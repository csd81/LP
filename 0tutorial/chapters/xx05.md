
-----

# Chapter 5: Production Problem

This chapter explores a **fundamental Linear Programming (LP) problem** in terms of model implementation: the **production problem**. This problem involves determining which products to manufacture to achieve the **maximum profit** when resources are limited. It is also referred to as the **product mix problem** or **production planning problem**.

The production problem is one of the oldest problems in **Operations Research**, and numerous tutorials use it as an introduction to mathematical programming (see, for example, [11, 12]). We will also present the **diet problem**, which seeks to find the least expensive combination of foods that meets all nutritional requirements. A common generalization of these two problems is also shown. The final section includes an overview of **integer programming**, where "packages" of raw materials and products can be bought and sold all at once.

The chapter focuses on how a single model can be extended to incorporate various circumstances one by one. We begin with a simple exercise that can even be solved manually and conclude with a very general and complex optimization model.

-----

## 5.1 Basic Production Problem

The simplest version of the production problem can be generally described as follows.

**Problem 8.**

Given a set of **products** and a set of **raw materials** needed for their production. Production is linear and can occur in any amount, with fixed **consumption rates** of raw materials: we know exactly how much of each raw material is consumed to produce **one unit** of each product. We have a fixed amount of each raw material available and a fixed unit revenue for each product.

**Determine the optimal amounts of all products to be manufactured** such that the consumption of each raw material does not exceed its availability, and the **total revenue** from all products is maximized.

This definition might be a little challenging to grasp. It primarily outlines the **model logic** and will be implemented in a model file. Let's look at a specific example of the production problem with supporting data.

**Problem 9.**

We have a manufacturing plant capable of producing three different products, named **P1, P2, and P3**. Four raw materials are required for production, named **A, B, C, and D**. We have precise data for the following:

  * Amount of each raw material required for producing 1 unit of each product.
  * Available amount of each raw material that can be used for production.
  * Revenue for 1 unit of each product.

This information can be viewed in a single table, as shown below.

| | **P1** | **P2** | **P3** | **Available** |
| :--- | :--- | :--- | :--- | :--- |
| **A** (electricity) | 200 kWh | 50 kWh | 0 kWh | 23000 kWh |
| **B** (working time) | 25 h | 180 h | 75 h | 31000 h |
| **C** (materials) | 3200 kg | 1000 kg | 4500 kg | 450000 kg |
| **D** (production quota) | 1 | 1 | 1 | 200 |
| **Revenue (per unit)** | **$252** | **$89** | **$139** | |

Note that any amount of each product can be produced, and the raw material requirements are **exactly proportional**. There is no other limitation than the **total availability** of each raw material. Amounts can also be fractional.

**Determine the optimal amount of P1, P2, and P3 to be produced** such that raw material availability is respected, and the total revenue from the products is maximized.

(Note that problem data are entirely fictional.)

Compared to "pure mathematical" models like the system of linear equations we saw previously, the problem data here includes **units**. However, **GNU MathProg** does not have a built-in feature to track the quantities or currencies of model elements (variables, parameters, constraints). We must work only with **scalars**. The general approach for handling units is to convert all data corresponding to the same quantity to the **same unit** and treat them consistently throughout the model. This must always be kept in mind during model formulation.

However, understanding the units in the problem is recommended because it helps us avoid mistakes by reminding us that **only scalars of the same unit should ever be added together**. For example, amounts in kWh and kg cannot be added. If adding them appears necessary, it means either the operation is wrong entirely, or we are missing one or more factors that would bring these quantities to the same dimension and unit.

Let's begin formulating the model. The first step is selecting the **decision variables**. The goal of optimization is to determine the values of these variables. Each solution obtained describes a decision on how the plant will be operated. Of course, not all solutions are feasible, and the revenues are also usually different. Therefore, we seek the **feasible solution with the highest revenue**.

The decision variables can be read directly from the problem description. The **amounts of each product to be determined** are the decision variables; these must definitely be determined by the optimization. The question is, should there be more variables? If we only know the amounts produced, we can calculate everything relevant in the plant: the exact amounts consumed of each raw material and the total revenue. Therefore, at this point, we do not need any more variables in our optimization model.

The **objective function** is easy to determine. The production amount of each product must be multiplied by its **unit revenue**, and the total revenue is the sum of these products.

What remains are the **constraints** and **variable bounds**. In general, the only requirement is that production can be zero or a positive number, but it definitely **cannot be negative**. So, each variable must be **nonnegative**; this is a **lower bound**. There is no upper bound, as any production amount is considered feasible as long as there is sufficient raw material for it. This brings us to the **only constraint**, which is about **raw material availability**. Based on the amounts produced (which are denoted by the variables), we can easily calculate how much of each raw material is used per product and in total. This total usage must not be greater than the availability of that particular raw material.

We have defined the variables, the objective, constraints, and bounds, so we are ready to implement our model in **GNU MathProg**. First, we will not use indexing and will implement it in the most straightforward way.

The variables denote production amounts. By convention, these are all in **dollars ($)**.

```
var P1, >=0;
var P2, >=0;
var P3, >=0;
```

Constraints are formulated next. For each production amount, it must be multiplied by the coefficient that describes **raw material consumption per product unit**. These must be summed for all three products to obtain the total consumption for a given raw material.

Note how the tabular data of the problem correspond to the implementation of constraints.

```
s.t. Raw_material_A:  200 * P1 +   50 * P2 +    0 * P3 <= 23000;
s.t. Raw_material_B:   25 * P1 +  180 * P2 +   75 * P3 <= 31000;
s.t. Raw_material_C: 3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:    1 * P1 +    1 * P2 +    1 * P3 <= 200;
```

Finally, the objective can also be defined based on production amounts. Note that each constraint is within its own unit for the raw material, and the objective is in the **$** unit. From now on, we use units consistently and will not refer to them.

```
maximize Raw_material: 252 * P1 + 89 * P2 + 139 * P3;
```

A `solve` statement can be inserted in the model, after which some additional post-processing work can be done to print the solution. The full code is below. We print the total revenue (the objective), the production of each product (the variables), and the usage of each raw material. In the usage part, we print both the total amount consumed for production and the amount remaining available.

```
var P1, >=0;
var P2, >=0;
var P3, >=0;

s.t. Raw_material_A:   200 * P1 +   50 * P2 +    0 * P3 <= 23000;
s.t. Raw_material_B:    25 * P1 +  180 * P2 +   75 * P3 <= 31000;
s.t. Raw_material_C:  3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:     1 * P1 +    1 * P2 +    1 * P3 <= 200;

maximize Raw_material: 252 * P1 +   89 * P2 +  139 * P3;

solve;

printf "Total Revenue: %g\n", ( 252 * P1 + 89 * P2 + 139 * P3);

printf "Production of P1: %g\n", P1;
printf "Production of P2: %g\n", P2;
printf "Production of P3: %g\n", P3;

printf "Usage of A: %g, remaining: %g\n",
            ( 200 * P1 + 50 * P2 + 0 * P3),
    23000 - ( 200 * P1 + 50 * P2 + 0 * P3);

printf "Usage of B: %g, remaining: %g\n",
            ( 25 * P1 + 180 * P2 + 75 * P3),
    31000 - ( 25 * P1 + 180 * P2 + 75 * P3);

printf "Usage of C: %g, remaining: %g\n",
             (3200 * P1 + 1000 * P2 + 4500 * P3),
    450000 - (3200 * P1 + 1000 * P2 + 4500 * P3);

printf "Usage of D: %g, remaining: %g\n",
            ( 1 * P1 + 1 * P2 + 1 * P3),
      200 - ( 1 * P1 + 1 * P2 + 1 * P3);
end;
```

In this model file, there is **no data section at all**; the data is **hard-coded** into the model. Therefore, we can solve it with `glpsol` without providing any additional data files, yielding the following result (showing only our `printf` results).

```
Total Revenue: 33389
Production of P1: 91.3386
Production of P2: 94.6457
Production of P3: 14.0157
Usage of A: 23000, remaining: -3.63798e-12
Usage of B: 20370.9, remaining: 10629.1
Usage of C: 450000, remaining: -5.82077e-11
Usage of D: 200, remaining: 0
```

We interpret the solutions as follows: **$33,389** is the **maximum revenue** that can be obtained. To achieve this, we produce **91.34 units of P1**, **94.65 units of P2**, and **14.02 units of P3**. Note that, in this case, it is allowed to produce **fractional amounts** of a product—this can occur in practice if the products and raw materials are chemicals, fluids, heat, electricity, or other divisible quantities.

Production consumes **all of A, C, and D**, but there is a **surplus of B** that is not used up. Some remaining amounts are reported as extremely small positive numbers. These are actually tiny **numerical errors** from the actual value of zero in the optimal solution because `glpsol` uses floating-point arithmetic, which isn't perfect. If this output is inconvenient, we can use the format specifier `%f` instead of `%g`, or alternatively, explicitly round down the numbers to be printed in the model using the built-in `floor()` function.

Another option is to add `--xcheck` as a command-line argument to `glpsol`. This forces the final solution to be recalculated with **exact arithmetic**, eliminating rounding errors.

```
glpsol -m model.mod -d data.dat --xcheck
```

One interesting observation about the solution is that **three of the remaining amounts are zero**. If we varied the problem data and solved the model repeatedly, it would turn out that, from the seven values printed (three production amounts and four remaining amounts), there are almost always **three zeroes**. Generally, the number of zeroes is the number of products, and the number of non-zeroes is the number of raw materials. (Exceptions occur in some special cases.) This is a beautiful property of production problems that is better understood by knowing how the solution algorithms (particularly the **simplex method**) work for LP problems. However, we are not focusing on the algorithms here, only the model implementations. Nevertheless, understanding what a good solution looks like is a very valuable skill.

We now have a working implementation for the specific production problem described. However, we know this solution is not very general. If we encounter a different production problem, we must understand and **tamper with the code** describing the model logic. Also, notice that the exact expressions describing the total consumption of each raw material appear **three times**: once in the constraints and twice in the post-processing work. This level of **redundancy** is typically considered bad code design, regardless of the programming language.

Our next task is to create a more general, **indexed model** that requires only a properly formatted data section to solve any production problem.

In the production problem, two sets are relevant: the set of **products** and the set of **raw materials**.

```
set Products;
set Raw_Materials;
```

We can also identify three important **parameters**. One for the production ratios, defined for each pair of raw materials and products; we'll call it `Consumption_Rate`. One for availability, defined for each raw material; we name it `Storage`. The name "storage" captures the logic of how raw materials work from a modeling perspective: they are present in a given amount beforehand, like physically stored material, and no more than this amount can be used for production. Another parameter is `Revenue`, defined for each product.

```
param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
```

Notice how **indexing** is used so that each `param` statement refers not just to a single scalar but to a **collection of values**. For `Consumption_Rate` and `Revenue`, we also provide a default value of **zero**. This means if we do not provide data, we assume no raw material need or revenue for that particular case.

Also, in GNU MathProg, we can define **bounds and other value restrictions for parameters**. In this case, all three parameters are forced to be **nonnegative** by the `>=0` restriction. This is generally good practice if we do not expect specific values for a given parameter. If a restriction is violated by a value provided for the parameter (for example, in the data section or calculated on the spot), model processing terminates with an error describing the situation. It's much easier to notice and correct errors this way than to allow a wrong parameter value in the model, which could lead to an invalid solution. It is typically difficult to debug a model once it can be processed, so explicitly checking data is highly recommended.

The variables can now be defined. They denote production amounts, and each must be nonnegative.

```
var production {p in Products}, >=0;
```

Finally, all the constraints can be described by one general `s.t.` statement. The logic is as follows: There is a single inequality for each raw material: its **total consumption cannot exceed its availability**. The availability is simply described as a parameter, but the total consumption is obtained by a **summation**. We must sum, for each product, its amount multiplied by the consumption rate of that particular raw material.

```
s.t. Material_Balance {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p]
    <= Storage[r];
```

The objective is obtained as a **sum** for all products, where the amounts must be multiplied by the unit revenues.

```
maximize Total_Revenue:
    sum {p in Products} Revenue[p] * production[p];
```

Finally, we can implement a general post-processing routine to print the total revenue, production amounts, and raw material usages. The full model file is below.

```
set Products;
set Raw_Materials;

param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;

var production {p in Products}, >=0;

s.t. Material_Balance {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p]
    <= Storage[r];

maximize Total_Revenue: sum {p in Products} Revenue[p] * production[p];

solve;

printf "Total Revenue: %g\n", sum {p in Products} Revenue[p] * production[p];

for {p in Products}
{
    printf "Production of %s: %g\n", p, production[p];
}

for {r in Raw_Materials}
{
  printf "Usage of %s: %g, remaining: %g\n",
      r, sum {p in Products} Consumption_Rate[r,p] * production[p],
      Storage[r] - sum {p in Products} Consumption_Rate[r,p] * production[p];
}
end;
```

If the corresponding data file is implemented as follows, we should get the same result as with the straightforward implementation.

```
data;
set Products := P1 P2 P3;
set Raw_Materials := A B C D;

param Storage :=
  A 23000
  B 31000
  C 450000
  D 200
  ;

param Consumption_Rate:
      P1   P2   P3 :=
  A  200   50    0
  B   25  180   75
  C 3200 1000 4500
  D    1    1    1
;

param Revenue :=
  P1 252
  P2 89
  P3 139
  ;
end;
```

Although the model is very general and compact, it still contains some **redundancy**. The total consumed amount of each raw material is still represented three times in the code. At least we don't have to rewrite that code ever again if another problem's data is given; we only have to modify the data section. However, we still want to eliminate this redundancy.

Remember that we can introduce parameters in the model section and calculate values on the spot. If we are after the `solve` statement, then even variable values can be referred to, as their values have already been determined by the solver. We introduce `Material_Consumed` and `Material_Remained` to denote the total amount consumed and the amount remaining for each material.

```
param Material_Consumed {r in Raw_Materials} :=
    sum {p in Products} Consumption_Rate[r,p] * production[p];

param Material_Remained {r in Raw_Materials} :=
    Storage[r] - Material_Consumed[r];

for {p in Products}
{
    printf "Production of %s: %g\n", p, production[p];
}

for {r in Raw_Materials}
{
    printf "Usage of %s: %g, remaining: %g\n",
    r, Material_Consumed[r], Material_Remained[r];
}
```

The solution should be exactly the same as before for the same data file. But now, some of the redundancy has been eliminated from the model section. Unfortunately, the parameter for the total amounts consumed **cannot be used** in the constraints where it appears first. More on that later.

-----

## 5.2 Introducing Limits

Now that we have a working implementation for arbitrary production problems, let's change the problem description itself.

**Problem 10.**

Solve the **production problem**, provided that for each **raw material** and each **product**, a **minimum** and **maximum** total **usage** is also given that must be respected by the solution.

The usage of a raw material is the total amount consumed, and the usage of a product is the total amount produced.

These are **additional restrictions** on the production mix. Let's see how this affects the model formulation. The problem remains almost the same; we just need to exclude additional solutions from the **feasible set**—namely, those where any newly introduced restriction is violated.

The change only added new restrictions, so the **variables**, the **objective function**, and even the existing **constraints** and **bounds** can remain the same. The new limits must be implemented by new constraints and/or bounds. We also need to provide new options in the **data sections** where these limits can be given as **parameter** values.

There are four limits altogether:

  * **Upper limit on production amount.** The production amount for any product $p$ appears as the $production[p]$ variable in the model. A constant upper limit for this value can easily be implemented as a **linear constraint**, but an even easier way is to implement it as an **upper bound** of the $production$ variable.
  * **Lower limit on production amount.** The same applies here. Just note that there is already a non-negativity bound defined for the variables, and defining two lower or two upper bounds on the same variable is forbidden in **GNU MathProg**.
  * **Upper limit on raw material consumption.** The total consumption of each raw material is already represented in the model as an **expression**. Actually, the only constraint in the production problem so far defines an upper limit for this expression as $Storage[r]$ for any raw material $r$. Therefore, there's no need to further define upper bounds. If one wants to give an extra upper limitation for total consumption, it can be done without modifying the **model section**, simply by decreasing the appropriate $Storage$ parameter value in the **data section**.
  * **Lower limit on raw material consumption.** As we noted before, the expression already appears in a constraint. We need to implement another constraint with exactly the same expression, but expressing a **minimum limit** instead of the maximum.

First, we have to add the extra parameters to describe the limits.

```
param Storage {r in Raw_Materials}, >=0, default 1e100;

param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;

param Revenue {p in Products}, >=0, default 0;

param Min_Usage {r in Raw_Materials}, >=0, <=Storage[r], default 0;

param Min_Production {p in Products}, >=0, default 0;

param Max_Production {p in Products}, >=Min_Production[p], default 1e100;
```

The new $Min\_Usage$ is for the **minimum** total consumption for each raw material, while parameters $Min\_Production$ and $Max\_Production$ are for the **lower and upper limits** of production for each product. The fourth limit parameter is the original $Storage$, for the **upper limit** of raw material consumption. All these limit parameters now have sensible bounds and default values. Lower limits default to $0$, while upper limits default to $10^{100}$, a massive number that we **expect not to appear** in problem data. Also, lower limits must **not be larger** than upper limits. Meanwhile, all limits must be **non-negative**. Remember that these restrictions on parameter values are valuable to **prevent mistakes in data sections**, but we don't expect them to contribute to generating and solving the model once satisfied. This is in contrast to **variable bounds**, which are part of the model formulation and may affect solutions.

The variables and the objective function remain the same. However, we must add **three additional constraints** to tighten the search space of the model. Each of the four constraints corresponds to one of the four limits mentioned. The $Material\_Balance$ constraint is for the upper limit of total consumption of raw materials; this one was originally there and was left unchanged.

```
var production {p in Products}, >=0;

s.t. Material_Balance {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p]
    <= Storage[r];

s.t. Cons_Min_Usage {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p]
    >= Min_Usage[r];

s.t. Cons_Min_Production {p in Products}:
    production[p] >= Min_Production[p];

s.t. Cons_Max_Production {p in Products}:
    production[p] <= Max_Production[p];

maximize Total_Revenue: sum {p in Products} Revenue[p] * production[p];
```

The **post-processing work** to print out solution data may remain the same as for the original model. Now, our **model section** is ready.

To demonstrate how it works, consider the following production problem with limits.

**Problem 11.**

Solve the **production problem** described in Problem 9, but with the following restrictions added:

  * Use at least $20,000$ hours of working time (**raw material B**).
  * Fill the production quota: produce at least $200$ units (**raw material D**), which is also the maximum for that raw material.
  * Produce at most $10$ units of **P3**.

Since the problem is simply an "**extension**" of the original one, its implementation can be done by just extending the **data section** with the aforementioned limits. Note that each parameter is indexed with the set of all raw materials and all products. Those that do not appear in the data section will simply default to $0$ for lower limits and $10^{100}$ for upper limits, effectively making the limits redundant. In that case, they don't modify the search space of the model because those limits are true anyway for any otherwise feasible solution.

```
param Min_Usage :=
    B 21000
    D 200
    ;

param Min_Production :=
    P2 100
    ;

param Max_Production :=
    P3 10
    ;
```

The solution to the problem is now slightly different due to the newly defined bounds.

```
Total Revenue: 32970
Production of P1: 90
Production of P2: 100
Production of P3: 10
Usage of A: 23000, remaining: -7.27596e-12
Usage of B: 21000, remaining: 10000
Usage of C: 433000, remaining: 17000
Usage of D: 200, remaining: 0
```

This means that **$90$ units of P1, $100$ units of P2, and $10$ units of P3** are produced. We can verify that all limitations are met. It's interesting to note that all variables in this solution are **integers**, even though they aren't forced to be. This means that if the problem were changed to consider only integer solutions (e.g., if the product must be produced in whole numbers), this solution would still be valid. Moreover, it would also be the **optimal solution**, because restricting variables to only integer values just makes the model's search space tighter. So, if a solution is optimal even in the original model—meaning there are no better solutions—then there shouldn't be better solutions in the more restrictive **integer counterpart** either.

Now, our implementation for limits is complete. But we can still improve the model implementation by making it a bit more **readable** and less **redundant**. First, there's a neat feature in **GNU MathProg**: if a **linear expression** can be bounded by both an upper and a lower value, and both limits are constants, they can be defined in a **single constraint** instead of two. Using this, we can reduce the number of `s.t.` statements from four to two in our model section, as follows. All other parts of the model, the data, and the solution remain the same.

```
s.t. Material_Balance {r in Raw_Materials}: Min_Usage[r] <=
    sum {p in Products} Consumption_Rate[r,p] * production[p]
    <= Storage[r];

s.t. Production_Limits {p in Products}:
    Min_Production[p] <= production[p] <= Max_Production[p];
```

There is another thing we can improve, which is actually a **modeling technique** rather than a language feature: we can introduce **auxiliary variables** for linear expressions. The variables, constraints, and objective function will look like this:

```
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;

s.t. Usage_Calc {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Revenue[p] * production[p];

maximize Total_Revenue: total_revenue;
```

Observe the newly introduced variable `usage`. We intend for this variable to denote the total consumption of a raw material. Therefore, we add the `Usage_Calc` constraint to ensure this. We now have that variable throughout the model to denote this value. We also do this for the total revenue, denoted by the variable `total_revenue`, calculated in the `Total_Revenue_Calc` constraint, and then used in the objective function. The objective function is actually the `total_revenue` variable itself.

Now, notice that all the expressions we have to limit are actually variables, and all the limits are constants. This means the constraints for the limits can be converted to **bounds** of these variables, specifically `production` and `usage`. This way, we effectively got rid of all the previously defined constraints and converted them into bounds, but we needed two more constraints (`Usage_Calc` and `Total_Revenue_Calc`) to calculate the values of `usage` and `total_revenue`.

You might think the main importance of introducing the new variable is the possibility of using bounds instead of `s.t.` statements, making our implementation shorter. This is just one example of its usefulness. The key point is that if some expression is used more than once in our model, we can simply introduce a **new variable** for it, define a new constraint so that the variable equals that expression, and then use the variable instead of that expression everywhere.

Think about this: does adding auxiliary variables change the **search space**? Formally, yes. The search space has a different **dimension**. There are more variables, so in a solution to the new problem, we have to decide more values. However, note that feasible solutions of the new model will be in a **one-to-one correspondence** with the original ones. For a solution feasible to the original problem, we can introduce the auxiliary variable with the corresponding value of the expression and get a feasible solution for the extended problem. Conversely, each feasible solution in the extended problem must have its auxiliary variable equal to the expression it is defined for, so it can be substituted back into the model to return to a feasible solution of the original model.

In short, the search space formally changes, but the (feasible) solutions for the problem **logically remain the same**.

An important question arises: how does introducing auxiliary variables change the course of the algorithms and **solver performance**? The general answer is that we don't know. There are more variables, so computational performance might be slightly worse, but this is often **negligible** because the main difficulty of solving a model in practice comes from the complexity of the search space, which is logically unchanged. Of course, if there are magnitudes more auxiliary variables than ordinary variables and constraints, it might cause technical problems. Also note that, in theory, the solver has the right to substitute out auxiliary variables, effectively reverting back to the original problem formulation, but we generally cannot be sure that it does so. The solver doesn't see which of our variables are intended to be "auxiliary." If there is an equation constraint in the model, the solver might use that equation to express one of the variables appearing in it and perform a substitution, even if we hadn't considered it auxiliary.

In short, the course of the solution algorithm may differ, and the computational performance might change, but this is usually negligible.

Also note that we previously introduced some new values in the post-processing work so we didn't have to write the total consumption expression twice. That was done by introducing a new parameter, not a variable, and only worked **after** the `solve` statement because it involved variable values only available when the model is solved. However, now with an auxiliary variable introduced for total consumption, we can use it **both before and after** the `solve` statement. Therefore, we write this expression down in code only once, and that redundancy is finally completely gone.

The ultimate model code for the limits is below. Note that the data section and solution remain the same as before. Also note that we didn't have to introduce new parameters after the `solve` statement, as the auxiliary variables do the work.

```
set Products;
set Raw_Materials;

param Storage {r in Raw_Materials}, >=0, default 1e100;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
param Min_Usage {r in Raw_Materials}, >=0, <=Storage[r], default 0;
param Min_Production {p in Products}, >=0, default 0;
param Max_Production {p in Products}, >=Min_Production[p], default 1e100;

var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;

s.t. Usage_Calc {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Revenue[p] * production[p];

maximize Total_Revenue: total_revenue;

solve;

printf "Total Revenue: %g\n", total_revenue;

for {p in Products}
{
    printf "Production of %s: %g\n", p, production[p];
}

for {r in Raw_Materials}
{
    printf "Usage of %s: %g, remaining: %g\n",
        r, usage[r], Storage[r] - usage[r];
}

end;
```

-----

## 5.3. Maximizing minimum production

In the previous sections, we saw a complete implementation for the production problem where total raw material consumption and production can be limited by constants. Now, let's modify the optimization goal to **maximize the minimum production**. The exact definition is as follows.

**Problem 12.**

The problem requires us to **maximize the minimum production** amount among all products, while keeping the problem data the same. The minimum production refers to the product for which the least amount is manufactured.

Whether we start with the simple model or the one with added limitations, this problem only requires us to modify the **objective function**. This means the **feasible solutions** and search space remain exactly the same.

This also makes the **revenue parameter** irrelevant, because we are no longer interested in the total monetary value of the products, but only the production amounts (specifically, the minimum of those amounts).

We have already solved a similar problem with the system of linear equations (Problem 7 from Section 4.8), where the objective was to minimize the maximum error across all equations. Here, we need to maximize the minimum production. The required **modeling technique** is indeed similar.

The idea is to introduce a new **variable** to represent the minimum of all production amounts. Specifically, this variable will denote a **lower bound** for all individual production amounts. This lower bound also serves as a lower bound for the minimum of those amounts. If this variable is **maximized**, the optimization process will eventually increase its value as much as possible until it reaches the true minimum of the production amounts.

Using this modeling trick, we can ensure that the final optimal solution found will correspond to the maximal possible value of the minimum production amount. This is a general method that works for any set of linear expressions where either the minimum must be maximized or the maximum must be minimized.

In the implementation, parameters and post-processing work remain the same, as do the existing variables, bounds, and constraints from the extended model (including `Min_Production`, `Max_Production`, and auxiliary variables for usage and revenue):

```
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;

s.t. Usage_Calc {r in Raw_Materials}:
  sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];

s.t. Total_Revenue_Calc: total_revenue =
  sum {p in Products} Revenue[p] * production[p];
```

The change is that, instead of maximizing total revenue, we set the minimum production as the new objective. This requires introducing a new variable, `min_production`, to denote a lower bound for all production amounts, and a constraint to ensure that the variable is, in fact, a lower bound. Then, this new variable is maximized as the objective function.

```
var min_production;

s.t. Minimum_Production_Calc {p in Products}:
  min_production <= production[p];

maximize Minimum_Production: min_production;
```

The post-processing code can be the same as before, so we print the same data as we did for the total revenue objective. We only add a `printf` statement to emphasize the minimum production amount, which is our current objective.

```
printf "Minimum Production: %g\n", min_production;
```

Note that in our code, `min_production` is the name of the **variable**, and `Minimum_Production` is the name of the **objective function**. In GNU MathProg, we could use both as values. However, be cautious when referring to the objective by its name because constant terms in the objective are omitted. Constant terms do not affect the selection of the optimal solution, only the value of the objective. Therefore, it is recommended to refer to the objective function value using the variable `min_production` instead.

We can now run our model to solve two problems.

**Example 1: Ignoring Production/Usage Limits**

In the first example, all the limits (`Min_Usage`, `Min_Production`, `Max_Production`) are ignored, except for the `Storage` capacity. Note that in the data section, we can begin rows with a hash mark (`#`). This turns the row into a **comment**, effectively excluding it from processing. The data section looks like this:

```
data;

set Products := P1 P2 P3;
set Raw_Materials := A B C D;

param Storage :=
    A 23000
    B 31000
    C 450000
    D 200
    ;

param Consumption_Rate:
       P1    P2    P3 :=
  A   200    50     0
  B    25   180    75
  C  3200  1000  4500
  D     1     1     1
  ;

param Revenue :=
    P1 252
    P2 89
    P3 139
    ;

param Min_Usage :=
    # B 21000
    # D 200
    ;

param Min_Production :=
    # P2 100
    ;

param Max_Production :=
    # P3 10
    ;

end;
```

Note that revenue data are not strictly necessary in this model, but it is not an error to assign them values, as long as the parameter is represented in the model section.

The solution to the problem results in a minimum production amount of **51.72**.

```
Total Revenue: 24827.6
Minimum Production: 51.7241
Production of P1: 51.7241
Production of P2: 51.7241
Production of P3: 51.7241
Usage of A: 12931, remaining: 10069
Usage of B: 14482.8, remaining: 16517.2
Usage of C: 450000, remaining: 0
Usage of D: 155.172, remaining: 44.8276
```

It turns out that production is **balanced** to the edge to achieve this solution. All resources are distributed evenly, and all three products are produced in an **equal amount**. If we consider the objective, this isn't surprising. Why would we produce any product amount above the minimum if it offers no advantage to the objective function, but represents a disadvantage in terms of raw materials consumed?

It looks like raw material **C is the bottleneck** in this problem. We call a factor a **bottleneck** if changing it has a visible impact on the final solution while other factors remain the same—for example, the most scarce resource. If there were slightly less or more of raw materials A, B, and D, the solution would be the same because all of C is completely used up and distributed evenly. This knowledge can be fundamental in real-world optimization because it informs decision-makers that improving some factors is unnecessary. On the other hand, slightly more or less of C would likely result in slightly more or less production (likely, because there could be other limitations we do not see). For this reason, raw material **C is the bottleneck** in this particular production problem.

**Example 2: With Constraints** (Excluding $P3 \le 10$)

In the second example, **Problem 11** is used but without the constraint on $P3$. This means all limitations are now included, except for the restriction that $P3$ is maximized at 10 units. Note that if this constraint were enabled, the optimal solution would obviously be 10 units, as the former solution we already know produces exactly 10 units of $P3$, and there cannot be more.

In short, we only get a meaningful new problem if we **omit** the constraint maximizing $P3$ at 10 units.

```
Total Revenue: 27142.1
Minimum Production: 43.8596
Production of P1: 43.8596
Production of P2: 112.281
Production of P3: 43.8596
Usage of A: 14386, remaining: 8614.04
Usage of B: 24596.5, remaining: 6403.51
Usage of C: 450000, remaining: 0
Usage of D: 200, remaining: 0
```

The solution is slightly different here. Now, only **P1 and P3 are produced in equal amounts**, both at the minimum production amount of **43.86**. Also, not only C but **D is also totally used up**. Note that a much larger amount of P2 is needed because all 200 units of D must be used up in this problem. This answers a former question: why is it advantageous to produce products above the minimum limit? Because it might help satisfy the minimum production and/or minimum consumption constraints.

Note that the objective in this case is slightly **worse** than that of the first example problem, where the objective was 51.72. This is a natural consequence of differences in the data. In the second example, the data were the same except for **additional constraints** on consumption and production. If a problem is more constrained, we can only get an optimal solution with the **same, or a worse, objective value**.

Generally, if only the objective is changed in a model, the set of **feasible solutions remains the same**, because the objective only guides the selection of the most suitable solution, not which solutions are feasible. In this case, the new objective function involved a new variable, `min_production`, which served as a lower bound and was maximized.

Note that, in theory, `min_production` does not need any lower bound and can even be allowed to be zero or negative. The solution would still be feasible. However, such solutions are not reported because they are not optimal. Therefore, only those feasible solutions are interesting for which `min_production` is not only a valid lower bound on production amounts but is actually **strict**—that is, it equals the minimum production amount.

Among these interesting solutions, `min_production` works just like an **auxiliary variable**. Each optimal solution where `min_production` is a strict bound corresponds to a feasible solution of the original problem where revenues were maximized, and vice versa.

-----

## 5.4 Raw Material Costs and Profit

We have seen an example where only the objective was changed. Now let's look at another example, which is a more natural extension to the problem. From now on, raw materials are no longer considered **"free"**: they must be produced, purchased, stored, etc. In general, they have **costs**. Just as there is a revenue for each product per unit produced, there is now a **cost for each raw material per unit consumed**.

**Problem 13.**

Solve the production problem, but now instead of optimizing for revenue, optimize for **profit**. The profit is defined as the difference between the **total revenue** from products and the **total cost** of raw materials consumed for production. The cost for each raw material is proportional to the material consumed and is independent of which product it is used for. A single **unit cost** for each raw material is given.

This is the general description of the problem. We will again use an example for demonstration, which includes costs for raw materials. The other data for the example problem remain the same as before.

**Problem 14.**

Solve the production problem with the objective of **maximized profit**, using the following problem data, with unit costs of raw materials added.

| | **P1** | **P2** | **P3** | **Available** | **Cost (per unit)** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **A** (electricity) | 200 kWh | 50 kWh | 0 kWh | 23000 kWh | **$1** |
| **B** (working time) | 25 h | 180 h | 75 h | 31000 h | **$0.07** |
| **C** (materials) | 3200 kg | 1000 kg | 4500 kg | 450000 kg | **$0.013** |
| **D** (production quota) | 1 | 1 | 1 | 200 | **$8** |
| **Revenue (per unit)** | **$252** | **$89** | **$139** | | |

Additionally, there are three limitations, as before:

  * Use at least **20,000 h** of working time (raw material B).
  * Fill the production quota: produce at least **200 units** (raw material D), which also happens to be the maximum for that raw material.
  * Produce at most **10 units of P3**.

Again, we want to write a general model and a separate, corresponding data section for the particular example problem. The starting point is the model and data sections we obtained by solving **Problem 11** (where limits were introduced), as both are almost ready; we only need to implement some modifications.

First, we definitely need a new parameter that describes the costs. Let's call this parameter `Material_Cost`. We can simply add it to the model section. No other data is needed.

Before proceeding, let's observe what happens when material costs are zero. This means our problem is the same as the original, where raw materials were free. This means the current problem with raw material costs is a **generalization** of the original problem. In other words, the original problem is a **special case** of the current problem where all raw material costs are zero. For this reason, it is sensible to give a **zero default value** to material costs. This makes data files implemented for the original problem compatible with our new model as well.

```
param Material_Cost {r in Raw_Materials}, >=0, default 0;
```

We also know the corresponding data, which can be implemented in the data section. Each raw material has a nonzero cost.

```
param Material_Cost :=
  A  1
  B  0.07
  C  0.013
  D  8
  ;
```

Beyond the data, the only difference in the model is the **objective value**. We could simply change the objective line and our model would be complete. However, for better readability, we will introduce an **auxiliary variable** for the profit and use it instead. The modified part of the model section is below. Only three lines of code changed: the `profit` variable was introduced, the objective changed, and the `Profit_Calc` constraint was added to ensure that the `profit` variable obtains the corresponding value. We also print it after the `solve` statement.

```
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;
var profit;

s.t. Usage_Calc {r in Raw_Materials}:
    sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Revenue[p] * production[p];

s.t. Profit_Calc: profit = total_revenue - 
    sum {r in Raw_Materials} Material_Cost[r] * usage[r];

maximize Profit: profit;

solve;

printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
```

Now both the model and the data sections are ready. If we optimize for profit now, we get the following result.

```
Total Revenue: 22453.9
Profit: 1577.45
Production of P1: 25.4839
Production of P2: 164.516
Production of P3: 10
Usage of A: 13322.6, remaining: 9677.42
Usage of B: 31000, remaining: 0
Usage of C: 291065, remaining: 158935
Usage of D: 200, remaining: 0
```

Now let's examine this solution briefly. Logically, the **search space** did not change: exactly the same solutions are **feasible** in both the original problem (maximizing revenue) and the current problem (maximizing profit). This explains the difference in total revenues. In the original problem, the optimal total revenue was **$32,970**, achieved by producing 90 units of P1, 100 units of P2, and 10 units of P3. However, optimizing for **profit** yields a total revenue of **$22,453.87**, which is worse. The profit in this case is much smaller, **$1,577.45**, meaning most of the revenue is consumed by raw material costs. The production is also slightly different: 25.48 units of P1, 164.52 units of P2, and 10 units of P3 are now produced.

Although revenue is significantly higher for the original solution, we can now be certain that the profit would be no more than **$1,577.45** in that case either.

-----

## 5.5 Diet Problem

We have seen several versions of the production problem. Now, we consider a seemingly unrelated problem called the **diet problem** [13, 14], or the **nutrition problem**.

**Problem 15.**

Given a set of **food types** and a set of **nutrients**. Each food consists of a given, fixed ratio of the nutrients.

We aim to arrange a **diet**, which is any combination of the set of food types, in any amount. However, for each nutrient, there is a **minimum requirement** that the diet must satisfy to be healthy. Also, each food has its own proportional **cost**.

**Find the healthy diet with the lowest total cost of food involved.**

After the general problem definition, let's look at a specific example.

**Problem 16.**

Solve the diet problem with the following data. There are five food types, named **F1 to F5**, and four nutrients under focus, named **N1 to N4**. The contents of a unit amount of each food, the unit cost of each food, and the minimum requirement of each nutrient are shown below.

| | **N1** | **N2** | **N3** | **N4** | **Cost (per unit)** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **F1** | 30 | 5.2 | 0.2 | 0.0001 | **450** |
| **F2** | 20 | 0 | 0.7 | 0.0001 | **220** |
| **F3** | 25 | 2 | 0.1 | 0.0001 | **675** |
| **F4** | 13 | 3.6 | 0 | 0.0002 | **120** |
| **F5** | 19 | 0.1 | 0 | 0.0009 | **500** |
| **Required** | **2000** | **180** | **30** | **0.04** | |

The diet problem is regarded as one of the first problems that led to the field of **Operations Research**.

Note that the underlying dimensions are slightly different in the diet problem and the production problem. We omitted fictional physical dimensions here, but the scale of each nutrient suggests which data belong to a single dimension. In this table, each column corresponds to a single nutrient and has its own unit of measure. The last column shows unit costs.

Usually, when implementing a model, the first things we must decide are: how our **freedom of choice** will be implemented as **decision variables**, how the **search space** can be described by **constraints**, and how the **objective** can be calculated. These steps are essential for deciding whether a mathematical programming approach is even suitable for a real-world problem.

However, we will instead start by defining all the data available in the problem and then proceed with the steps above. This makes defining the variables, constraints, and objectives easier afterward. So, the first part of modeling in GNU MathProg is defining the **sets and parameters**. These are either calculated on the spot or provided later in a data section.

Two sets appear in the problem: one for **food types** and one for **nutrients**.

```
set FoodTypes;
set Nutrients;
```

There are three parameters available. One denotes **food costs**, defined for each food type. One denotes the **minimum required amount of nutrients**, defined for each nutrient. Finally, one parameter denotes the **contents of food**, given by a unit amount for each pair of food type and nutrient. For example, each unit of F2 contains 20 units of N1, 0.7 units of N3, and 0.0001 units of N4. The default values are all set to zero, and all these parameters are nonnegative.

```
param Food_Cost {f in FoodTypes}, >=0, default 0;
param Content {f in FoodTypes, n in Nutrients}, >=0, default 0;
param Requirement {n in Nutrients}, >=0, default 0;
```

Now that all data are defined as sets and variables, we must identify our freedom of choice. The **amounts of each food used** are clearly under our decision. If we know these amounts, we can easily calculate total cost and nutrient contents, determining if the diet is healthy and how much it costs. This means we should define a variable denoting **food consumption** for each food type, and no other variables are needed.

We introduce a variable named `eaten` to denote the amount of each food included in the diet. This variable is nonnegative and indexed over the set of food types. We also introduce the auxiliary variable `total_costs` so it can be printed more easily.

```
var eaten {f in FoodTypes}, >=0;
var total_costs;
```

There is one significant factor restricting which diets are acceptable: the **total nutritional content**. This translates into a constraint for each nutrient. The total amount contained in the selected diet must be summed up, and this total must be **no less than** the minimal requirement for that nutrient.

Additionally, there is another constraint for calculating the auxiliary variable denoting total food costs.

```
s.t. Nutrient_Requirements {n in Nutrients}:
    sum {f in FoodTypes} Content[f,n] * eaten[f] >= Requirement[n];

s.t. Total_Costs_Calc: total_costs =
    sum {f in FoodTypes} Food_Cost[f] * eaten[f];
```

With the auxiliary `total_costs` variable, defining the objective is straightforward.

```
minimize Total_Costs: total_costs;
```

After the `solve` statement, we can write our own printing code to show the solution found. This time, we show the amount of each food in the diet, as well as the total consumption per nutrient alongside the lower limit. Our model section is now ready.

```
set FoodTypes;
set Nutrients;

param Food_Cost {f in FoodTypes}, >=0, default 0;
param Content {f in FoodTypes, n in Nutrients}, >=0, default 0;
param Requirement {n in Nutrients}, >=0, default 0;

var eaten {f in FoodTypes}, >=0;
var total_costs;

s.t. Nutrient_Requirements {n in Nutrients}:
    sum {f in FoodTypes} Content[f,n] * eaten[f] >= Requirement[n];

s.t. Total_Costs_Calc: total_costs =
    sum {f in FoodTypes} Food_Cost[f] * eaten[f];

minimize Total_Costs: total_costs;

solve;

printf "Total Costs: %g\n", total_costs;

param Nutrient_Intake {n in Nutrients} :=
    sum {f in FoodTypes} Content[f,n] * eaten[f];

for {f in FoodTypes}
{
    printf "Eaten of %s: %g\n", f, eaten[f];
}

for {n in Nutrients}
{
    printf "Requirement %g of nutrient %s done with %g\n",
    Requirement[n], n, Nutrient_Intake[n];
}

end;
```

Now we implement the specific problem mentioned. It is described in a single data section as follows.

```
data;
set FoodTypes := F1 F2 F3 F4 F5;
set Nutrients := N1 N2 N3 N4;

param Food_Cost :=
    F1 450
    F2 220
    F3 675
    F4 120
    F5 500
    ;

param Content:
      N1  N2  N3     N4 := 
    F1 30 5.2 0.2 0.0001
    F2 20   . 0.7 0.0001
    F3 25   2 0.1 0.0001
    F4 13 3.6   . 0.0002
    F5 19 0.1   . 0.0009
    ;

param Requirement :=
    N1 2000
    N2 180
    N3 30
    N4 0.04
    ;
end;
```

Solving the problem gives the following result:

```
Total Costs: 29707.2
Eaten of F1: 0
Eaten of F2: 42.8571
Eaten of F3: 0
Eaten of F4: 49.2014
Eaten of F5: 28.7489
Requirement 2000 of nutrient N1 done with 2042.99
Requirement 180 of nutrient N2 done with 180
Requirement 30 of nutrient N3 done with 30
Requirement 0.04 of nutrient N4 done with 0.04
```

The optimal objective is **$29,707.2**. This literally means that any diet containing at least 2,000 units of N1, 180 units of N2, 30 units of N3, and 0.04 units of N4, using foods F1 through F5, would cost at least **$29,707.2**, and there exists a solution to obtain exactly this number.

The optimal solution only uses **F2, F4, and F5**. This means that if F1 and F3 were omitted from the problem data altogether, the optimal solution would be exactly the same. Introducing a new food type only **increases freedom** in the model, leaving any previously feasible solutions feasible, and potentially adding new ones. We can also observe that **N1 is the only nutrient** for which consumption in the optimal diet is **more than** the minimal requirement (2,042.99 units vs. 2,000). For the other three nutrients, there is exactly enough. This suggests the solution shows a diet that is **balanced to the edge** to meet minimum requirements while optimizing cost.

 
-----

## 5.6 Arbitrary Recipes

The implementations of the **diet problem** and the **production problem** are surprisingly similar. This similarity extends to the number of sets, parameters, variables, constraints, the content of those constraints, and the objective. In this section, we will show how the diet problem can be viewed as a production problem. Finally, we will demonstrate a production problem with **arbitrary recipes** that generalizes both problems simultaneously.

There are two ways to represent a diet problem as a production problem.

1.  **Products are Food Types, Raw Materials are Nutrients.** This makes sense from a real-world perspective as well. You can think of food as being "produced" from its constituent nutrients in specific ratios. When dieting, we consume products and break them down into nutrients, so the process is simply reversed in time. The products have costs, like foods, and the amounts exactly define the solution. The only difference is that instead of "storage" amounts for raw materials, which serve as an **upper bound** for usage, we have a **lower bound** because each nutrient must be consumed in a minimal total amount for a healthy diet. However, this feature is already implemented in the limits extension (Problem 10). Another detail is that food "production" should be **minimized** instead of maximized, but we can easily achieve this by representing food costs as **negative revenues** in the model. Technically, rewriting our diet problem into a production problem with limits and negative unit revenues is straightforward if we consider **food types as the products** and **nutrients as the raw materials**.

2.  **Products are Nutrients, Raw Materials are Food Types.** This matches the timeline: foods are the "inputs" available first, and the products are the nutrients we want to obtain through the process. However, there are more differences in this representation that might make it feel unnatural. There are no upper or lower limits for foods, but there is a lower limit for nutrients, which implies a minimum production amount for each product in the production problem context. There are no costs for the nutrients, only for the foods, meaning the production problem would have costs only for raw materials and **zero revenues** for all products.

The most significant difference, which prevents us from directly using the standard production model in this second representation, is that the **logic of production is reversed**. In the standard production problem, **many raw materials produce a single product** in given ratios. In the diet problem context, a **single raw material (food) produces many products (nutrients)** in given ratios.

At this point, we could say the second representation is flawed and stick to the first one. Technically, nothing stops us from doing that. However, the second representation suggests a valuable generalization for the production problem itself: **What if we relax the rule that there is only a single product in each production step?** This leads us to the **production problem with arbitrary recipes**.

A **recipe** describes a process that consumes several **inputs** at once and produces several **outputs** at once, in specific amounts. Each recipe can be utilized in any volume, and both inputs and outputs scale proportionally according to this volume.

This concept of recipes can describe both the production problem and the diet problem:

  * In the **production problem**, there is one recipe for each product. That recipe produces only that particular product as **output** but can consume any given combination of raw materials as **inputs**.
  * In the **diet problem**, there is one recipe for each food type. That recipe consumes only that particular food type as an **input** but can produce any given combination of nutrients as **outputs**.
  * Furthermore, there may be other problems involving **many inputs and many outputs** simultaneously in a single recipe. Neither the standard production nor the diet problem covers these cases alone.

We can now define the production problem with arbitrary recipes as follows.

-----

**Problem 17.**

Given a set of **raw materials** and a set of **products**, there is also a set of **recipes** defined.

Each recipe describes the ratio in which it **consumes raw materials** and **produces products**; these ratios are arbitrary nonnegative numbers. Each recipe may be utilized in an arbitrary amount, referred to as its **volume**.

  * There is a **unit cost** defined for each raw material and a **unit revenue** for each product.
  * There can be **minimal and maximal total consumption** amounts defined for each raw material, and **minimal and maximal total production** amounts defined for each product.
  * For practical purposes, the total cost of consumed raw materials is limited: it **cannot exceed a given value**, which represents the initial funds available for purchasing raw materials.

Find the optimal production plan, where recipes are utilized in arbitrary volumes, such that all consumption and production limits are satisfied, and the **total profit is maximal**. Total profit is the difference between total revenue from products and the total cost of raw materials consumed.

-----

**Model Implementation**

Let's start by implementing this problem without a specific example. You'll find its implementation very similar to the original production problem. The first step is to "read" all available data for future use. For this reason, the model includes three sets: raw materials, products, and recipes.

```
set Raws;
set Products;
set Recipes;
```

Note that the problem definition doesn't exclude the possibility that the **same material acts as both a raw material and a product** in different recipes. This is natural in real-world scenarios: a material produced by one recipe might be consumed by another. However, considering this would raise questions regarding **timing**. For instance, if a material is consumed as a raw material in a second recipe, it must first be produced by the first recipe. This implies a sequence where the first recipe executes before the second. Alternatively, the production could describe an equilibrium where amounts must be maintained, making timing irrelevant. Given the complexity of these possibilities, we won't go into details here. For simplicity, we assume that **raw materials and products are distinct**.

To ensure that raw materials are indeed distinct from products, we introduce a `check` statement. We explicitly state that the **intersection** of the set of raw materials and the set of products must contain exactly zero elements. If this condition isn't met, model construction fails immediately, as it should.

```
check card(Raws inter Products) == 0;
```

For each recipe, there are ratios for both raw materials and products. Since these are two different sets, defining them would typically require two different parameters: one for raw material ratios and one for product ratios. This would apply to other parameters as well.

Instead, we introduce the concept of **materials** in our model. We simply group raw materials and products together as "materials." In GNU MathProg, it is legal to introduce a set that is calculated on the spot based on other sets.

```
set Materials := Products union Raws;
```

Since we assumed no material is both a product and a raw material, we can assume each raw material and product is represented exactly once in the union, and they are all distinct. Now, with this new set, we can define the necessary parameters compactly.

```
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
```

The parameters **`Min_Usage`** and **`Max_Usage`** denote the lower and upper bounds for each material in the model. These parameters are indexed over the `Materials` set. For raw materials, `Min_Usage` and `Max_Usage` represent limits for **total consumption**. For products, they represent limits for **total production**. Because each raw material and product appears exactly once in the `Materials` set, this definition unambiguously describes all limits for both. Note that the default limits are **0** for the lower bound and a very large number, **$10^{100}$**, for the upper limit. Technically, this means there is no limit by default.

The **`Value`** parameter works similarly; it represents **raw material costs** for raw materials and **revenues** for products. Both are nonnegative and default to zero.

The **`Recipe_Ratio`** parameter describes the recipes. The only data needed are the exact amounts of inputs consumed and outputs produced. With the common `Materials` set, we can do this with a single parameter. `Recipe_Ratio` is defined for all recipes and all materials. If the material is raw, it describes the **consumption amount**; if it is a product, it describes the **production amount**. We call this parameter "ratio" because it corresponds to the amounts consumed and produced when utilizing the recipe with a **volume of 1**. Generally, since inputs and outputs are proportional, the ratio must be multiplied by the volume to get the actual amounts consumed or produced.

Finally, there is a single numeric parameter, **`Initial_Funds`**. This serves as an **upper limit for raw material costs**. In practice, you generally cannot invest unlimited amounts into raw materials; there is usually a cap. Without such a restriction (and without upper limits for consumption or production), it might be possible to gain unlimited profit by consuming unlimited raw materials to produce at least one product in unlimited amounts. By default, `Initial_Funds` is set to the extreme value of **$10^{100}$** so that it does not restrict the model unless specified.

Now that all parameters and sets are defined, let's look at the freedom in our model. We have to decide the **volume for each recipe utilized**. This is slightly different than before because decisions correspond to a given recipe rather than a particular product or raw material. If recipe volumes are defined, the solution is fully determined, and all other information—including raw material usage, production amounts, costs, revenues, profit, and limitations—can be calculated.

```
var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
```

In our implementation, **`volume`** is the variable denoting the volume at which each recipe is utilized. This is a nonnegative value but can be zero or even fractional, as usual. While this single variable would be sufficient for formulation, we introduce a few **auxiliary variables** to write a compact and readable model.

The variable **`usage`** represents the total "usage" of each material. It is indexed over the `Materials` set and works similarly to the parameters: it has a slightly different meaning for raw materials and products, but for simplicity, a single variable handles both. For raw materials $r$, `usage[r]` is the **total consumption**, while for products $p$, `usage[p]` is the **total production** amount. We can use `Min_Usage[m]` and `Max_Usage[m]` as bounds for this variable, implementing the limitations in our problem.

There is also a variable named **`total_costs`** denoting total costs of consumed raw materials, a variable **`total_revenue`** for total revenue from products, and finally, a variable **`profit`** for the difference (our objective function). We set `Initial_Funds` as an upper bound for `total_costs`, implementing the maximum usage limitation.

Constraints are implemented next.

```
s.t. Material_Balance {m in Materials}: usage[m] =
    sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];

s.t. Total_Costs_Calc: total_costs = 
    sum {r in Raws} Value[r] * usage[r];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Value[p] * usage[p];

s.t. Profit_Calc: profit = 
    total_revenue - total_costs;
```

Although this model is intended to generalize both the production problem and the diet problem, supporting most features mentioned so far, there is only one key constraint: the **material balance** established by recipe utilization. This constraint states that the usage of each material—whether raw material or product—is calculated by summing the volume of each recipe multiplied by the ratio of that material in the recipe. This is exactly the same logic used in both the original production problem and the diet problem.

We also define three additional constraints to calculate the values of the auxiliary variables `total_costs`, `total_revenue`, and `profit`. Note that even though parameters and variables (here `Value` and `usage`) are indexed over the `Materials` set, it is valid in GNU MathProg to index those parameters and variables over a **smaller set**. Using the original `Raws` and `Products` sets, we can sum up only for raw materials or only for products. Be careful: you can only index over the original domain or its subset; otherwise, you will get an out-of-domain error (and the model is guaranteed to be logically wrong).

The objective is straightforward: the profit itself.

```
maximize Profit: profit;
```

After solving the problem, we can print out the auxiliary variables, the utilization volumes for each recipe, and the total consumption and production amounts for each material. The full model section is ready as follows.

```
set Raws;
set Products;
set Recipes;

check card(Raws inter Products) == 0;

set Materials := Products union Raws;

param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;

var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;

s.t. Material_Balance {m in Materials}: usage[m] =
    sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];

s.t. Total_Costs_Calc: total_costs = 
    sum {r in Raws} Value[r] * usage[r];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Value[p] * usage[p];

s.t. Profit_Calc: profit = 
    total_revenue - total_costs;

maximize Profit: profit;

solve;

printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;

for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}

for {r in Raws}
{
printf "Consumption of raw %s: %g\n", r, usage[r];
}

for {p in Products}
{
printf "Production of product %s: %g\n", p, usage[p];
}

end;
```

Although the model for arbitrary recipes is similar in nature to previous models, we implemented it all at once. The question arises: how can you implement a large, complex model in GNU MathProg from scratch? Or, generally, in any mathematical programming language?

**Guide to Complex Model Implementation**

There is no universal guide for modeling, but there are good **rules of thumb** to follow. Here is a recommendation, specifically for GNU MathProg:

1.  **Feasibility Assessment:** First, decide whether the problem can be effectively solved by **LP (or MILP)** models. Many problems simply cannot be solved this way (or only with complicated workarounds), or there might be a much more suitable algorithm. This is the hardest part: you essentially have to determine the **decision variables** and how to define the appropriate **search space** by adding constraints and other variables. If you are sure you can implement an LP (or MILP) model, proceed to implementing the model file.
2.  **Data Collection and Parameter Definition:** Collect all available and necessary data. Define **sets and parameters** that will be provided by the data sections. You can implement data files at this point if example problem instances are available. If data is missing or must be calculated afterward, you can always introduce other sets and parameters and calculate data within the model file.
3.  **Define Decision Variables:** Define the decision variables. Keep in mind that the values of all variables should **exactly determine** the real-world outcome. Specifically, you must be able to calculate the objective and decide whether each restriction is violated based on these variables.
4.  **Implement Constraints and Bounds:** Implement all possible rules as **constraints or bounds**. Be aware of two potential mistakes: a problem may be **under-constrained** or **over-constrained** (or both).
      * In **under-constrained** problems, solutions remain in the search space that are infeasible in reality but feasible in the model. These may be found by the solver and reported as fake optimal solutions. You must define additional constraints to exclude these or make existing constraints more restrictive.
      * In **over-constrained** problems, valid, interesting solutions are excluded from the search space and won't be found by the solver. This means some constraints or bounds are too restrictive; you must reformulate or remove them. Remember, you can always introduce new auxiliary variables in the model.
5.  **Define the Objective:** Define the objective function.
6.  **Reporting:** After the `solve` statement, report the relevant details of the found solution in the desired format.

Complex models may have several dozen constraints, so how can you be sure you haven't forgotten any rules? One idea is to focus on **parameters or variables**. Often, parameters are used only once in the model. Even if not, you can list all the roles the parameter or variable must play in the model (as a bound, constraint, objective term, etc.). This makes it easier to spot anything you've missed.

***Applications of the Arbitrary Recipe Model***

Now that our model for arbitrary recipes is ready, we will demonstrate how it works for all the problems mentioned so far in this chapter (except for the maximum-of-minimum production amounts case).

***1. Production Problem with Costs (Problem 14)***

First, we solve **Problem 14**, which introduced raw material costs. Since this is a pure production problem in the original sense, we introduce a recipe to produce each product. All limits are implemented by the `Min_Usage` parameter, while raw material costs and product revenues are implemented by the `Value` parameter. Here is the data section:

```
data;

set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;

param Min_Usage :=
  B 21000
  D 200
  P2 100
  ;

param Max_Usage :=
  A 23000
  B 31000
  C 450000
  D 200
  P3 10
  ;

param Value :=
  A 1
  B 0.07
  C 0.013
  D 8
  P1 252
  P2 89
  P3 139
  ;

param Recipe_Ratio:
         A   B    C  D P1 P2 P3 := 
MakeP1 200  25 3200  1  1  0  0
MakeP2  50 180 1000  1  0  1  0
MakeP3   0  75 4500  1  0  0  1
;

end;
```

Solving this yields exactly the same result as the original model with raw costs. The optimal profit is **$1,577.45**, with production of 25.48 units of P1, 164.52 units of P2, and 10 units of P3. The output follows:

```
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Consumption of raw A: 13322.6
Consumption of raw B: 31000
Consumption of raw C: 291065
Consumption of raw D: 200
Production of product P1: 25.4839
Production of product P2: 164.516
Production of product P3: 10
```

**2. Diet Problem (Problem 16)**

The second application is the **diet problem**. We solve the exact same problem instance as in **Problem 16**. Here, food types are the **raw materials**, and nutrients are the **products** we want to obtain. Unlike the original production problem (several inputs, one output per recipe), here we have one input (a food type) per recipe producing several nutrients with given ratios.

```
data;
set Raws := F1 F2 F3 F4 F5;
set Products := N1 N2 N3 N4;
set Recipes := EatF1 EatF2 EatF3 EatF4 EatF5;
param Min_Usage :=
N1 2000
N2 180
N3 30
N4 0.04
;
param Value :=
  F1 450
  F2 220
  F3 675
  F4 120
  F5 500
  ;

param Recipe_Ratio:
      F1 F2 F3 F4 F5  N1  N2   N3      N4 :=
EatF1  1  0  0  0  0  30 5.2  0.2  0.0001
EatF2  0  1  0  0  0  20   .  0.7  0.0001
EatF3  0  0  1  0  0  25   2  0.1  0.0001
EatF4  0  0  0  1  0  13 3.6    .  0.0002
EatF5  0  0  0  0  1  19 0.1    .  0.0009
;


end;
```

The solution matches the original diet problem exactly: an optimal cost of 29,707.2, with food consumption amounts of 42.86 for F2, 49.20 for F4, and 28.75 for F5. Note that the objective reported by the solver is -29,707.2 because the profit is determined solely by food costs (revenue is zero, so profit = $0 - \text{Total Costs}$).

```
Total Costs: 29707.2
Total Revenue: 0
Profit: -29707.2
Volume of recipe EatF1: 0
Volume of recipe EatF2: 42.8571
Volume of recipe EatF3: 0
Volume of recipe EatF4: 49.2014
Volume of recipe EatF5: 28.7489
Consumption of raw F1: 0
Consumption of raw F2: 42.8571
Consumption of raw F3: 0
Consumption of raw F4: 49.2014
Consumption of raw F5: 28.7489
Production of product N1: 2042.99
Production of product N2: 180
Production of product N3: 30
Production of product N4: 0.04
```

Recall that we mentioned two ways to represent a diet problem as a production problem. We just implemented the second way (food types as raw materials, nutrients as products). But how could we implement the first case (food types as products, nutrients as raw materials)?

Surprisingly, this **arbitrary recipe model** can handle that as well, simply by **exchanging the roles of products and raw materials**. This highlights the high degree of **symmetry** in the production problem with arbitrary recipes. There are minimum and maximum usages for both raw materials and products. The cost of a raw material is the counterpart to the revenue of a product. Looking at the recipes, there is no fixed "source-target" relationship between raw materials and products; the roles are **interchangeable**. The only slight difference breaking perfect symmetry is the **`Initial_Funds`** feature (an upper limit for total raw material costs). Symmetry would be perfect if `Initial_Funds` were infinite or if we introduced a counterpart feature like maximal revenue.

Finally, let's look at a new example problem to further demonstrate the capabilities of the arbitrary recipe model. We will start with **Problem 14** (production with raw material costs) but add a few modifications.

**Problem 18.**

Solve **Problem 14**, the original production problem, using the exact same data, but with two additional production options.

  * **P1** and **P2** can be produced jointly with slightly different consumption amounts than when produced separately. Producing one unit of both products requires **240 units** of raw material $\text{A}$ (vs. 250 separately), **200 units** of raw material $\text{B}$ (vs. 205 separately), **4,400 units** of raw material $\text{C}$ (slightly more than 4,200 separately), and **2 units** of raw material $\text{D}$ (same as separately).

  * Similarly, **P2** and **P3** can be produced jointly. The costs are **51 units** of raw material $\text{A}$ (slightly more than 50 separately), **250 units** of raw material $\text{B}$ (vs. 255 separately), **5,400 units** of raw material $\text{C}$ (vs. 5,500 separately), and **2 units** of raw material $\text{D}$ (same as separately).

We can solve this by manipulating the data section of the original problem. We add two extra *recipes* to the **Recipes** set, then two rows to the **Recipe\_Ratios** parameter to describe these new recipes. The data section and results are as follows:

```
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;

param Min_Usage :=
  B 21000
  D 200
  P2 100
  ;

param Max_Usage :=
  A 23000
  B 31000
  C 450000
  D 200
  P3 10
  ;

param Value :=
  A 1
  B 0.07
  C 0.013
  D 8
  P1 252
  P2 89
  P3 139
  ;

param Recipe_Ratio:
             A      B       C   D    P1  P2  P3 :=
    MakeP1 200     25    3200   1    1   0   0
    MakeP2  50    180    1000   1    0   1   0
    MakeP3   0     75    4500   1    0   0   1
    Comp1  240    200    4400   2    1   1   0
    Comp2   51    250    5400   2    0   1   1
    ;

end;
```

-----

```
Total Costs: 30495
Total Revenue: 32460.6
Profit: 1965.62
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 6.25
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 86.875
Volume of recipe Comp2: 10
Consumption of raw A: 21672.5
Consumption of raw B: 21000
Consumption of raw C: 442500
Consumption of raw D: 200
Production of product P1: 86.875
Production of product P2: 103.125
Production of product P3: 10
```

-----

The optimal solution is **$1,965.62$**, which is slightly better than the original **$1,577.45$**. This makes sense because adding new production opportunities widened the search space. We can see that **Comp1** and **Comp2**, the recipes for joint production, are used instead of the original options. However, a small amount (6.25 units) of **P2** is still produced alone. The total production mix has also shifted slightly, with **86.88 units** of $\text{P1}$, **103.13 units** of $\text{P2}$, and **10 units** of $\text{P3}$.

-----

## 5.7 Order Fulfillment

We now have a complete model for the production problem with arbitrary recipes, allowing us to easily implement and solve a wide range of problems, including the diet problem. We will further extend this model with a new, practical feature: **orders**. Orders allow materials to be bought and sold in bulk. This can be more lucrative but requires an "all-or-nothing" decision—orders must be accepted entirely or ignored completely.

Until now, the production problems involved only **real-valued variables**, making them **Linear Programming (LP)** models. Now, we introduce **integer variables**, turning the model into a **Mixed Integer Linear Programming (MILP)** model. While MILP models are easy to implement, solving them can take an unacceptably long time if there are too many **binary variables**. The limit on what constitutes "too many" varies by problem: sometimes dozens are too many, while other times hundreds or thousands work fine. Regardless, this limit is definitely lower than for ordinary real-valued variables in LP models. Unfortunately, **integer programming** is an **NP-Complete problem**, so limitations can often only be slightly improved by better hardware, solvers, or modeling techniques. Nevertheless, integer variables are powerful tools that significantly expand the range of problems solvable by MILP compared to LP.

We will demonstrate how to extend a **GNU MathProg** model with new features while maintaining compatibility with old data files. We will also show how to use a filter within an indexing expression in **GNU MathProg**.

An **order** is a fixed amount of several raw materials (purchased) and/or products (sold when ready). An order can cost money or generate income, and payment may happen before or after production. The same order may be fulfilled multiple times.

Here is the general problem definition for arbitrary recipes with order fulfillment.

**Problem 19.**

Solve **Problem 17**, the production problem with arbitrary recipes, where production proceeds as usual but now includes **orders**. Orders are **optional** but must be acquired (and fulfilled) **completely**, not partially. Each order has the following characteristics:

  * **Fixed Material and Product Amounts:** If a raw material is included, acquiring the order means we **obtain** that material *before* production. If a product is included, acquiring the order means we must **deliver** that product *after* it is produced.
  * **Order Price (Cash Flow):** This can be a cash **gain (revenue)** or a **payment (cost)**. Payment occurs either **before** or **after** production.
  * **Maximum Count:** An order can be acquired and fulfilled multiple times, up to a specified limit.

Raw materials must be purchased from the market (as usual) or obtained via orders. Any **leftover** raw materials after production are **lost** without compensation.

Products must be sold on the market or delivered via an order. Products can only be obtained by producing them. Fulfilling acquired orders is **mandatory**.

Minimum and maximum usage limitations apply as before, corresponding to the **total amounts** of materials/products in possession at one time.

**Total Costs** include expenses/incomes from orders where payment is due *before* production, plus the cost of raw materials purchased from the market. Total Costs are limited by a fixed amount of **initial funds**.

**Total Revenue** includes expenses/incomes from orders where payment is due *after* production, plus revenue from selling products on the market.

The objective is to optimize **Profit**, the difference between Total Revenue and Total Costs.

-----

**Model Analysis and Compatibility**

First, observe that if we assume there are **no orders**, we revert exactly to the production problem with arbitrary recipes.

Without orders, raw materials come solely from market purchases, and revenue comes solely from market sales. We would purchase exactly the raw materials needed and sell all products produced, with no potential loss of materials or alternatives.

Therefore, the new model is designed to work with data files from the "old" arbitrary recipes model, ensuring **backward compatibility**.

-----

**Data Implementation for Orders**

Let's see how to implement the extra data for orders using sets and parameters:

```
set Orders, default {};

param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;
```

  * The additional set **Orders** uses a default value of `{}` (an empty one-dimensional set in GNU MathProg). This ensures original data files (which don't mention `Orders`) still work.
  * **`Order_Material_Flow`**: Similar to `Recipe_Ratio`. If material $m$ is a **raw material**, the order denotes a **purchase** (input). If $m$ is a **product**, it denotes a **delivery** (output). Default is zero.
  * **`Order_Cash_Flow`**: Denotes the cash flow for the order. This is the **only parameter that can be negative**.
      * **Positive value:** A **cost** (payment) for acquiring the order.
      * **Negative value:** A **revenue** (cash gain) from the order.
      * Zero is relevant (e.g., an exchange of materials/products without immediate cash impact).
      * *Note*: A zero material flow with non-zero cash flow represents an investment, though the current model only implements cash flow once (before or after production).
  * **`Order_Count`**: Maximum number of times an order can be acquired. Since orders multiply flows and prices, this must be a non-negative **integer** ($\ge 0$, `integer` keyword). Default is **1** (acquire once or not at all).
  * **`Order_Pay_Before`**: A **binary** parameter (0 or 1) specifying payment timing.
      * **1 (True)**: Payment is due **before** production (contributes to Total Costs).
      * **0 (False)**: Payment occurs **after** production (contributes to Total Revenue).
      * Default is **1**.
  * *Note*: The `binary` and `integer` keywords restrict values for parameters and variables similarly.

-----

**Decision Variables**

We define the following variables, including a new one for order acquisition:

```
var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
```

  * The main recipe variable (`volume`) and auxiliary variables (`total_costs`, `total_revenue`, `profit`) remain unchanged.
  * **`ordcnt`**: A new variable denoting how many times an order is acquired. Constrained by `Order_Count`, it must be an **integer** (`integer` keyword). This is the **only variable** changing the model from LP to **MILP**. Since orders cannot be partially fulfilled, `ordcnt` must take whole number values (0, 1, 2, ...).

-----

**Material Usage Variables**

Material flow is now more complicated as materials come from/go to different sources. We introduce several usage variables:

  * **Raw Materials** come from market/orders, are used in production, or become leftover (wasted).
  * **Products** come from production and go to market/orders. Leftovers aren't modeled for products (no incentive to keep them vs. selling).
  * Usage refers to the **total amount** in possession at one time.

<!-- end list -->

```
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
```

All variables are set as $\ge 0$ to ensure quantities are non-negative.

-----

**Material Balance Constraints**

Constraints define relationships between the new usage variables.

**1. Production and Order Calculations**

These calculate amounts flowing through production and orders based on decision variables (`volume` and `ordcnt`).

```
s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
    sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];

s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
    sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
```

**2. Total Usage and Balance for Raw Materials**

For raw materials, total amount obtained must equal total amount consumed (production + leftover).

```
s.t. Material_Balance_Total_Raws_1 {r in Raws}:
    usage_total[r] = usage_orders[r] + usage_market[r]; 
    // Total amount obtained = (From Orders) + (From Market)

s.t. Material_Balance_Total_Raws_2 {r in Raws}:
    usage_total[r] = usage_production[r] + usage_leftover[r];
    // Total amount used = (Consumed by Production) + (Leftover)
```

  * `usage_market` and `usage_leftover` are "free" variables the model selects to satisfy balance equations, given the calculated `usage_orders` and `usage_production`.

**3. Total Usage and Balance for Products**

For products, total amount obtained must equal total amount sold/delivered.

```
s.t. Material_Balance_Total_Products_1 {p in Products}:
    usage_total[p] = usage_production[p];
    // Total available amount = (Amount Produced)

s.t. Material_Balance_Total_Products_2 {p in Products}:
    usage_total[p] = usage_orders[p] + usage_market[p];
    // Total disposed = (Delivered to Orders) + (Sold on Market)
```

  * The first constraint sets auxiliary variable `usage_total[p]` equal to `usage_production[p]`. The second ensures this total is covered by deliveries to orders and market sales (`usage_market[p]` is the "free" variable).

-----

**Cost, Revenue, and Profit Calculation**

These constraints calculate financial variables, incorporating order cash flow timing.

```
s.t. Total_Costs_Calc: total_costs =
    sum {r in Raws} Value[r] * usage_market[r] +
    sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];

s.t. Total_Revenue_Calc: total_revenue =
    sum {p in Products} Value[p] * usage_market[p] -
    sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];

s.t. Profit_Calc: profit = 
    total_revenue - total_costs;
```

**Order Cash Flow Logic:**

The sign of `Order_Cash_Flow` represents cost (positive) or revenue (negative).

1.  **Payment due BEFORE production (`Order_Pay_Before[o]` is 1):** Cash flow adds to `total_costs`.

      * **Expense** ($\text{Order\_Cash\_Flow} > 0$): $\text{Cost}$ increases.
      * **Income** ($\text{Order\_Cash\_Flow} < 0$): $\text{Cost}$ decreases (increasing available funds).
      * Term: `sum \text{Order\_Cash\_Flow}[o] \times \text{ordcnt}[o]`.

2.  **Payment due AFTER production (`!Order\_Pay\_Before[o]` is 1):** Cash flow subtracts from `total_revenue`.

      * **Income** (`Order_Cash_Flow} < 0`): Subtracting a negative increases `Revenue`.
      * **Expense** (`Order_Cash_Flow > 0`): `Revenue` decreases (treated as negative revenue).
      * Term: `-\sum \text{Order\_Cash\_Flow}[o] \times \text{ordcnt}[o]`.

**Filtering in GNU MathProg**

We use a **filter** in the summation's indexing expression for selective addition:

  * $\text{sum \{o in Orders: Order\_Pay\_Before[o]\} ...}$ iterates only over orders $o$ where `Order_Pay_Before[o]` is true (1).
  * $\text{!Order\_Pay\_Before}[o]$ iterates over orders where the parameter is false (0).
  * GNU MathProg allows filtering on all indexing expressions (e.g., `param`, `set`, `var`, `s.t.`, `for`). Summing over an empty set evaluates to zero.

-----

**Complete Model Section and Output**

The final model maximizes profit:

```
set Raws;
set Products;
set Recipes;
set Orders, default {};

check card(Raws inter Products) == 0;
set Materials := Products union Raws;

param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;

var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];

s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
s.t. Material_Balance_Total_Raws_1 {r in Raws}:
usage_total[r] = usage_orders[r] + usage_market[r];
s.t. Material_Balance_Total_Raws_2 {r in Raws}:
usage_total[r] = usage_production[r] + usage_leftover[r];
s.t. Material_Balance_Total_Products_1 {p in Products}:
usage_total[p] = usage_production[p];
s.t. Material_Balance_Total_Products_2 {p in Products}:
usage_total[p] = usage_orders[p] + usage_market[p];
s.t. Total_Costs_Calc: total_costs =
sum {r in Raws} Value[r] * usage_market[r] +
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage_market[p] -
sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Profit_Calc: profit = total_revenue - total_costs;

maximize Profit: profit;

solve;

printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
for {o in Orders}
{
printf "Acquiring order %s: %dx\n", o, ordcnt[o];
}
for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}
printf "Raw materials (orders + market -> production + leftover):\n";
for {r in Raws}
{
printf "Consumption of raw %s: %g + %g -> %g + %g (total: %g)\n",
r, usage_orders[r], usage_market[r], usage_production[r],
usage_leftover[r], usage_total[r];
}
printf "Products (production -> orders + market):\n";
for {p in Products}
{
printf "Production of product %s: %g -> %g + %g (total: %g)\n",
p, usage_production[p], usage_orders[p],
usage_market[p], usage_total[p];
}
end;
```

The order of variable and constraint declarations doesn't affect the solution, but a logical flow aids understanding:

1.  **Decision on Orders:** Set `ordcnt`.
2.  **Calculate Order Flows:** Determine `usage_orders`.
3.  **Decision on Production:** Set `volume`.
4.  **Calculate Production Flows:** Determine `usage_production`.
5.  **Adjust Market/Total Flows:** Set `usage_market` and calculate `usage_total` to satisfy material balance.
6.  **Calculate Leftovers:** Determine `usage_leftover`.
7.  **Calculate Financials:** Determine `total_costs`, `total_revenue`, and `profit`.

-----

**Example 1: Problem 14 Data (No Orders)**

The first example uses data from **Problem 14** (arbitrary recipes with costs) but doesn't define the `Orders` set.

```
data;

set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;

param Min_Usage :=
  B 21000
  D 200
  P2 100
  ;

param Max_Usage :=
  A 23000
  B 31000
  C 450000
  D 200
  P3 10
  ;

param Value :=
  A 1
  B 0.07
  C 0.013
  D 8
  P1 252
  P2 89
  P3 139
  ;

param Recipe_Ratio:
             A      B      C      D    P1  P2  P3 :=
    MakeP1 200     25   3200      1    1   0   0
    MakeP2  50    180   1000      1    0   1   0
    MakeP3   0     75   4500      1    0   0   1
    ;

end;
```

**Results:** The optimal solution matches the original: **$1,577.45$** profit, production of 25.48 P1, 164.52 P2, and 10 P3.

```
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 13322.6 -> 13322.6 + 0 (total: 13322.6)
Consumption of raw B: 0 + 31000 -> 31000 + 0 (total: 31000)
Consumption of raw C: 0 + 291065 -> 291065 + 0 (total: 291065)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 25.4839 -> 0 + 25.4839 (total: 25.4839)
Production of product P2: 164.516 -> 0 + 164.516 (total: 164.516)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

*The model works even without orders defined, demonstrating compatibility.*

-----

**Example 2: Problem 18 Data (No Orders, Explicit Empty Sets)**

The second example uses data from **Problem 18** (arbitrary recipes with joint production), but explicitly defines order-related parameters and sets as empty.

```
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;

param Min_Usage :=
  B 21000
  D 200
  P2 100
  ;

param Max_Usage :=
  A 23000
  B 31000
  C 450000
  D 200
  P3 10
  ;

param Value :=
  A 1
  B 0.07
  C 0.013
  D 8
  P1 252
  P2 89
  P3 139
  ;

param Recipe_Ratio:
         A      B      C      D    P1  P2  P3 :=
  MakeP1 200    25     3200   1    1   0   0
  MakeP2 50     180    1000   1    0   1   0
  MakeP3 0      75     4500   1    0   0   1
  Comp1  240    200    4400   2    1   1   0
  Comp2  51     250    5400   2    0   1   1
  ;

param Initial_Funds :=;

set Orders :=;
param Order_Material_Flow :=;
param Order_Cash_Flow :=;
param Order_Count :=;
param Order_Pay_Before :=;


end;
```

**Results:** The optimal solution is again the same: **$1,965.63$** profit, utilizing joint production options `Comp1` and `Comp2`.

```
Total Costs: 30495
Total Revenue: 32460.6
Profit: 1965.63
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 6.25
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 86.875
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 21672.5 -> 21672.5 + 0 (total: 21672.5)
Consumption of raw B: 0 + 21000 -> 21000 + 0 (total: 21000)
Consumption of raw C: 0 + 442500 -> 442500 + 0 (total: 442500)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 86.875 -> 0 + 86.875 (total: 86.875)
Production of product P2: 103.125 -> 0 + 103.125 (total: 103.125)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

*The model successfully handles the empty order definition.*

-----

**Problem 20.**

Solve **Problem 18** (production with arbitrary recipes) with these modifications:

  * **Raw Material Limits:** Reset to **50,000 A**, **120,000 B**, **1,000,000 C**, and **1,500 D**.
  * **Initial Funds:** Capped at **35,000**.
  * **Available Orders:** Three orders are available with the following properties:

| | **Ord1** | **Ord2** | **Ord3** |
|:---|:---:|:---:|:---:|
| **Payment Before** | no | no | yes |
| **Expense** | 10,000 | 10,000 | — |
| **Income** | — | — | 500 |
| **Maximum Count** | 10 | 10 | 30 |
| **Obtain A** | 20,000 | 15,000 | 190 |
| **Obtain B** | 10,000 | 10,000 | 20 |
| **Obtain C** | 300,000 | 400,000 | 3,000 |
| **Obtain D** | 500 | 500 | — |
| **Deliver P1** | 40 | 45 | 1 |
| **Deliver P2** | 80 | 70 | — |
| **Deliver P3** | — | 6 | — |

The data section implementation and the solution output are as follows:

```glp
data;

set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;

param Min_Usage :=
    B 21000
    D 200
    P2 100
    ;

param Max_Usage :=
    A 50000
    B 120000
    C 1000000
    D 1500
    P3 10
    ;

param Value :=
    A 1
    B 0.07
    C 0.013
    D 8
    P1 252
    P2 89
    P3 139
    ;

param Recipe_Ratio:
              A   B    C  D  P1 P2 P3 :=
      MakeP1 200  25 3200  1  1  0  0
      MakeP2  50 180 1000  1  0  1  0
      MakeP3   0  75 4500  1  0  0  1
      Comp1  240 200 4400  2  1  1  0
      Comp2   51 250 5400  2  0  1  1
      ;

param Initial_Funds := 35000;

set Orders := Ord1 Ord2 Ord3;

param Order_Material_Flow:
            A     B      C   D  P1  P2  P3 :=
    Ord1 20000 10000 300000 500  40  80  0 
    Ord2 15000 10000 400000 500  45  70  6
    Ord3   190    20   3000   0   1   0  0
    ;

param Order_Cash_Flow := # negative means income
    Ord1 10000
    Ord2 10000
    Ord3 -500
    ;

param Order_Count :=
    Ord1 10
    Ord2 10
    Ord3 30
    ;

param Order_Pay_Before :=
    Ord1 0
    Ord2 0
    Ord3 1
    ;

end;
```

```
Total Costs: 26497.3
Total Revenue: 47202.7
Profit: 20705.4
Acquiring order Ord1: 1x
Acquiring order Ord2: 0x
Acquiring order Ord3: 30x
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 553.716
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 89.1554
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 25700 + 23893.1 -> 49593.1 + 0 (total: 49593.1)
Consumption of raw B: 10600 + 109400 -> 120000 + 0 (total: 120000)
Consumption of raw C: 390000 + 610000 -> 1e+06 + 0 (total: 1e+06)
Consumption of raw D: 500 + 252.027 -> 752.027 + 0 (total: 752.027)
Products (production -> orders + market):
Production of product P1: 89.1554 -> 70 + 19.1554 (total: 89.1554)
Production of product P2: 652.872 -> 80 + 572.872 (total: 652.872)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

The larger raw material limits and generally profitable production lead to a significant objective increase. Orders are also being utilized.

The **optimal profit is 20,705.4**. Total production is **89.16 P1**, **553.72 P2**, and **10 P3**. We acquire **Ord1 once** and **Ord3 30 times** (maximum). Ord3 is a lucrative way to produce and deliver P1. Significant raw materials come from orders, with the rest purchased from the market, resulting in **no leftovers**. Some products are delivered via orders, but amounts are sold on the market in all three cases.

Let's run an experiment to check the integer nature of this model. Since order decisions require integer variables, this is an **MILP** model. However, `glpsol` has a `--nomip` option to relax all integer variables.

**Relaxing** means variables aren't forced to be integers, only constrained by their lower/upper bounds. Relaxing all integer variables converts an MILP into its **LP (Linear Programming) relaxation**.

```bash
glpsol -m model.mod -d data.dat --nomip
```

The model is treated as an LP, which solves much faster, but integer variables can take fractional values (making the solution **infeasible in reality**). Using this option yields:

```
Total Costs: 12163
Total Revenue: 33560
Profit: 21397
Acquiring order Ord1: 1x
Acquiring order Ord2: 0x
Acquiring order Ord3: 30x
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 550
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 90
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 35700 + 13910 -> 49610 + 0 (total: 49610)
Consumption of raw B: 15600 + 103900 -> 119500 + 0 (total: 119500)
Consumption of raw C: 540000 + 460000 -> 1e+06 + 0 (total: 1e+06)
Consumption of raw D: 750 + 0 -> 750 + 0 (total: 750)
Products (production -> orders + market):
Production of product P1: 90 -> 90 + 0 (total: 90)
Production of product P2: 650 -> 120 + 530 (total: 650)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

The LP relaxation optimal profit is **21,397**, which is **better** than the MILP's 20,705.4. This is natural because the LP relaxation has a wider search space. The LP relaxation is important for the solution process: it solves fast and guarantees an **upper bound** for the MILP optimal solution.

Though the LP relaxation solution looks oddly "integer," the different objective value confirms at least one integer variable is fractional. In fact, **Ord1 is acquired 1.5 times**. This wasn't reported because the order count was printed with `%d`, rounding the value. Using `%f` or `%g` would have revealed the fraction.

-----

## 5.8 Production Problem – Summary

We started with the simplest production problem: deciding the production mix to maximize revenue given limited raw materials. We showed how to add production/consumption limits, optimize different objectives, and factor in raw material costs.

The **diet problem**—satisfying nutritional needs with specific foods—resulted in a very similar implementation. Both can be seen as special cases of a general production problem where recipes involve multiple inputs and outputs.

Finally, we introduced **orders** in the chapter's ultimate model, giving the problem an **integer nature** (orders must be fulfilled completely). This extension adds new supply/demand possibilities while keeping the problem linear. Additional data files, from basic to complex, can be easily implemented and solved with the same single model file.