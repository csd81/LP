----------------------
Chapter 4

Equation systems
In this chapter, basic capabilities of the GNU MathProg language are presented on an example
modeling problem, which is the general solution of linear equation systems. The aim is to navigate
from the initial point of a straightforward implementation to the usage of indexing and separated
model and data sections.
With this knowledge, maintenance of code, and solution of the model with different instances
(different data) become very easy, provided that first the model is correctly implemented. This is
the standard way we intend to implement models in the future.
Note that solving linear systems of equations is considered a routine task. There are plenty
of capable software tools, either standalone or embedded. A well-known algorithm is the Gaussian elimination [10]. But we are now interested in not the solution algorithms, but modeling.
Particularly, GNU MathProg implementation techniques, in this chapter.

4.1

Example system

Let us start with the solution of a small system of equations, now in GNU MathProg.

Problem 4.
Solve the following system of equations in the real domain.
2 (x − y) = −5
y−z =w−5
1=y+z
x + 2w = 7y − x

(8)

Although it is not explicitly mentioned in the problem description, there are four variables, x,
y, z, w, and the real domain means that all of these can take arbitrary real values, independently.
Our goal is to find values for these four variables so that all four equations are true.
If a complete analysis about the problem was in question, then the problem would be not only
to find a single solution, but to find all of them - and if there are infinitely many solutions, then
characterize this infinite set, moreover, also prove that there are no other solutions. However, for
the sake of simplicity, now we only want to find any single solution to the system of equations and
we do not want to decide whether there is another or not.
This is therefore a feasibility problem, it means that only a single feasible solution is to be
found. There is no need to objective function for which we want to optimize, because there are no
19

4.1. EXAMPLE SYSTEM

EQUATION SYSTEMS

better or worse solutions.
It can be observed that Problem 4 describes a linear system of equations. This is apparent after
we arrange the equations into the following format.
2x

2x

−2y
y
y
−7y

−z
+z

−w
+2w

= −5
= −5
=1
=0

(9)

The point is that this arrangement can be obtained from the original system by simplifying each
equation alone: removing the parentheses, adding and merging terms at both sides. In this way,
the arranged system is equivalent to the original. On the left-hand side (LHS) of the equation,
there is a linear expression of the variables (each multiplied by a constant, then added), and on the
right-hand side (RHS), there is a constant, in each equation. Therefore all equations are linear.
If we further add zero terms and emphasize coefficients at each column of the arranged format, we
get the following, equivalent form of the same system.
(+2) · x
0·x
0·x
(+2) · x

+ (−2) · y
+ (+1) · y
+ (+1) · y
+ (−7) · y

+
+
+
+

0·z
(−1) · z
(+1) · z
0·z

+
+
+
+

0·w
(−1) · w
0·w
(+2) · w

= −5
= −5
=1
=0

(10)

Although this representation is less readable, it represents more generally what a system of
linear equations actually mean. For each equation, there is a constant right-hand side, and a linear
expression at the left-hand side, for which we only want to know the coefficients for each variable.
So this whole problem can be represented in a matrix of coefficients, for which the rows correspond
to solutions, and columns correspond to variables – except the rightmost column, which corresponds
to the right-hand side.
This is very close to what we call the standard form of a Linear Programming problem.
The standard form also includes ≥ 0 bounds for all variables, consists of ≤ inequalities instead
of equations, and of course, has a linear objective function. This matrix-like form is important
because it inspires solution algorithms. However, we are now not going into the details of solution
algorithms, neither in case of system of equations nor in LP problems.
Instead, the representation shown in Equation system 10 will be useful to understand the general
scheme behind systems of linear equations, and to implement a separated GNU MathProg MILP
model, for which a data section describing an arbitrary system of linear equations can be provided
and solved.
Now let us see how the code looks like in GNU MathProg. First, the most straightforward
implementation is shown, without arrangement of the equations.
var x;
var y;
var z;
var w;
s.t. Eq1: 2 * (x - y) = -5;
s.t. Eq2: y - z = w - 5;
s.t. Eq3: 1 = y + z;
s.t. Eq4: x + 2 * w = 7 * y - x;
solve;

20

4.2. MODIFICATIONS IN CODE

EQUATION SYSTEMS

printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
end;
As we can see here, GNU MathProg allows usage of parentheses and basic operations, provided
that the constraints, now named Eq1, Eq2, Eq3 and Eq4, simplify into an equality (or non-strict
inequality) between two linear expressions.
If we solve the above model file, then the solution x = 0.5, y = 3, z = −2 and w = 10 is obtained.
This solution is unique, so all solution methods shall end up with this exact result. We can also
manually check that all four equations are satisfied with the resulting values of the variables. The
code itself helps us by printing the values of the four variables to the solver output.
Now, if the aligned version is to be implemented, we can get the following.
s.t. Eq1: 2 * x + (-2) * y +
0 * z +
0 * w = -5;
s.t. Eq2: 0 * x +
1 * y + (-1) * z + (-1) * w = -5;
s.t. Eq3: 0 * x +
1 * y +
1 * z +
0 * w = 1;
s.t. Eq4: 2 * x + (-7) * y +
0 * z +
2 * w = 0;
As we can see, white space characters can be freely used in GNU MathProg to help with readability. Also, zero coefficient terms can be eliminated from the expressions and padded with whitespace
instead. The rest of the model file can remain unchanged. The result when solving this arranged
model file shall be the same.

4.2

Modifications in code

Now that we have a working model file solving a particular system of linear equations, let us try
to solve another one, which is obtained by slight modifications from the original one. The problem
description is the following.
