
---

# Chapter 1: Introduction

This tutorial provides an **overview** of mathematical programming and Operations Research (OR). We will focus on developing Linear Programming (LP) and Mixed-Integer Linear Programming (MILP) models using the GNU MathProg (GMPL) modeling language.

Optimization is essentially about finding the **best** solution to real-world problems. While you can sometimes rely on common sense or simple logic, many scenarios require advanced approaches. Typically, we create a mathematical model of the problem and design solution methods by leveraging the best available math, computer science, and technology.

The main challenge often lies in the **vast number of potential solutions** to a problem. It is often impossible to evaluate every single one, even with the fastest supercomputers. In many situations, instead of hunting for a perfect solution, we use "rules of thumb," also known as **heuristic methods**. These methods simplify the underlying model or limit the number of solutions we investigate. This approach sacrifices optimality but makes finding a "good enough" solution computationally feasible. Even then, we usually need some form of optimization to pick the best option from the remaining candidates.

When faced with an optimization problem, the "conventional" approach is to design and code a specific algorithm in a programming language like C++, Java, or Python. This involves defining the data structures and the exact sequence of steps (the "How") to achieve the goal (the "What"). For example, you might implement Dijkstra’s algorithm to find the shortest path in a graph, Kruskal’s algorithm for the cheapest spanning tree, or the Ford-Fulkerson algorithm for network flow.

Mathematical programming offers a different path. Instead of coding the steps, you **only formulate a mathematical model** of the real-world problem. This model uses equations, inequalities, and logical expressions to describe the rules governing the problem. You don't write the algorithm to solve it; you just define the system. Specialized **solver software** handles the heavy lifting to find the solution for that class of mathematical model.

This tutorial focuses on a subset of these methods—specifically Linear Programming (LP) and Mixed-Integer Linear Programming (MILP)—using the GNU MathProg (GMPL) language [1]. **Tackling** real-world optimization problems by building a model and running it through a solver is a valuable skill, distinct from standard programming. While a custom algorithm might be faster for specific problems, building a mathematical model is often surprisingly fast and easy. Plus, models are much more flexible if the requirements of the real-world problem change later.

The internal algorithms that solvers use to process our models are an interesting topic, but they aren't our focus here. In short, learning *how to formulate* these models is more important for our purposes than the mechanics of *how the software solves them* to optimality.

We chose the GNU MathProg language and the `glpsol` solver (part of the GNU Linear Programming Kit [2]) because they are open-source and relatively easy to understand. There are many other free and commercial tools available for formulating and solving mathematical programming models, many of which are significantly faster than `glpsol`.

There are several other learning resources available on this subject. The basic GLPK installation includes a number of example models, some of which are quite complex. GLPK also has a detailed Wikibooks project [3]. We also recommend Hegyháti’s Linear Programming tutorial [4], and you can find many useful books and lecture materials on the Hungarian Tankönyvtár homepage [5].

This tutorial covers the basics of the language and presents key problems that are easily solved with mathematical programming. It offers insight into the power of optimization using mathematical models, particularly MILP. We will also touch on some algorithmic solution methods for specific problems.

The remainder of the tutorial is organized as follows:

* **Chapter 2** introduces the main goals, tools, and concepts of optimization.
* **Chapter 3** covers the basic usage of GNU MathProg and the `glpsol` solver, including a minimal "Hello, World!" model.
* **Chapter 4** demonstrates how to solve linear equation systems using GNU MathProg. We will gradually improve the model implementation to show off language features like indexing and separating data from the model.
* **Chapter 5** introduces the production problem. This chapter focuses on incremental development, showing how to handle changes, extensions, and integer variables.
* **Chapter 6** presents the transportation problem. We will introduce modeling techniques for various cost functions found in complex problems.
* **Chapter 7** discusses more challenging problems that require MILP formulations. We will cover advanced modeling and coding techniques, as well as graphical outputs.
* **Chapter 8** provides a brief look "under the hood" at LP/MILP solving algorithms to explain how the software works in the background.

This tutorial includes attachments. You can find all the GNU MathProg codes (models, data files, and outputs) mentioned in the text, grouped by chapter and section. (See the attachment itself for a detailed description.)

For the best learning experience, we recommend manually examining and solving the models with their corresponding data files. Note that most of the code and key output segments are included directly in the text using the following format:

> GNU MathProg code for model files is formatted like this.

> GNU MathProg code of data sections that may go to
> separate data files are formatted like this.

> Output generated by the solver is formatted like this.

> Commands to be run are formatted like this.

If you have questions or spot any errors in this tutorial, please feel free to contact us at eles@dcs.uni-pannon.hu. We hope you find this material useful.

---

