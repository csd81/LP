---------------
Problem 26.
Solve Problem 21, the transportation problem, with one modification: there are two unit costs for
transportation, one below a given threshold amount transported, and a lower unit cost for surplus
amounts above that threshold.

Problem 27.
Solve Problem 22, the original example transportation problem, with one modification: the given
unit costs are only for transportation amounts below 100 units. Above that limit, costs are decreased
by 25% per amount transported.
Note that the only difference between this problems and the previous one is that the unit costs
above the threshold are not higher, but lower. Even the threshold of 100 and the rate of 25%
are the same. Therefore it is tempting to address this problem by only slightly modifying our
code to calculate with decreasing costs instead. The parameter CostIncPercent is renamed to
CostDecPercent, and the CostOverThreshold is calculated accordingly.
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
However, if we solve the model, the results do not reflect reality.
Optimal cost: 2025.
From S1 to D1, transport 10=0+10 amount for 37.5 (unit cost: 5/3.75).
From S1 to D5, transport 90=0+90 amount for 337.5 (unit cost: 5/3.75).
From S2 to D1, transport 110=0+110 amount for 82.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=0+140 amount for 210 (unit cost: 2/1.5).
From S3 to D3, transport 170=0+170 amount for 127.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=0+20 amount for 60 (unit cost: 4/3).
From S4 to D4, transport 90=0+90 amount for 540 (unit cost: 8/6).
From S4 to D6, transport 120=0+120 amount for 630 (unit cost: 7/5.25).
The optimal solution is 2025, way better than the original 2700. There is nothing wrong so far,
because costs decreased. But the details show that there is zero transportation amounts below the
threshold, the total amount is transported for the lower price, for amounts above the threshold.
This is clearly not allowed, as we can only use the lower unit costs if we filled the thresholds first,
after spending the higher unit cost for the amounts below.
The case where the cost above the threshold was higher, the model worked perfectly. Now, when
the cost above the threshold is lower, the model is wrong. What makes this difference?
• If the unit costs increase above the threshold, the amounts above the threshold are filled first,
and then we can optionally transport additional amounts above the threshold. We (and the
model) are allowed to transport above the threshold first, but it does not give any benefit,
therefore these approaches are ruled out by the optimization procedure.
• If the unit costs decrease above the threshold, however, the optimization prefers using the
amounts above the threshold because of the lower cost. However, it does not work like a „free
option”, but a „right” that must be obtained: we can only use the lower unit cost if we filled
the amounts below the threshold first. This is not enforced by the constraints, and therefore
the reported optimal solution is infeasible in reality.

103

6.4. ECONOMY OF SCALE

TRANSPORTATION PROBLEM

To better understand the difference, observe the slightly modified schematic representation of
economy of scale (see Figure 4). One might argue that the only difference is that the curve is going
downward, not upward, but observe the feasible region.

Figure 4: Transportation costs with an increased unit cost above a threshold.
One property of LP problems is that their search space is always convex. This means, if
we have two feasible solutions, and make a convex sum of these, then the result is also a feasible
solution. For example, if x1 = 3, y1 = 1 is one feasible solution, and x2 = 7, y2 = 9 is another,
then let us obtain a convex sum of these with weights 43 and 14 . We get x3 = 43 x1 + 14 x2 = 4,
y3 = 34 y1 + 14 y2 = 4, which is guaranteed to be also feasible. If we investigate what general
constraints are allowed in LP models, the convexity of the feasible region could be verified easily.
However, if we look at the schematic representation in Figure 4, the feasible region is not convex.
Moreover, we cannot make it convex by cutting down parts from it. The reason is that we should
allow feasibility on both of the two red line segments, but their convex sums fall into the infeasible
region that must be prohibited by model constraints. We can see why this was not a problem in case
if increasing unit costs: because the convex sums of the two red line segments fell into the feasible
region – those cases did not make sense in reality though, but the model still included them, and
overall the problem could be perfectly modeled by LP.
But the feasible region is clearly not convex, which suggests that economy of scale cannot
be modeled by LP. However, we can model it by adding integer variables, making the model
an MILP. Our goal is to ensure that the amounts below the threshold, denoted by tranBase are
utilized in full whenever any amounts are transported above the threshold, denoted by tranOver.
For each connection, we introduce a binary variable isOver.
var isOver {(s,d) in Connections}, binary;
The meaning of isOver is that whether we are entitled (= 1) or not (= 0) to transport for the
lower unit cost, for amounts above the threshold. This binary variable introduces a discrete nature
to the problem, and now the search space is not convex, because no fractional values are allowed
for isOver between 0 and 1. Depending on the value isOver takes, there are specific circumstances
required.
104

6.4. ECONOMY OF SCALE

TRANSPORTATION PROBLEM

• If isOver=0, then we cannot use the lower cost, hence the amounts above the threshold must
be zero.
• If isOver=1, then we must get the right to use the lower costs, hence the amounts below the
threshold must be maximal, i.e. equal to the threshold amount.
It is a common problem in mathematical programming that we have an ordinary linear constraint,
like A ≥ B, but we want this constraint to be active if and only if a certain condition is met. The
condition is often represented by the value of a binary variable x. If x = 1, then constraint A ≥ B
must hold. However, if x = 0, there is no restrictions about A or B.
The modeling technique used is called big-M constraint. The first step is to arrange the linear
constraint into the form B − A ≤ 0, then find a positive upper bound for B − A. This upper
bound shall be large enough to include all possible values for all model variables appearing in the
expression B − A. In practice, often a very large number, like M = 1000000 is selected as an upper
bound, which is magnitudes larger than any sensible solution for the problem, is sufficient. This is
the so-called big-M value.
Then, include the following constraint in the model formulation.
B − A ≤ M · (1 − x)

(12)

Now investigate what this constraint does in the model. Because x is an integer variable, there
are two cases. If x = 1, then the constraint reduces to B − A ≤ 0, which is exactly what we wanted
to achieve if x = 1. If x = 0 however, the constraint reduces to B − A ≤ M . Remember that M
is magnitudes larger than any possible, sensible values of B − A. Therefore the constraint becomes
redundant, as it does not impose further restrictions on model variables – again, what we exactly
wanted for x = 0.
If the linear constraint is an equation, like A = B, then we can express it as two inequalities
A ≥ B and A ≤ B and implement a big-M constraint for each.
If the condition is not x = 1 but x = 0 instead, then we can simply replace (1 − x) by x in the
model formulations as the negation of any binary value x is (1 − x).
We can see that this is a very general technique which allows conditional inclusion of linear
constraints in MILP models, provided that their condition can be expressed as a binary variable (or
any other linear expression which results in a value that can only be 0 or 1, but nothing in between).
One might ask: if M is only required to be large enough, what is the most suitable M to be
given? In the solution algorithmic point of view, the best choice is usually the lowest possible M .
Be careful though, if M is too small, the constraint is not redundant when the condition is not met,
and we risk excluding valuable solutions. (It might be OK to exclude feasible solutions, and even
optimal ones, provided that at least one optimal solution remains.) Too large M values may also
result in numerical errors in the solution procedure.
Now that the general technique of big-M constraints is introduced, let us head back to the
economy of scale and implement the required constraints. There are two conditional constraints to
implement.
• If isOver=0, then tranOver=0 must hold.
• If isOver=1, then tranBase=CostThreshold must hold.
The first constraint can be formulated as follows.
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];

105

6.4. ECONOMY OF SCALE

TRANSPORTATION PROBLEM

Note that when isOver[s,d]=0, then tranOver[s,d]<=0 is enforced, and because it is a nonnegative variable, it will be zero. The value M must be selected to be larger than any sensible values
of tranOver[s,d]. One easy possibility is to add up all total supplies in the problem. Clearly, no
single transportation amount can be larger than this M, we introduced this value as a parameter.
We could provide smaller values for each tranOver[s,d] if we wanted, but a single M will suffice.
The second constraint can be formulated as follows.
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
If isOver[s,d]=1, then tranBase[s,d]>=CostThreshold is enforced, and because parameter
CostThreshold is also an upper bound for tranBase[s,d], they will be equal. If isOver[s,d]=0,
then the constraint is redundant, because the right-hand side, CostThreshold-M is a negative number and tranBase[s,d] is a nonnegative variable. However, we can provide a more clever big-M
for this constraint. The only requirement is that CostThreshold-M cannot be positive, otherwise
tranBase[s,d]=0 would be excluded from the search space entirely, which is unacceptable. But the
big-M in this constraint can be set as low as CostThreshold, in which case CostThreshold-M=0
and the constraint is still redundant when isOver[s,d]=1. However, for this particular big-M, the
whole constraint can be rearranged into a more readable form, as follows.
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold * isOver[s,d];
We can see that if isOver[s,d]=1, then tranBase[s,d]>=CostThreshold is enforced, but if
isOver[s,d]=0, then the constraint is equivalent to tranBase[s,d]>=0, which is redundant.
In conclusion, we added the variable isOver and these two constraints to the previous model for
increasing cost rates, and now our model for transportation problem with economy of scale is ready.
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
param CostThreshold, >=0;
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
var tranBase {(s,d) in Connections}, >=0, <=CostThreshold;
var tranOver {(s,d) in Connections}, >=0;
var isOver {(s,d) in Connections}, binary;

106

6.4. ECONOMY OF SCALE

TRANSPORTATION PROBLEM

s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
s.t. Total_Transported {(s,d) in Connections}:
tran[s,d] = tranBase[s,d] + tranOver[s,d];
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
# tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
tranBase[s,d] >= CostThreshold * isOver[s,d];
minimize Total_Costs: sum {(s,d) in Connections}
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]);
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g=%g+%g " &
"amount for %g (unit cost: %g/%g).\n",
s, d, tran[s,d], tranBase[s,d], tranOver[s,d],
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]),
Cost[s,d], CostOverThreshold[s,d];
}
We get the following results for  
Problem 27.
Optimal cost: 2625.
From S1 to D1, transport 10=10+0 amount for 50 (unit cost: 5/3.75).
From S1 to D5, transport 90=90+0 amount for 450 (unit cost: 5/3.75).
From S2 to D1, transport 110=100+10 amount for 107.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=100+40 amount for 260 (unit cost: 2/1.5).
From S3 to D3, transport 170=100+70 amount for 152.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=20+0 amount for 80 (unit cost: 4/3).
From S4 to D4, transport 90=90+0 amount for 720 (unit cost: 8/6).
From S4 to D6, transport 120=100+20 amount for 805 (unit cost: 7/5.25).
Now the optimal solution is 2625, still better than the original 2700, but not significantly. We
can observe that each time a lower cost is used, the threshold 100 is first reached. Unlike the case
for the increasing unit costs, in Section 6.3, the reduced costs above the threshold now only affect
the objective through pricing, but the optimal solution remains the same in terms of transported
amounts.
Remember that the model contains binary variables, making it an MILP, instead of a pure LP
107

6.5. FIXED COSTS

TRANSPORTATION PROBLEM

model. If the number of binary variables in an MILP is large, computational time required for the
final solution will eventually explode. This is not the case here only because the resulting MILP
model with its 24 binary variables is still considered small.

6.5

Fixed costs

Different scenarios for unit costs and changes were considered. These kinds of costs were all proportional costs, because the calculation formula was always based on the amount in question,
which was multiplied by some constant. In some cases, not only proportional costs, but fixed costs
may be present.
