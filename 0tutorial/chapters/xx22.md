

## Problem 26.

Solve Problem 21, the **transportation problem**, with one modification: there are two **unit costs** for transportation—one for amounts **below** a given **threshold** and a **lower** unit cost for **surplus amounts above** that threshold.

-----

## Problem 27.

Solve Problem 22, the original example transportation problem, with one modification: the given unit costs are only for transportation amounts **below 100 units**. Above that limit, costs are **decreased by 25%** per amount transported.

Note that the only difference between this problem and the previous one is that the unit costs above the threshold are now **lower**, not higher. Even the threshold of 100 and the rate of 25% remain the same. Therefore, it is tempting to address this problem by only slightly modifying our code to calculate with decreasing costs instead. The parameter `CostIncPercent` is renamed to **`CostDecPercent`**, and the `CostOverThreshold` is calculated accordingly.

```
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
```

However, if we solve the model, the results **do not reflect reality**.

```
Optimal cost: 2025.
From S1 to D1, transport 10=0+10 amount for 37.5 (unit cost: 5/3.75).
From S1 to D5, transport 90=0+90 amount for 337.5 (unit cost: 5/3.75).
From S2 to D1, transport 110=0+110 amount for 82.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=0+140 amount for 210 (unit cost: 2/1.5).
From S3 to D3, transport 170=0+170 amount for 127.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=0+20 amount for 60 (unit cost: 4/3).
From S4 to D4, transport 90=0+90 amount for 540 (unit cost: 8/6).
From S4 to D6, transport 120=0+120 amount for 630 (unit cost: 7/5.25).
```

The optimal solution is **2,025**, which is much better than the original 2,700. There is nothing wrong with this so far, because the costs have decreased. But the details show that there are **zero transportation amounts below the threshold** ($\text{tranBase}=0$), meaning the total amount is being transported at the lower price (using $\text{tranOver}$) for amounts above the threshold. This is clearly **not allowed**, as we can only use the lower unit costs *after* we have filled the amounts below the threshold first, paying the higher unit cost for the base amount.

In the case where the cost above the threshold was **higher**, the model worked perfectly. Now, when the cost above the threshold is **lower**, the model is incorrect. What causes this difference?

  * If the unit costs **increase** above the threshold, the amounts below the threshold ($\text{tranBase}$) are filled first, and then we can optionally transport additional amounts above the threshold ($\text{tranOver}$). We (and the model) are *allowed* to transport above the threshold first, but it doesn't provide any benefit. Therefore, these non-optimal approaches are **ruled out by the optimization procedure**.
  * If the unit costs **decrease** above the threshold, however, the optimization **prefers using the amounts above the threshold** ($\text{tranOver}$) because of the lower cost. However, this lower cost is not a "free option," but a "**right**" that must be earned: we can only use the lower unit cost if we have **filled the amounts below the threshold first**. This is **not enforced by the constraints**, and therefore the reported optimal solution is **infeasible in reality**.

To better understand the difference, observe the slightly modified schematic representation of the economy of scale (see **Figure 4**). One might argue that the only difference is that the curve is going downward, not upward, but observe the **feasible region**.

One property of **Linear Programming (LP)** problems is that their search space is always **convex**. This means if we have two feasible solutions, and we take a **convex combination** of these, the result is also a feasible solution. For example, if $x_1 = 3, y_1 = 1$ is one feasible solution, and $x_2 = 7, y_2 = 9$ is another, let's obtain a convex combination of these with weights $\frac{3}{4}$ and $\frac{1}{4}$. We get $x_3 = \frac{3}{4} x_1 + \frac{1}{4} x_2 = 4$ and $y_3 = \frac{3}{4} y_1 + \frac{1}{4} y_2 = 4$, which is guaranteed to be also feasible. If we investigate what general constraints are allowed in LP models, the convexity of the feasible region can be easily verified.

However, if we look at the schematic representation in **Figure 4**, the feasible region is **not convex**. Moreover, we cannot make it convex by cutting parts from it. The reason is that we must allow feasibility on both of the two red line segments, but their **convex combinations fall into the infeasible region** that must be prohibited by model constraints. We can see why this wasn't a problem in the case of increasing unit costs: because the convex combinations of the two red line segments fell into the **feasible region**—those cases didn't make sense in reality, but the model still included them, and overall the problem could be perfectly modeled by LP.

Since the feasible region is clearly not convex, this suggests that the **economy of scale cannot be modeled by LP**. However, we can model it by adding **integer variables**, making the model a **Mixed-Integer Linear Program (MILP)**. Our goal is to ensure that the amounts below the threshold, denoted by $\text{tranBase}$, are **fully utilized** whenever any amounts are transported above the threshold, denoted by $\text{tranOver}$.

For each connection, we introduce a **binary variable**, $\text{isOver}$.

```
var isOver {(s,d) in Connections}, binary;
```

The meaning of $\text{isOver}$ is whether we are **entitled** (= 1) or not (= 0) to transport for the lower unit cost, for amounts above the threshold. This binary variable introduces a **discrete nature** to the problem, and now the search space is **not convex** because no fractional values are allowed for $\text{isOver}$ between 0 and 1. Depending on the value $\text{isOver}$ takes, there are specific circumstances required:

  * If $\text{isOver}=0$, then we **cannot** use the lower cost, hence the amounts above the threshold ($\text{tranOver}$) **must be zero**.
  * If $\text{isOver}=1$, then we **must** earn the right to use the lower costs, hence the amounts below the threshold ($\text{tranBase}$) **must be maximal**, i.e., equal to the threshold amount ($\text{CostThreshold}$).

### The Big-M Constraint Technique

It's a common problem in mathematical programming that we have an ordinary linear constraint, like $A \ge B$, but we want this constraint to be **active if and only if a certain condition is met**. The condition is often represented by the value of a binary variable $x$. If $x = 1$, then constraint $A \ge B$ must hold. However, if $x = 0$, there are no restrictions on $A$ or $B$.

The modeling technique used is called the **big-M constraint**. The first step is to arrange the linear constraint into the form $B - A \le 0$, then find a **positive upper bound** for $B - A$. This upper bound ($\mathbf{M}$) must be large enough to include all possible values for all model variables appearing in the expression $B - A$. In practice, often a very large number, like $M = 1,000,000$, is selected as an upper bound, which is magnitudes larger than any sensible solution for the problem, and is sufficient. This is the so-called **big-M value**.

Then, include the following constraint in the model formulation:

$$B - A \le M \cdot (1 - x)$$

Now, let's investigate what this constraint does in the model. Because $x$ is an integer variable, there are two cases:

1.  If **$x = 1$**, then the constraint reduces to $B - A \le 0$, which is exactly what we wanted to achieve when $x = 1$.
2.  If **$x = 0$**, the constraint reduces to $B - A \le M$. Remember that $M$ is magnitudes larger than any possible, sensible values of $B - A$. Therefore, the constraint becomes **redundant**, as it does not impose further restrictions on model variables—again, exactly what we wanted for $x = 0$.

If the linear constraint is an **equation**, like $A = B$, then we can express it as two inequalities ($A \ge B$ and $A \le B$) and implement a big-M constraint for each. If the condition is not $x = 1$ but $x = 0$ instead, then we can simply replace $(1 - x)$ with $x$ in the model formulation, as the negation of any binary value $x$ is $(1 - x)$.

This is a very general technique that allows for the **conditional inclusion of linear constraints** in MILP models, provided that their condition can be expressed as a binary variable (or any other linear expression that results in a value that can only be 0 or 1, but nothing in between).

One might ask: if $M$ is only required to be large enough, what is the most suitable $M$ to be given? From an algorithmic point of view, the best choice is usually the **lowest possible $M$**. Be careful, though, if $M$ is too small, the constraint is not redundant when the condition is not met, and we risk excluding valuable solutions. (It might be okay to exclude feasible solutions, and even optimal ones, provided that at least one optimal solution remains.) Too large $M$ values may also result in **numerical errors** in the solution procedure.

### Implementing the Economy of Scale Constraints

Now that the general technique of big-M constraints is introduced, let's head back to the economy of scale and implement the required constraints. There are two conditional constraints to implement:

1.  If $\text{isOver}=0$, then $\text{tranOver}=0$ must hold.
2.  If $\text{isOver}=1$, then $\text{tranBase}=\text{CostThreshold}$ must hold.

The first constraint can be formulated as follows. We define the big-M parameter as the sum of all available supplies, ensuring it is a safe upper bound for any single transportation amount.

```
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];
```

Note that when $\text{isOver}[s,d]=0$, then $\text{tranOver}[s,d] \le 0$ is enforced, and because it is a nonnegative variable, it must be zero. The value $M$ must be selected to be larger than any sensible value of $\text{tranOver}[s,d]$. One easy possibility is to add up all total supplies in the problem. Clearly, no single transportation amount can be larger than this $M$; we introduced this value as a parameter. We could provide smaller values for each $\text{tranOver}[s,d]$ if we wanted, but a single $M$ will suffice.

The second constraint can be formulated as follows.

```
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
```

  * If $\text{isOver}[s,d]=1$, then $\text{tranBase}[s,d] \ge \text{CostThreshold}$ is enforced, and because parameter $\text{CostThreshold}$ is also an upper bound for $\text{tranBase}[s,d]$, they will be equal ($\text{tranBase}[s,d]=\text{CostThreshold}$).
  * If $\text{isOver}[s,d]=0$, then the constraint is redundant, because the right-hand side, $\text{CostThreshold} - M$ is a negative number and $\text{tranBase}[s,d]$ is a nonnegative variable.

However, we can provide a **more clever big-M** for this constraint. The only requirement is that $\text{CostThreshold} - M$ cannot be positive; otherwise, $\text{tranBase}[s,d]=0$ would be excluded from the search space entirely, which is unacceptable. But the big-M in this constraint can be set as low as $\mathbf{CostThreshold}$, in which case $\text{CostThreshold} - M = 0$, and the constraint is still redundant when $\text{isOver}[s,d]=0$. For this particular big-M, the whole constraint can be rearranged into a more readable form, as follows:

```
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold * isOver[s,d];
```

We can see that if $\text{isOver}[s,d]=1$, then $\text{tranBase}[s,d] \ge \text{CostThreshold}$ is enforced, but if $\text{isOver}[s,d]=0$, then the constraint is equivalent to $\text{tranBase}[s,d] \ge 0$, which is redundant (since $\text{tranBase}$ is a nonnegative variable).

In conclusion, we added the variable $\text{isOver}$ and these two constraints to the previous model for increasing cost rates, and now our model for the transportation problem with **economy of scale** is ready.

### Full MILP Model for Economy of Scale

```
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
param CostThreshold, >=0;
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
var tranBase {(s,d) in Connections}, >=0, <=CostThreshold;
var tranOver {(s,d) in Connections}, >=0;
var isOver {(s,d) in Connections}, binary;

s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
s.t. Total_Transported {(s,d) in Connections}:
tran[s,d] = tranBase[s,d] + tranOver[s,d];
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
# tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
tranBase[s,d] >= CostThreshold * isOver[s,d];
minimize Total_Costs: sum {(s,d) in Connections}
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]);
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g=%g+%g " &
"amount for %g (unit cost: %g/%g).\n",
s, d, tran[s,d], tranBase[s,d], tranOver[s,d],
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]),
Cost[s,d], CostOverThreshold[s,d];
}
```

We get the following results for **Problem 27**:

```
Optimal cost: 2625.
From S1 to D1, transport 10=10+0 amount for 50 (unit cost: 5/3.75).
From S1 to D5, transport 90=90+0 amount for 450 (unit cost: 5/3.75).
From S2 to D1, transport 110=100+10 amount for 107.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=100+40 amount for 260 (unit cost: 2/1.5).
From S3 to D3, transport 170=100+70 amount for 152.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=20+0 amount for 80 (unit cost: 4/3).
From S4 to D4, transport 90=90+0 amount for 720 (unit cost: 8/6).
From S4 to D6, transport 120=100+20 amount for 805 (unit cost: 7/5.25).
```

Now, the optimal solution is **2,625**, which is still better than the original 2,700, but not significantly. We can observe that each time a lower cost is used (i.e., $\text{tranOver}>0$), the **full threshold of 100 is first reached** ($\text{tranBase}=100$). Unlike the case for the increasing unit costs in Section 6.3, the reduced costs above the threshold now only affect the objective through pricing, and the optimal solution remains the same in terms of the transported amounts.

Remember that the model contains **binary variables**, making it an **MILP**, instead of a pure LP model. If the number of binary variables in an MILP is large, the computational time required for the final solution may increase dramatically. This is not the case here only because the resulting MILP model, with its 24 binary variables, is still considered **small**.

-----

## 6.5 Fixed Costs

Different scenarios for unit costs and changes were considered. These kinds of costs were all **proportional costs** because the calculation formula was always based on the amount in question, which was multiplied by some constant. In some cases, not only proportional costs, but **fixed costs** may also be present.

