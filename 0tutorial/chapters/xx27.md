

## Problem 36.

Given a set of $N \ge 1$ **real numbers**, divide them **exhaustively** into exactly $K \ge 1$ **subsets** so that the difference between the **smallest** and **largest** sum of numbers in a subset is **minimal**.

The **multi-way number partitioning problem** can be interpreted as a modified version of the **knapsack problem** where all $N$ **items** must be packed into any one of $K$ given **knapsacks**, and this distribution shall be as **balanced** as possible. There is no **gain value** in the multi-way number partitioning problem (or, it can be interpreted as being equal to the **weight** of the item).

We will solve one example problem.

-----

## Problem 37.

**Distribute** the $N=10$ **items** described in Problem 35, the **knapsack example problem**, into $K=3$ **knapsacks** so that the difference between the **lightest** and the **heaviest** knapsack is **minimal**.

Let's see how this can be **implemented** in **GNU MathProg**. First, there is an `Items` set and a `Weight` parameter, as before, but there is no `Gain` parameter. Instead, we **define** a single integer parameter `Knapsack_Count`, which refers to the **positive integer** $K$ in the problem description.

```
set Items;
param Weight {i in Items}, >=0;
param Knapsack_Count, integer;
set Knapsacks := 1 .. Knapsack_Count;
```

We also introduced the set `Knapsacks`. However, instead of reading this set from the data section, we **denote** each knapsack by numbers from **1 to K**. The operator `..` defines a set by the **smallest** and **largest** integer element, **enlisting** all integers in between.

Note that we require `Weight` to be **non-negative**; however, these parameters can be restricted to **integers** in general, or relaxed to take **real values**. The **model** is exactly the same in all cases.

There are **more decisions** to be made than in the original knapsack problem. For each item, we don't only decide whether it **goes to the knapsack or not**, but we now decide **which knapsack it goes into**. This can be done by defining a **binary decision variable** `select` for each pair of an **item** and a **knapsack**, denoting whether the item goes into that particular knapsack or not. These decisions determine the situation well, but **auxiliary** and **other variables** are needed to express the **objective function concisely**. Therefore, we also introduce an **auxiliary variable** `weight` for each knapsack, denoting its **total weight**, and `min_weight` and `max_weight` for the **minimal** and **maximal** knapsack weight.

```
var select {i in Items, k in Knapsacks}, binary;
var weight {k in Knapsacks};
var min_weight;
var max_weight;
```

There is only **one constraint** which establishes whether a decision about knapsacks is **feasible**: **each item must go exactly into one knapsack**, **not more and not less**. If we add some binary variables and set the sum equal to one, then its only feasible solution is when **one binary variable is 1 and all others are 0**. Therefore, the constraint is the following.

```
s.t. Partitioning {i in Items}:
sum {k in Knapsacks} select[i,k] = 1;
```

We provide **three additional constraint statements** to express the calculation of the weight of each knapsack, a **lower limit** on all knapsack weights (`min_weight`), and an **upper limit** (`max_weight`), respectively.

```
s.t. Total_Weights {k in Knapsacks}:
weight[k] = sum {i in Items} select[i,k] * Weight[i];
s.t. Total_Weight_from_Below {k in Knapsacks}:
min_weight <= weight[k];
s.t. Total_Weight_from_Above {k in Knapsacks}:
max_weight >= weight[k];
```

The **objective** can be the **difference** between the upper and lower limit.

```
minimize Difference: max_weight - min_weight;
```

This design had been used before for **minimizing errors in equations** (see Section 4.8), **maximizing minimum production volumes** (see Section 5.3), and some **cost functions** (see, for example, Sections 6.3 or 6.6). The key is that the solver is allowed **not** to assign the actual **minimum** and **maximum** weights to the variables `min_weight` and `max_weight` to obtain **feasible solutions**. It's just **not beneficial** to do so, and therefore, those solutions where these two bounds are not **strict** are **automatically ruled out**.

Finally, we **print the contents of each knapsack** after the `solve` statement, and our model section is **ready**.

```
set Items;
param Weight {i in Items}, >=0;
param Knapsack_Count, integer;
set Knapsacks := 1 .. Knapsack_Count;
var select {i in Items, k in Knapsacks}, binary;
var weight {k in Knapsacks};
var min_weight;
var max_weight;
s.t. Partitioning {i in Items}:
sum {k in Knapsacks} select[i,k] = 1;
s.t. Total_Weights {k in Knapsacks}:
weight[k] = sum {i in Items} select[i,k] * Weight[i];
s.t. Total_Weight_from_Below {k in Knapsacks}:
min_weight <= weight[k];
s.t. Total_Weight_from_Above {k in Knapsacks}:
max_weight >= weight[k];
minimize Difference: max_weight - min_weight;
solve;
printf "Smallest difference: %g (%g - %g)\n",
Difference, max_weight, min_weight;
for {k in Knapsacks}
{
printf "%d:", k;
for {i in Items: select[i,k]}
{
printf " %s", i;
}
printf " (%g)\n", weight[k];
}
end;
```

Solving the example **Problem 37** gives the following result.

```
Smallest difference: 2.5 (55.3 - 52.8)
1: C F J (53.2)
2: D E H I (55.3)
3: A B G (52.8)
```

The **ten items** could be divided into **three subsets** of roughly **equal size**. The **largest knapsack** is the second, with a weight of **55.3**, and the **smallest** is the third, with **52.8**. Note that the **order of knapsacks** is **not important**. Because **all ten items are distributed**, it is **guaranteed** that the sum of the three knapsacks is a **constant**; therefore, their **average** is also **constant** and must be in between the two limits.

Another similar, interesting, and **better-known problem** is the so-called **bin packing problem**, where all items are known, but the **knapsack sizes are fixed**. Therefore, the **number of knapsacks** (called **bins**) is to be **minimized** [20]. This could also be solved in **GNU MathProg**, but it is not detailed here.

-----

## 7.2 Tiling the Grid ðŸ§±

The **knapsack** and **similar problems** require items to "fit" somewhere. "Fitting" means that each item has a **weight**, and the **sum of the weights** is under a **constraint**. But what happens when **fitting is more complex**? For instance, considering the **size** or **shape** of items and their **container** is also a **common real-world question** that can lead to much more **difficult optimization problems**.

A **two-dimensional example** is the class of **tiling problems**, where copies of the **same shape** called **tiles** are used to **cover a region** in the plane. Tiles are usually **forbidden to overlap**, and the **cover** is often required to be **perfect**; that is, **all of the designated region is covered**. If we don't require **perfect covering**, then one may ask what is the **most area we can cover**, which is an **optimization problem**. Provided that there is a **single tile**, the **congruent copies** of which are used, the optimization problem simplifies to **maximizing the non-overlapping tiles** that can be put into the region.

In this section, we **restrict tiling** to the **rectangular grid** of **unit squares**. The **tile**, its **all possible positions**, and the **region to be covered** all fit onto **unit squares** of the same grid. The tile will be the **simplest cross** consisting of **five squares**. For the sake of simplicity, the **region to be covered** is a **rectangular area** (see ). Tiles cannot cover area outside the region.

 
