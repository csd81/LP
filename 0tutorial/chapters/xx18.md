

**Problem 20.**

Solve **Problem 18**, a production problem example with arbitrary recipes, with the following modifications:

  * **Raw Material Usage Limits:** The maximum usage limits for raw materials have been reset. Instead of 23,000 units of A, 31,000 units of B, 450,000 units of C, and 200 units of D, the new limits are **50,000 units of A**, **120,000 units of B**, **1,000,000 units of C**, and **1,500 units of D**.
  * **Initial Funds:** Initial funds are capped at **35,000**.
  * **Available Orders:** There are three available orders with the following properties:

| | **Ord1** | **Ord2** | **Ord3** |
|:---|:---:|:---:|:---:|
| **Payment Before** | no | no | yes |
| **Expense** | 10,000 | 10,000 | ‚Äî |
| **Income** | ‚Äî | ‚Äî | 500 |
| **Maximum Count** | 10 | 10 | 30 |
| **Obtain A** | 20,000 | 15,000 | 190 |
| **Obtain B** | 10,000 | 10,000 | 20 |
| **Obtain C** | 300,000 | 400,000 | 3,000 |
| **Obtain D** | 500 | 500 | ‚Äî |
| **Deliver P1** | 40 | 45 | 1 |
| **Deliver P2** | 80 | 70 | ‚Äî |
| **Deliver P3** | ‚Äî | 6 | ‚Äî |

The data section implementation and the solution output are as follows:

```glp
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 50000
B 120000
C 1000000
D 1500
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A
B
C
D
P1
P2
P3 :=
MakeP1 200
25 3200
1
1
0
0
MakeP2
50 180 1000
1
0
1
0
MakeP3
0
75 4500
1
0
0
1
Comp1
240 200 4400
2
1
1
0
Comp2
51 250 5400
2
0
1
1
;
param Initial_Funds := 35000;
set Orders := Ord1 Ord2 Ord3;
param Order_Material_Flow:
A
B
C
D
P1
P2
P3 :=
Ord1 20000 10000 300000 500
40
80
0
Ord2 15000 10000 400000 500
45
70
6
Ord3
190
20
3000
0
1
0
0
;
param Order_Cash_Flow := # negative means income
Ord1 10000
Ord2 10000
Ord3 -500
;
param Order_Count :=
Ord1 10
Ord2 10
Ord3 30
;
param Order_Pay_Before :=
Ord1 0
Ord2 0
Ord3 1
;
end;
Total Costs: 26497.3
Total Revenue: 47202.7
Profit: 20705.4
Acquiring order Ord1: 1x
Acquiring order Ord2: 0x
Acquiring order Ord3: 30x
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 553.716
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 89.1554
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 25700 + 23893.1 -> 49593.1 + 0 (total: 49593.1)
Consumption of raw B: 10600 + 109400 -> 120000 + 0 (total: 120000)
Consumption of raw C: 390000 + 610000 -> 1e+06 + 0 (total: 1e+06)
Consumption of raw D: 500 + 252.027 -> 752.027 + 0 (total: 752.027)
Products (production -> orders + market):
Production of product P1: 89.1554 -> 70 + 19.1554 (total: 89.1554)
Production of product P2: 652.872 -> 80 + 572.872 (total: 652.872)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

Since the maximum usages for raw materials are much larger and production is generally profitable, the extra capacities result in a significant increase in the objective function. Also, orders are being used.

We can see that the **optimal profit is 20,705.4**. The total production volume is **89.16 units of P1**, **553.72 units of P2**, and **10 units of P3**. We acquire **Ord1 once** and **Ord3 30 times**, which is the maximum available. Ord3 is a lucrative way to produce and deliver product P1. Significant amounts of each raw material are obtained through orders, and additional amounts are purchased from the market. For this reason, there are **no leftovers** after production. Some of the products are delivered via orders, but in all three cases, amounts are also sold on the market.

Let's run an experiment to examine the integer nature of this model. As previously mentioned, this is an **MILP** (Mixed-Integer Linear Programming) model because of the order acquisition decisions, which must be modeled using integer variables. However, `glpsol` has a built-in `--nomip` option to relax all integer variables.

**Relaxing** means that variables are not forced to be integers but are only constrained to be between their defined lower and upper bounds, if any. By relaxing all integer variables of an MILP model, we obtain its **LP (Linear Programming) relaxation**.

```bash
glpsol -m model.mod -d data.dat --nomip
```

If this option is used, the model is treated as an LP. This is solved much faster, but integer variables are allowed to take fractional values. If this occurs, the solution is **infeasible in reality**. Using this option on the problem instance above, the following result is reported:

```
Total Costs: 12163
Total Revenue: 33560
Profit: 21397
Acquiring order Ord1: 1x
Acquiring order Ord2: 0x
Acquiring order Ord3: 30x
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 550
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 90
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 35700 + 13910 -> 49610 + 0 (total: 49610)
Consumption of raw B: 15600 + 103900 -> 119500 + 0 (total: 119500)
Consumption of raw C: 540000 + 460000 -> 1e+06 + 0 (total: 1e+06)
Consumption of raw D: 750 + 0 -> 750 + 0 (total: 750)
Products (production -> orders + market):
Production of product P1: 90 -> 90 + 0 (total: 90)
Production of product P2: 650 -> 120 + 530 (total: 650)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

The optimal solution of the LP relaxation is **21,397**, which is **better** than the MILP's profit of 20,705.4. This is a natural result because the LP relaxation has a wider search space, including all MILP solutions and possibly others where integer variables take fractional values. The LP relaxation is important not for modeling but for the algorithmic solution process. The LP relaxation of an MILP is usually fast to solve, and its optimal solution is guaranteed to be an **upper bound** for the optimal solution of the MILP itself. This is useful because solving the MILP to global optimality can be hard or impossible. The optimal solution will always lie between the best currently found integer solution and a suitable bound, like the LP relaxation.

If we look closely at the LP relaxation solution, it surprisingly seems "more integer" than the MILP solution. However, because the objective values are different, we can be certain that at least one integer variable has a fractional value. In fact, there are partially acquired orders; for example, **Ord1 is acquired 1.5 times**. We can deduce this by looking at the material amounts related to orders. The reason this wasn't reported is simply that the order count was printed using the `%d` format specifier, which rounds the fractional value to the nearest integer before printing. Therefore, the post-processing output is not precise when integer variables are relaxed. Alternatively, `%f` or `%g` could have been used.

-----

### 5.8 Production Problem ‚Äì Summary üìù

We began with the simplest production problem: given only the available amounts of raw materials, the goal was to decide the production mix to achieve the highest revenue. We demonstrated how this problem can include upper and lower limits on production and consumption, how to optimize using a different objective if necessary, and how to factor in raw material costs.

The **diet problem**‚Äîdetermining the optimal amount of certain food types to satisfy nutritional requirements‚Äîwhile seemingly quite different, resulted in a very similar implementation to the production problem. In fact, the two problems can be interpreted as special cases of a more general production problem where recipes may involve multiple raw materials and products simultaneously.

Finally, the concept of **orders** was introduced in the ultimate model of the chapter, which gave the problem an **integer nature**. This is because orders can only be acquired and fulfilled completely, not partially. This extension provides new possibilities for raw material supply and final product demand, and the problem remains linear. Additional data files, ranging from basic to more complex problems, can be easily implemented and solved using the same single model file.


