-----------------------
Chapter 8

Solution algorithms
So far, the LP and MILP modeling techniques and GNU MathProg implementation details were in
focus. Mathematical programming models are solved by dedicated solvers. Usually the modeling
procedure can be performed without knowing how the solvers work.
Nevertheless, an expertise in the solution algorithms themselves can be valuable when modeling.
It may help designing models, improving their efficiency, choosing the appropriate solver tools and
configurations, interpreting results and solver outputs. Therefore, this chapter is dedicated to give
an insight into how the models we describe in a modeling language are solved in the background.
Operations research has a very rich literature from the seventies regarding solution algorithms,
we propose some books for the interested readers. First of all, book of W. L. Winston [31] is a very
commonly used handbook, considering the main models and algorithms. We recommend also the
book of István Maros about Linear Programming [32], and the book of George Dantzig [33].
In fact, Linear Programming (LP) is a main technique within operations research. There are
several solution methods, and within them we must mention the Simplex Method (and its different
versions). The first version called Primal Simplex Method was introduced by George Dantzig in
1947. In the next chapter we briefly introduce it by solving a simple production problem.

8.1

The Primal Simplex Method

Given the next table with the data of a production problem.
Res1
Res2
Res3
Profit

P1
1
0
1
19

P2
2
1
0
23

P3
1
1
0
15

P4
3
5
2
42

P5
0
1
2
33

Cap
24
43
18

The meaning of the data is analogous to production problems mentioned before (see Problem 9
from Chapter 5).
We have a small factory where we may produce several products (P1 , ..., P5 ). We have three
resources for the production, a column belongs for each product, showing how many units from
the resources must be used, respectively, for producing one unit of the corresponding product. For
example, if we produce one unit from product P4 , we will use 3 units from resource Res1 , 5 units
from resource Res2 , and 2 units from resource Res3 . A resource can be in fact some kind of raw
material, or a human resource, electricity, etc. We can produce as many from the products as we
want, except that the production will consume the capacities of the resources, and these capacities
must not be exceeded. For example, if we produce 8 units from P2 and 1 unit from P4 , then in
166

8.1. THE PRIMAL SIMPLEX METHOD

SOLUTION ALGORITHMS

total we will consume as many as 8 · 2 + 1 · 3 = 19 units from the first resource. The usage from the
other resources can be calculated similarly. We will gain certain amount of profit for the production,
this is again a linear combination of the production plan and the vector of coefficients of the profit.
If the production vector is as before, x(0, 8, 0, 1, 0), introducing vector c(19, 23, 15, 42, 33) for the
profit, the gained profit would be c · x = (19, 23, 15, 42, 33) · (0, 8, 0, 1, 0) = 226. Our goal is to find
a production plan where all constraints are satisfied and the gained profit is as large as possible.
Denoting the matrix of the coefficients in the rows of resources and columns of products by A, the
vector of capacities of resources by b, our problem can be written as below:

st.

z = c · x → max
Ax ≤ b, x ≥ 0.

We can see that this is a general format for LP models. We show how we can solve it by the
Primal Simplex Method. First let us see the model in a detailed form:
+x3 +3x4
≤ 24
+x3 +5x4 +x5 ≤ 43
+2x4 +2x5 ≤ 18
xi ≥ 0, 1 ≤ i ≤ 5
19x1 +23x2 +15x3 +42x4 +33x5 = z → max
x1 +2x2
+x2
x1

First we change the inequalities by adding so-called slack variables to the left hand side, gaining
equations, like below.
x1 +2x2
x2
x1

+x3 +3x4
+s1
= 24
+x3 +5x4 +x5
+s2
= 43
+2x4 +2x5
+s3 = 18
x ≥ 0, s ≥ 0
19x1 +23x2 +15x3 +42x4 +33x5
= z → max
In the above model we write x ≥ 0 instead of writing the nonnegativity constraints one by one
for the variables but the meaning is the same. The same holds for the s vector. Instead of the
system of equations we can use a brief form to handle the data. This brief form is called simplex
tableau, which is shown below.
B
u1
u2
u3
z

xB
24
43
18
0

a1
1
0
1
−19

a2
2
1
0
−23

a3
1
1
0
−15

a4
3
5
2
−42

a5
0
1
2
−33

u1
1
0
0
0

u2
0
1
0
0

u3
0
0
1
0

We note that there are several versions of the simplex tableau; and all are equivalent. Here we
use that version where the basis solution is put to the left hand side, and the extra row belonging
to the objective is put in the bottom. These special choices have no importance in fact.
Here B means basis, which is a maximal linearly independent set of vectors. Now B =
{u1 , u2 , u3 }, the basis is composed now (initially) from the three unit vectors. The corresponding basis solution is xB = (0, 0, 0, 0, 0, 24, 43, 18). This is a solution of the linear system, moreover
each variable is nonnegative (i.e. the solution is feasible), and any nonzero component in the vector
belongs to a basis vector.
The tableau contains all data, and it also has an extra row.
How do we define the extra row of the objective function? Here simply the negatives of the
coefficients of the c vector appear.
The next theorem is crucial:
167

8.1. THE PRIMAL SIMPLEX METHOD

SOLUTION ALGORITHMS

Theorem 1 Exactly one of the following options happens.
a, There is no negative entry in the last row. In this case the corresponding basis solution is optimal.
b, There is a negative value in the last row, such that there is no positive value in its column. In
this case there is no optimal solution, as the objective value is not bounded from above.
c, Otherwise (there is a negative value in the last row, but for any such value there exists a positive
value in its column) we can perform a basis transformation so that the corresponding value of the
objective will not be smaller.
Since we give only a brief overview here about the simplex method, we do not prove the theorem,
the interested reader can find it in any proposed book. But we show how the transformation goes.
Each transformation exchanges one vector in the basis to another one not already there.
Let us suppose that we choose the column of a2 for the vector that enters the basis. We are not
allowed to choose the vector that will leave the basis, this choice must be made by a rule that is
43
called the minimum rule. This is as follows. We take the following minimum: min 24
2 , 1 , here
the fractions are created so that the numerator is taken from the basis solution, and the denominator
is taken from the same row and the chosen column. We cannot divide by zero, and we do not want
to divide by negative value. The minimum is found as 24/2, this means that the vector of the row
of 24 must be chosen as leaving vector. So u1 leaves the basis. We call the 2 value as pivot number,
we wrote it by bold letter in the tableau.
How do we perform the transformation? The row of the pivot value is divided by the pivot value
(i.e. by 2), and 1/2 times of the row of the pivot value is subtracted from the second row, 0/2 times
of the row of the pivot value is subtracted from the third row, and 23/2 times of the row of the
pivot value is added to the row of the objective. In the above calculations (i.e. 1/2, 0/2, and 23/2)
the numerator comes from the column of the pivot value, and the denominator is always the pivot
value. The goal of choosing these factors is that by adding the pivot row to others, each element in
the pivot column other than the pivot element is eliminated to zero. After the transformation we
get the following tableau.
B
a2
u2
u3
z

xB
12
31
18
276

a1
1/2
−1/2
1
−15/2

a2
1
0
0
0

a3
1/2
1/2
0
−7/2

a4
3/2
7/2
2
−15/2

a5
0
1
2
−33

u1
1/2
−1/2
0
23/2

u2
0
1
0
0

u3
0
0
1
0

Now let us choose the column of a5 to enter the basis. According to the minimum rule u3 is the
leaving vector. After the transformation we get:
B
a2
u2
a5
z

xB
12
22
9
573

a1
1/2
−1
1/2
9

a2
1
0
0
0

a3
1/2
1/2
0
−7/2

a4
3/2
5/2
1
51/2

a5
0
0
1
0

u1
1/2
−1/2
0
23/2

u2
0
1
0
0

u3
0
−1/2
1/2
33/2

Only one negative entry remained in the last row, we must choose this column to enter the basis.
According to the minimum rule a2 leaves the basis.
As we could realize, the rule of the change of the objective function is the following:
• If we choose a column to enter the basis where the value is negative in the row of the objective:
the consequence is that the objective value is growing.
• If we choose a column where the value in the bottom is positive: the objective will decrease
(but we do not want this as our goal is to maximize the objective)
168

8.1. THE PRIMAL SIMPLEX METHOD

SOLUTION ALGORITHMS

• If we choose a column where the value in the bottom line is zero: there will be no change in
the objective value.
Note that this rule about the choice of the entering column and the change of the objective is
only true if the basis solution is non-degenerate, which means that if for example the current basis
is B(a2 , u2 , a5 ), then all out of x2 , s2 , x5 are positive. In fact, if the value of the variable in the basis
solution in the row of the pivot value would be zero then there will be no change in the column of
the basis solution, so there is no change in the objective.
Let us see what happened after the transformation:
B
a3
u2
a5
z

xB
24
10
9
657

a1
1
−3/2
1/2
25/2

a2
2
−1
0
7

a3
1
0
0
0

a4
3
1
1
36

a5
0
0
1
0

u1
1
−1
0
15

u2
0
1
0
0

u3
0
−1/2
1/2
33/2

We can see that there is no more negative entry in the last row which means (according to
Theorem 1) that the present solution is optimal. This optimal solution is as follows: xB =
(0, 0, 24, 0, 9 |0, 10, 0 ). Here in the vector we put a vertical line to separate the first five variables
from the last three variables (i.e. the slack variables), as their meanings are different. Now the
solution means that in the optimal solution (if we get maximal amount of profit, so that all constraints are still satisfied) we need to produce 24 units and 9 units from the third and fifth products,
respectively. Moreover, 10 units form the second resource remains, the whole amounts of the other
two resources are completely consumed.
We can realize that we have performed three transformations, but we could also have reached the
final tableau by only two transformations (as only a3 and a5 needed to be changed in the original
basis). It is not easy to see in advance what kinds of transformations will lead to the final state in
the fewest steps. But there are several tricks that can help. For example (for such a small problem)
it can be beneficial if we choose such a vector to leave the basis, for which the increment of the
objective is as much as possible.
There are other issues that can make the case difficult, for example very rarely "cycling" can
happen, this means that after several transformations we return to some basis that we had before.
This case is very rare in the practice, it almost never happens.
Another issue is that in many cases before we start to solve a problem, we can make some
preprocessings, e.g. some constraints can be found that are redundant (which means that we loose
nothing if we delete the constraint, the optimal solution of the remaining system will be the same).
What happens if the factory introduces a new (in fact a sixth) product, so that the data of
its resource need is given by a6 ? We can realize easily that there is no need to repeat the whole
computation, we compute only the column of the new product (the transformed form of the a6
vector can be written as B −1 a6 , where B is the present basis, and B −1 is its inverse), and we insert
this column vector into the tableau. If the coefficient of this new vector in the last row (calculated
as cB B −1 a6 − c6 ) is nonnegative, it means that producing this new product is not advantageous.
Otherwise this value is negative, and only this one is the negative value in the last row. Then we
continue the transformations as we made it before. For an example, let us suppose that the column
of the new product is a6 (1, 2, 1)T , here the components mean the resource consumption from the
three resources for producing one unit from this new product (say product P6 ). Furthermore, let
c6 = 35 which means the profit gained from producing one unit from this product. Note that
currently the basis is




1 0 0
1
0 0
B(a3 , u2 , a5 ) =  1 1 1  and B −1 =  −1 1 −1/2  .
0 0 2
0
0 1/2
169

8.2. THE TWO-PHASE (PRIMAL) SIMPLEX METHOD

SOLUTION ALGORITHMS

We can find the inverse also in the last three columns of the simplex tableau. Thus B −1 a6 =
∗
1, 21 , 12 , and cB B −1 a6 −c6 = (15, 0, 33)·(1, 1/2, 1/2)−35 = −7/2, which means that the production
of the new product is advantageous, and the procedure will continue, the vector representing the
new product will enter the basis.
Finally we mention an article which treats certain different pivoting rules [34].

8.2

The Two-phase (Primal) Simplex Method

Here we introduce very briefly the two-phase method. What has been shown before, this is in fact
the second phase of the method. So we need to show the first phase.
The purpose of the first phase is finding a feasible basis solution, while in the second phase,
starting from the feasible (basis) solution, step by step we get an optimal solution. When do we
need the first phase? In such a case when we are not able to begin with a suitable feasible solution.
We show the first phase through an example. Let us suppose that our LP is as follows:
+x3 +3x4
≥ 24
+x3 +5x4 +x5 ≤ 43
+2x4 +2x5 = 18
xi ≥ 0, 1 ≤ i ≤ 5
19x1 +23x2 +15x3 +42x4 +33x5 = z → max
We modified our original example a little bit. It can be interpreted that from the first resource
we need to use at least 24 units, we can use at most 43 units from the second resource (as before),
and finally, we need to consume all amounts of the third resource.
First we convert the inequalities to equations.
x1 +2x2
x2
x1

+x3 +3x4
−s1
= 24
+x3 +5x4 +x5
+s2 = 43
+2x4 +2x5
= 18
x ≥ 0, s ≥ 0
19x1 +23x2 +15x3 +42x4 +33x5
= z → max
x1 +2x2
x2
x1

Now we can realize that we do not have enough unit vectors (that would serve us as an initial
basis). We note that here s2 is called slack variable and s1 is called surplus variable. Let us create
the missing unit vectors that we will need for a basis:
+x3 +3x4
−s1
+t1
= 24
+x3 +5x4 +x5
+s2
= 43
+2x4 +2x5
+t2 = 18
x ≥ 0, s ≥ 0, t ≥ 0
19x1 +23x2 +15x3 +42x4 +33x5
= z → max
We call t1 and t2 as artificial variables, as we will use them but we „are not allowed” to use
them. It is true that the original equation system has a feasible solution (which means that all
equations are satisfied with the bounded x and s variables) if and only if we can eliminate the
artificial variables from the system. So our goal is to eliminate them, this will be the task of the
first phase. Our technique is to introduce an artificial (or secondary) objective function as follows,
∧
∧
let z = −t1 − t2 . Instead of the original objective function z, we will maximize z in the first phase
∧
(in the same way as we have shown how we maximize z). If the maximum value of z is zero, it
means that we already eliminated the artificial variables, and continue with the second phase, where
∧
we return to the original objective function. Otherwise, if the maximum of z is negative, it means
that the original LP cannot be solved without the artificial variables, i.e. does not have a feasible
solution.
x1 +2x2
x2
x1

170

8.3. THE DUAL SIMPLEX METHOD

8.3

SOLUTION ALGORITHMS

The Dual Simplex Method

There are several versions of the simplex method, besides the Primal Simplex Method, the Dual
Simplex Method is the other main version. We introduce it briefly. Let us consider the following
LP:
x1
+x3 ≥ 1
2x1 +x2 +3x3 ≥ 3
x1 +2x2
≥5
4x1 +2x2 +x3 ≥ 7
x≥ 0
10x1 +12x2 +15x3 = z → min
After multiplying all inequalities and the objective function by −1, and adding slack variables
we get the following system:
−x1
−x3 +s1
= −1
−2x1 −x2 −3x3
+s2
= −3
−x1 −2x2
+s3
= −5
−4x1 −2x2 −x3
+s4 = −7
x≥ 0
−10x1 −12x2 −15x3
= −z → max
And here is the first simplex tableau below:
B
u1
u2
u3
u4
−z

xB
−1
−3
−5
−7
0

a1
−1
−2
−1
−4
10

a2
0
−1
−2
−2
12

a3
−1
−3
0
−1
15

u4
1
0
0
0
0

u5
0
1
0
0
0

u3
0
0
1
0
0

u4
0
0
0
1
0

For the first sight we can realize that now the simplex tableau is different from the previous form.
In the last row there are only nonnegative values. We will call this property that the basis solution
is dual-feasible. But now the basis solution is not primal feasible, i.e. there are negative values
in the basis solution. In fact, all values are negative or zero since now this is the basis solution:
xB = (0, 0, 0, −1, −3, −5, −7). If we can reach that the tableau is both dual and primal feasible after
several transformations, this means that we will get the optimal tableau. Note that in the Primal
Simplex Method (in the second phase of it) we go through primal feasible solutions, while in the
Dual Simplex Method we go through dual feasible solutions.
Here is the rule of the transformation:
• We choose a row where the coordinate of the basis solution is negative (this vector of the basis
will leave the basis).
• From this row we will choose a negative pivot value.
• We apply an appropriate version of the minimum rule for choosing the entering column.
Let us suppose that the leaving vector is u1 , so we choose the pivot value from the first row.
We can choose the entering column from a1 , a2 and a3 as all other vectors are in the basis. The
appropriate values in this row and in these columns are −1, 0 and again −1. As we told, we would
choose a negative value, so we cannot choose the zero. Regarding the two other values we make the
following calculation min {10/1, 15/1}. Here the numerators come from the row of the objective,
171

8.4. THE GOMORY CUT

SOLUTION ALGORITHMS

and the denominators are the negatives of the previously listed two −1 values. Since 10/1 is smaller,
the appropriate value is chosen as pivot value, we denoted it by bold letter in the tableau. After the
transformation (where the rule is the same as in the transformation for the primal simplex method),
we get the following tableau:
B
a1
u2
u3
u4
−z

xB
1
−1
−4
−3
−10

a1
1
0
0
0
0

a2
0
−1
−2
−2
12

a3
1
−1
1
3
5

u4
−1
−2
−1
−4
10

u5
0
1
0
0
0

u3
0
0
1
0
0

u4
0
0
0
1
0

Now let us choose u3 as the leaving vector. There are only two negative values in its row that can
be considered as pivot value. The calculation is the following: min {12/2, 10/1}. Since the former
fraction is the smaller, −2 is chosen as the pivot value. After the transformation the next tableau
is the following:
B
a1
u2
a2
u4
−z

xB
1
1
2
1
−34

a1
1
0
0
0
0

a2
0
0
1
0
0

a3
1
−3/2
−1/2
2
11

u4
−1
−3/2
1/2
−3
4

u5
0
1
0
0
0

u3
0
−1/2
−1/2
−1
6

u4
0
0
0
1
0

Since we got a tableau with a solution that is both primal and dual feasible, this is an optimal
solution. Here xB = (1, 2, 0 |, 0, 1, 0, 1 ) and the (optimal) value of the objective is z = 34.

8.4

The Gomory Cut

The Gomory cut is a main tool for getting integer solutions for an LP. If we require that the variables
of an LP are in fact integer numbers, we call the model Integer Linear Program (ILP). In many
cases some of the variables are required as integers but the other are allowed to be real values, in
this case the program is called Mixed-Integer Linear Program (MILP).
Solving an integer (or mixed-integer) program is (usually) much harder. There are several tools
to handle the integrality of the variables, we show only one such method, which is commonly used.
We will show the method through an example. The example comes from a book of András Prékopa,
as it is mentioned in the manuscript of Tamás Szántai [35], page 28 (in Hungarian), and it is
also shown in the short (Hungarian) draft of Mihály Hujter [36]. We note that we perform the
calculations in a little bit different way, as we tried to make our calculations uniform (for the Primal
Simplex and Dual Simplex tableau).
Let us consider the next ILP:
2x1 +x2 ≥ 1
2x1 +5x2 ≥ 4
−x1 +x2 ≥ 0
−x1 −x2 ≥ −5
−x1 −2x2 ≥ −4
x ≥ 0, x1 , x2 are integers
5x1 +4x2 = z → min
Let us transform the inequalities to „ ≤” type, then form them to equations by introducing slack
variables. Also, let us transform the objective to „ max” form. We get the following.
172

8.4. THE GOMORY CUT

SOLUTION ALGORITHMS

−2x1 −x2 +s1
= −1
−2x1 −5x2
+s2
= −4
x1 −x2
+s3
=0
x1 +x2
+s4
=5
x1 +2x2
+s5 = 4
x≥ 0
−5x1 −4x2
= −z → max
Now let us create the usual simplex tableau:
B
u1
u2
u3
u4
u5
−z

xB
−1
−4
0
5
4
0

a1
−2
−2
1
1
1
5

a2
−1
−5
−1
1
2
4

u1
1
0
0
0
0
0

u2
0
1
0
0
0
0

u3
0
0
1
0
0
0

u4
0
0
0
1
0
0

u5
0
0
0
0
1
0

The tableau is dual feasible, but primal infeasible. Let us make basis transformations with the
Dual Simplex Method to reach the optimal solution. In fact, two steps will be enough. First u1
leaves the basis and a1 enters (according to the minimum rule), then u2 leaves the basis and a2
enters. The resulting tableau is as follows:
B
a1
a2
u3
u4
u5
−z

xB
1/8
3/4
5/8
33/8
19/8
−29/8

a1
1
0
0
0
0
0

a2
0
1
0
0
0
0

u1
−5/8
1/4
7/8
3/8
1/8
17/8

u2
1/8
−1/4
−3/8
1/8
3/8
3/8

u3
0
0
1
0
0
0

u4
0
0
0
1
0
0

u5
0
0
0
0
1
0

The given tableau is optimal. The optimal (fractional) solution is the following:
xB = (1/8, 3/4 |0, 0, 5/8, 33/8, 19/8 )
This is the optimal solution of the relaxed model, where x ≥ 0 is still required, but the integrality
of the variables is not required. The optimum value of the relaxed problem is z = 29/8.
At this point we will perform the famous Gomory Cut!
Let us choose a fractional variable, e.g. x1 = 1/8. Let us consider the row of this variable in the
tableau, as well. Here the meaning of the data (provided by the tableau) is the following:
1/8 = x1 − 5/8u1 + 1/8u2
We round up all coefficients in this equation. The values (to round up 1/8, 1, −5/8 and 1/8)
are the following: 7/8, 0, 5/8 and 7/8, respectively. With these values (using them one by one and
omitting the zero) we create the next (new) constraint:
7/8 ≤ 5/8u1 + 7/8u2
We can realize that this condition does not hold, since u1 = u2 = 0 in the current optimal
(fractional) basis solution. It means that adding this last constraint to the previously used constraints, the current basis solution becomes infeasible. Let us multiply the new constraint by −1
and introduce a new slack variable denoted by s6 , we get:
173

8.4. THE GOMORY CUT

SOLUTION ALGORITHMS

−5/8u1 − 7/8u2 + s6 = −7/8
We add this new equation to the system, and write it into a new line into the simplex tableau
as follows:
B
a1
a2
u3
u4
u5
u6
−z

xB
1/8
3/4
5/8
33/8
19/8
−7/8
−29/8

a1
1
0
0
0
0
0
0

a2
0
1
0
0
0
0
0

u1
−5/8
1/4
7/8
3/8
1/8
−5/8
17/8

u2
1/8
−1/4
−3/8
1/8
3/8
−7/8
3/8

u3
0
0
1
0
0
0
0

u4
0
0
0
1
0
0
0

u5
0
0
0
0
1
0
0

u6
0
0
0
0
0
1
0

Now the tableau is still dual feasible but not primal feasible. We choose the row of u6 for the
leaving vector. According to the minimum rule the pivot value is −7/8 (denoted by bold), since
3/7 < 17/5. After the transformation the next tableau is as follows:
B
a1
a2
u3
u4
u5
u2
−z

xB
0
1
1
4
2
1
−4

a1
1
0
0
0
0
0
0

a2
0
1
0
0
0
0
0

u1
−5/7
3/7
8/7
2/7
−1/7
5/7
13/7

u2
0
0
0
0
0
1
0

u3
0
0
1
0
0
0
0

u4
0
0
0
1
0
0
0

u5
0
0
0
0
1
0
0

u6
1/7
−2/7
−3/7
1/7
3/7
−8/7
3/7

We got an optimal tableau again (primal feasible and dual feasible, so it is optimal). But here
the optimal solutions are as follows: xB = (0, 1 |0, 1, 1, 4, 2 ). Since x1 = 0 and x2 = 1 are integer
values, this means that we got the optimal solution of the ILP, as well.

174


Chapter 9

Summary
Capabilities of the GNU MathProg modeling language was presented, on various problems. Linear
equation system solution, the production and the diet problem and their common extensions, the
transportation problem, various cost functions in general, and integer programming techniques
through common optimization problems were involved.
Mathematical programming in general offers a simple practical solution for the class of problems
it is adequate for. MILP models can be used for a much wider range of cases than their pure LP
counterparts. Nevertheless both problem classes are useful on their own.
Using our expertise in GNU MathProg gives us a unique tool for hard optimization problems.
The solution speed is not necessarily the best available for a particular problem, but ease of implementation, maintenance of code and adaptation to changes in the problem definition makes the
methodology valuable for both industrial and scientific purposes.
Usually, a single model file is developed, which addresses all problem instances implemented in
their own data files. The glpsol solver is capable of parsing the language and solving the model at
the same time, and user-defined output can also be obtained.
We also gave an insight into how LP models can be solved by the Simplex Method, and one
technique for integer programming problems, the Gomory cut. These are only an introduction to
how LP/MILP solver software work in the background. We are allowed to treat solvers as black
boxes, but basic knowledge about them can be useful for developing mathematical programming
models, improving them and better understanding their results.
Note that there are many approaches other than the main line shown in this Tutorial. We
mention a few as an ending.
• The language GNU MathProg and a parser/solver like glpsol can be used alone to develop
and solve models, but note that the GLPK software kit offers other features, notably a callable
library. Accessing linear programming tools from a programming language can be better in the
long term than using standalone GNU MathProg model files. For example, in GNU MathProg,
we cannot „change” the value of a parameter, which limits input data processing possibilities.
• Different configurations of the solver glpsol are only barely touched in this Tutorial. Application of the appropriate heuristics or alternative solution methods can speed up the search.
• The solver glpsol is an easy-to-use tool, but probably not the fastest LP/MILP solver. Other
free solvers may be superior if performance is an issue, for example CBC [7] or lpsolve [8].
Commercial MILP solvers can be even much better. We can use alternative solvers with GNU
MathProg models, as glpsol supports exporting a model into well-known formats.
• GNU MathProg is not the only language for linear programming. There are dozens of other
languages, each having an own class of models, input/output formats and solvers to support.
175

SUMMARY

• Not LP and MILP are the only mathematical programming problem classes having general
purpose solvers. If specific nonlinear objectives and constraints are needed to model a situation,
then we might try developing a Nonlinear or Mixed-Integer Nonlinear Programming (NLP or
MINLP) model in some adequate environment. Remember, more general tools can be much
more costly in terms of running time.
• Mathematical programming is a powerful tool, but some problems do have much more effective
algorithmic solutions. Sometimes developing an algorithm can yield better results, although
often for the cost of more coding.
• Throughout this Tutorial, we only solved models in a whole, resulting in a final answer. In
general, mathematical programming tools can be used as part of some algorithmic framework.
For example, a large problem can be decomposed into several different models that are solved
separately or one after the other. Or, an LP/MILP model can serve as a relaxation for a more
complex optimization problem, and as such, provide a bound for its objective.
We hope the reader will find this Tutorial helpful and motivating in solving real-life optimization
problems in the future.

