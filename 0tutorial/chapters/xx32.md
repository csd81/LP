---------------
Problem 46.
A set of nodes and distances between any two are given. Find the shortest cycle visiting all nodes.
The motivation behind TSP is that an agent must visit a set of targets in the least amount of
time or least distance travelled, then go back to the starting point. The route, if optimal, will be
a cycle. Note that a cycle visiting all nodes of a graph is also called a Hamiltonian cycle. The
starting node in TSP can be arbitrary, as the cycle visits all nodes anyway.
Comparing the TSP to the knapsack problem, although both are NP-hard in general, the knapsack tends to be solvable for much larger number of items than the number of nodes in a TSP.
In general, the distances can be different between two nodes depending on direction, but we
assume they are equal throughout this section.
For the sake of simplicity, we solve the TSP problem for nodes situated on the plane (see Figure
15), and an arbitrary starting point is also determined. The distances are Euclidean, e.g. the
ordinary definition of distance between two points on the plane.
 
Problem 47.
Find the shortest route starting and ending at the green node and visiting all red nodes depicted
in Figure 15.
For this particular problem, rather than calculating distance matrix, we implement a model which
accepts the planar positions of the nodes instead and calculates Euclidean distances accordingly.
For this reason, a new kind of data section formulation is introduced: the nodes and their
155

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

Figure 15: Set of nodes on the plane, for which TSP is to be solved. The green node is designated
as an arbitrary starting point for travelling.
positions are listed in a single set statement named as Node_List.
Another parameter Start is for the arbitrary starting node. Its role is similar to the arbitrary
sink node in the minimum weight spanning tree problem (see Section 7.4) – it could be avoided, but
makes implementation easier.
data;
set Node_List :=
P00 0 0
P08 0 8
P15 1 5
P22 2 2
P23 2 3
P28 2 8
P29 2 9
P31 3 1
P34 3 4
P40 4 0
P56 5 6
P60 6 0

156

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

P61 6 1
P69 6 9
P73 7 3
P90 9 0
P93 9 3
P94 9 4
P97 9 7
;
param Start := P23;
end;
Let us see how such a data format can be implemented in the model file. What we first need is
a three-dimensional set called Node_List. Note that here we must add dimen 3 to the definition
to indicate that each element of this set has three coordinates. These coordinates are the name of
the node, its X and Y coordinates in plane, respectively.
set Node_List, dimen 3;
set Nodes := setof {(name,x,y) in Node_List} name;
check card(Nodes)==card(Node_List);
param X {n in Nodes} := sum {(n,x,y) in Node_List} x;
param Y {n in Nodes} := sum {(n,x,y) in Node_List} y;
After this point, the set Nodes is derived from the list, by picking each name mentioned there.
Node names shall be unique in the data section. This can be asserted by a check statement telling
the Nodes set has the same size as Node_List. If there are duplicates, the Nodes set is smaller.
The numeric parameters X and Y denote the planar coordinates of the nodes. Technically, this
is obtained by a sum. Since each node name appears in the list exactly once, the sum will result
in selecting the corresponding coordinate of that particular node. The Node_List set is no longer
needed.
The arbitrary Start can be any node from the Nodes set.
param Start, symbolic, in Nodes;
The parameter W denoting the Euclidean distances are calculated based on the X and Y parameters. The formula of the Euclidean distance between two points P1 (x1 , y1 ) and P2 (x2 , y2 ) is the
following. The implementation in GNU MathProg uses the sqrt built-in function and the operator
ˆ for exponentiation.
q
2
2
P1 P2 = (x1 − x2 ) + (y1 − y2 )
(13)
param W {a in Nodes, b in Nodes} := sqrt((X[a]-X[b])^2+(Y[a]-Y[b])^2);
We have all the required data defined in the model, now the solution strategy and appropriate
decision variables must be determined.
First, observe that TSP is in close connection with the assignment problem (see Section 7.3).
For each node in the TSP, we must decide the next node in the cycle. Therefore the solution of the
TSP is an assignment from the set of nodes to itself.
The variable use for each arc, and the two constraints ensure that each node have exactly one
„next”, and one „previous” neighbor.
157

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

var use {a in Nodes, b in Nodes}, binary;
subject to Path_In {b in Nodes}:
sum {a in Nodes} use[a,b] = 1;
subject to Path_Out {a in Nodes}:
sum {b in Nodes} use[a,b] = 1;
Applying the logic of the shortest paths, we can start a trail and go into the direction of the
only selected arc outside, obtaining a sequence A0 A1 A2 . . . of nodes. For each i ≥ 1, the arc going
into Ai is Ai−1 Ai , and the arc going out is Ai Ai+1 . Therefore it is impossible for the sequence to
run from Ai into an already visited node Aj , 1 ≤ j < i, because Aj has only one arc going in, and
it is Aj−1 Aj , not Ai Aj . This means that the only way the trail can end is running into A0 and the
cycle closes. Ideally, we would obtain a single cycle of the nodes this way (see Figure 16).

Figure 16: Cycle containing all nodes, representing a feasible solution for TSP.
Unfortunately, this simple solution is not sufficient. The mistake in the above consideration is
that the cycle starting from and ending at the Start node does not necessarily include all nodes.
The assignment of nodes to other nodes can possibly form not a single Hamiltonian cycle, but two
or several smaller cycles (see Figure 17).
To prevent the case of more than one cycle, we must ensure connectivity of the graph. And this
is where the technique shown for the minimum weight spanning tree (see Section 7.4) is reused: a
single droplet is put at each node, and they shall flow through selected arcs into the Start node.
This is possible if and only if the assignment is a single cycle.
Note that the resulting graph is not a tree, but the new variable flow and the corresponding
constraints guarantee connectivity only, as they did for the minimum weight spanning tree problem.
var flow {a in Nodes, b in Nodes};
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;

158

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

Figure 17: Feasible assignment of nodes but infeasible for TSP.

subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then (1-card(Nodes)) else 1;
The objective is the total weight of the selected arcs.
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
We finished the model implementation. As we can see, the TSP model is just the „combination”
of the assignment problem and the minimum weight spanning tree problem. The optimization
procedure does not end up with a spanning tree, but a Hamiltonian cycle because of the assignment
rules. Note that because the assignment problem can be solved by an LP, the assignment problem
can be used as a relaxation of the TSP problem. Solution techniques for TSP may exploit this fact.
We can again print out the used edges one by one after the solve statement, likely not in their
correct order.
printf "Shortest Hamiltonian cycle: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
Solving example Problem 47 gives the following result.

159

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

Shortest Hamiltonian cycle: 44.5948
P00->P31 (3.16228)
P08->P15 (3.16228)
P15->P34 (2.23607)
P22->P00 (2.82843)
P23->P22 (1)
P28->P29 (1)
P29->P08 (2.23607)
P31->P40 (1.41421)
P34->P23 (1.41421)
P40->P60 (2)
P56->P28 (3.60555)
P60->P61 (1)
P61->P90 (3.16228)
P69->P56 (3.16228)
P73->P93 (2)
P90->P73 (3.60555)
P93->P94 (1)
P94->P97 (3)
P97->P69 (3.60555)
Note that although the number of nodes is only 19, it still takes some time to be solved. The
output of glpsol shows clearly how the solution was gradually improved to optimality.
Integer optimization begins...
Long-step dual simplex will be used
+
545: mip =
not found yet >=
+ 1859: >>>>>
5.969014627e+01 >=
+ 4111: >>>>>
4.777953551e+01 >=
+ 7223: >>>>>
4.576632755e+01 >=
+ 15676: >>>>>
4.459475467e+01 >=
+ 39752: mip =
4.459475467e+01 >=
+ 52815: mip =
4.459475467e+01 >=
INTEGER OPTIMAL SOLUTION FOUND
Time used:
9.4 secs
Memory used: 4.7 Mb (4954539 bytes)

-inf
2.300457897e+01
2.623268810e+01
2.722682823e+01
3.434024294e+01
4.136099600e+01
tree is empty

(1; 0)
61.5% (48; 1)
45.1% (75; 7)
40.5% (90; 32)
23.0% (154; 77)
7.3% (501; 612)
0.0% (0; 2407)

The optimal cycle length is 44.59. Our manual output tells everything about the solution, but
is difficult to interpret. Instead, a visualization is produced, this time by the model section itself.
We print out the solution in Scalable Vector Graphics (SVG) format [29].
SVG is a vector-graphical image representation format. Instead of storing pixels, the primitives
making up the image are described. The SVG relies on XML data format. Therefore, we only need
to print properly formatted XML containing the grid, the nodes and the found TSP solution. This
whole work goes after the solve statement.
Producing SVG with GNU MathProg has more spectacular demonstrations publicly available
[30], we basically use the cited approach here. The syntax of neither SVG nor XML is explained in
this Tutorial.
First, the particular TSP, Problem 47 uses X and Y coordinates from 0 to 9, therefore the image
would fit in a 500 × 500 image with a 50 pixels distance between grid lines, the edges being padded
by 25 pixels. In the SVG to be produced, we refer to x and y coordinates from the top left corner,
160

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

increasing right and down. First, we translate coordinates in the TSP problem into coordinates in
the SVG image as follows.
param PX {n in Nodes} := 25 + 50 * X[n];
param PY {n in Nodes} := 475 - 50 * Y[n];
We also define an SVGFILE parameter to contain the name of the SVG file to be produced. This
is solution.svg by default, but can be overridden in a data section.
param SVGFILE, symbolic, default "solution.svg";
We first print an empty string by printf. But this is not printed into the result of the glpsol,
but the file we specify, by adding >SVGFILE at the end of the printf statement. If we want to append
to the end of the file instead, we should write >>SVGFILE, similarly to redirection in command line.
printf "" >SVGFILE;
The first >SVGFILE erases the file if it was present, but all subsequent printf statements shall
end with >>SVGFILE to keep previously written content.
The SVG is an XML file, and a properly formatted header is needed.
printf "<?xml version=""1.0"" standalone=""no""?>\n" >>SVGFILE;
printf "<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" " >>SVGFILE;
printf """http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"">\n" >>SVGFILE;
Note that GNU MathProg does not allow too long symbolic names and character strings in code
(not more than 100 characters), therefore the work is separated into multiple printf statements.
Afterwards, XML tags will be inserted. The SVG content starts with the opening of an svg
tag, with the width and height of the image. Note that we have to use a lot of " characters in the
SVG code. These must be escaped as "" if we want to print such characters with printf in GNU
MathProg.
printf "<svg width=""500"" height=""500"" version=""1.0"" " >>SVGFILE;
printf "xmlns=""http://www.w3.org/2000/svg"">\n" >>SVGFILE;
First, a „canvas” is printed, which is a rectangle having the same size as the whole image,
providing a uniform pale yellow background. We can use the & operator in GNU MathProg to
concatenate strings together, to separate a single string into multiple lines.
printf "<rect x=""0"" y=""0"" width=""500"" height=""500"" " &
"stroke=""none"" fill=""rgb(255,255,208)""/>\n" >>SVGFILE;
First, the grid is drawn, consisting of 10 vertical and 10 horizontal, narrow black lines at appropriate positions.
for {i in 0..9}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25+50*i, 475, 25+50*i, 25 >>SVGFILE;
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",

161

7.5. TRAVELLING SALESMAN PROBLEM

}

MILP MODELS

25, 25+50*i, 475, 25+50*i >>SVGFILE;

Next, the TSP solution is drawn. A wide, blue line segment is put between each pair of nodes
that appear in the optimal cycle. The direction is not represented, it does not matter anyways.
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""blue"" stroke-width=""3""/>\n",
PX[a], PY[a], PX[b], PY[b] >>SVGFILE;
}
Finally, the nodes are printed upon the grid and the blue cycle. All nodes apart from Start are
printed as small black circles with red fill.
for {n in Nodes: n!=Start}
{
printf "<circle cx=""%g"" cy=""%g"" r=""%g"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""red""/>\n",
PX[n], PY[n], 8 >>SVGFILE;
}
The Start node is a small black rectangle with green fill.
printf "<rect x=""%g"" y=""%g"" width=""16"" height=""16"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""green""/>\n",
PX[Start]-8, PY[Start]-8 >>SVGFILE;
Note that the mentioned order of elements to be printed is important, as it determines how they
cover each other in the result. Finally, the svg tag is closed.
printf "</svg>\n" >>SVGFILE;
By running glpsol to solve TSP, Problem 47, we do not only get the textual output, but the
SVG image file which shows the drawing (see Figure 18).
Note that the TSP problem has more effective implementations than the one shown here, and
even this one could be improved significantly to find solutions faster for larger TSP problem instances. The focus was on the relation to the assignment problem and the connectivity constraints.
Here we show the full model section, note that the MILP model logic almost as large as the code
responsible for the textual and SVG output.
set Node_List, dimen 3;
set Nodes := setof {(name,x,y) in Node_List} name;
check card(Nodes)==card(Node_List);
param X {n in Nodes} := sum {(n,x,y) in Node_List} x;
param Y {n in Nodes} := sum {(n,x,y) in Node_List} y;
param Start, symbolic, in Nodes;
param W {a in Nodes, b in Nodes} := sqrt((X[a]-X[b])^2+(Y[a]-Y[b])^2);

162

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

Figure 18: Optimal solution of TSP,  
Problem 47.

var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};
subject to Path_In {b in Nodes}:
sum {a in Nodes} use[a,b] = 1;
subject to Path_Out {a in Nodes}:
sum {b in Nodes} use[a,b] = 1;
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then (1-card(Nodes)) else 1;
minimize Total_Weight:

163

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
solve;
printf "Shortest Hamiltonian cycle: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
param PX {n in Nodes} := 25 + 50 * X[n];
param PY {n in Nodes} := 475 - 50 * Y[n];
param SVGFILE, symbolic, default "solution.svg";
printf "" >SVGFILE;
printf "<?xml version=""1.0"" standalone=""no""?>\n" >>SVGFILE;
printf "<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" " >>SVGFILE;
printf """http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"">\n" >>SVGFILE;
printf "<svg width=""500"" height=""500"" version=""1.0"" " >>SVGFILE;
printf "xmlns=""http://www.w3.org/2000/svg"">\n" >>SVGFILE;
printf "<rect x=""0"" y=""0"" width=""500"" height=""500"" " &
"stroke=""none"" fill=""rgb(255,255,208)""/>\n" >>SVGFILE;
for {i in 0..9}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25+50*i, 475, 25+50*i, 25 >>SVGFILE;
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25, 25+50*i, 475, 25+50*i >>SVGFILE;
}
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""blue"" stroke-width=""3""/>\n",
PX[a], PY[a], PX[b], PY[b] >>SVGFILE;
}
for {n in Nodes: n!=Start}
{
printf "<circle cx=""%g"" cy=""%g"" r=""%g"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""red""/>\n",
PX[n], PY[n], 8 >>SVGFILE;
}
printf "<rect x=""%g"" y=""%g"" width=""16"" height=""16"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""green""/>\n",

164

7.6. MILP MODELS – SUMMARY

MILP MODELS

PX[Start]-8, PY[Start]-8 >>SVGFILE;
printf "</svg>\n" >>SVGFILE;
end;

7.6

MILP models – Summary

Several optimization problems where shown where MILP models are an adequate solution technique,
while further capabilities of the GNU MathProg language were demonstrated.
• The knapsack and the multi-way number partitioning problem are easy examples for models
involving discrete decisions and requiring integer variables.
• Tiling can also be addressed by MILP approaches, provided that our choices on tile placement
are finite. This was shown on the tiling of an arbitrary rectangle with cross-shaped tiles. Some
set and param definitions allowed a more concise model formulation.
• The assignment problem is a well-known optimization problem, and was implemented as an
MILP model, turned out to be not more difficult than its LP relaxation. The functionality of
making a priori decisions for a model was demonstrated on the assignment problem.
• Some problems on weighted graphs were also addressed. The shortest path problem and the
minimum weight spanning tree problem were both formulated as an MILP model, with similar
techniques. The idea was the management of imaginary material flows through the edges of
the graph.
• Finally, the travelling salesman problem was solved as a combination of the assignment problem
and the connectivity constraints from the minimum weight spanning tree problem. Visual
output was also produced by the GNU MathProg code itself, in SVG format.
The examples shown here included some of the most common linear programming techniques
and their possible implementations. These can be part of more complex real-world optimization
problems. Integer programming techniques make a much wider range of problems to be solvable
than pure LP models, but at a price of exploding computational complexity.

165
