

## Problem 46.

Given a set of **nodes** and the **distances** between every two of them, find the **shortest cycle** that **visits all nodes**.

The goal of the **Traveling Salesperson Problem (TSP)** is to find the route an agent must take to visit a set of targets in the **least amount of time** or by traveling the **least distance**, and then return to the **starting point**. The most optimal route will be a cycle. Note that a cycle that visits all nodes of a graph is also called a **Hamiltonian cycle**. The starting node in TSP can be **arbitrary** since the cycle visits all nodes regardless.

Comparing TSP to the **knapsack problem**, while both are **NP-hard** in general, the knapsack problem tends to be solvable for a much larger number of items than the number of nodes in a TSP.

In general, the distances between two nodes can be different depending on the direction of travel, but we will assume they are **equal** throughout this section.

For simplicity, we will solve the TSP problem for nodes situated on a **plane** (see Figure 15), and an **arbitrary starting point** is also determined. The distances used are **Euclidean**, which is the ordinary definition of the distance between two points on a plane.

-----

## Problem 47.

Find the **shortest route** starting and ending at the **green node** and visiting all **red nodes** depicted in Figure 15.

For this specific problem, instead of calculating a **distance matrix**, we'll implement a model that accepts the **planar positions** of the nodes and calculates the **Euclidean distances** accordingly. Because of this, a new type of data section formulation is introduced: the nodes and their positions are listed in a single set statement named **Node\_List**.

Another parameter, **Start**, is for the arbitrary starting node. Its role is similar to the arbitrary sink node in the minimum weight spanning tree problem (see Section 7.4)—it could be avoided, but it makes the implementation easier.

```
data;
set Node_List :=
P00 0 0
P08 0 8
P15 1 5
P22 2 2
P23 2 3
P28 2 8
P29 2 9
P31 3 1
P34 3 4
P40 4 0
P56 5 6
P60 6 0
P61 6 1
P69 6 9
P73 7 3
P90 9 0
P93 9 3
P94 9 4
P97 9 7
;
param Start := P23;
end;
```

Let's see how such a data format can be implemented in the model file. First, we need a **three-dimensional set** called **Node\_List**. Note that here we must add `dime n 3` to the definition to indicate that each element of this set has three coordinates: the name of the node, its **X** coordinate, and its **Y** coordinate in the plane, respectively.

```
set Node_List, dimen 3;
set Nodes := setof {(name,x,y) in Node_List} name;
check card(Nodes)==card(Node_List);
param X {n in Nodes} := sum {(n,x,y) in Node_List} x;
param Y {n in Nodes} := sum {(n,x,y) in Node_List} y;
```

After this, the set **Nodes** is **derived** from the list by picking each name mentioned there. Node names must be **unique** in the data section. This can be asserted by a **check statement** confirming that the **Nodes** set has the same size as **Node\_List**. If there are duplicates, the **Nodes** set will be smaller.

The numeric parameters **X** and **Y** denote the planar coordinates of the nodes. Technically, this is obtained by a `sum`. Since each node name appears in the list exactly once, the sum will result in selecting the corresponding coordinate of that particular node. The **Node\_List** set is no longer needed.

The arbitrary **Start** can be any node from the **Nodes** set.

```
param Start, symbolic, in Nodes;
```

The parameter **W** denoting the **Euclidean distances** is calculated based on the **X** and **Y** parameters. The formula for the Euclidean distance between two points $P_1 (x_1 , y_1 )$ and $P_2 (x_2 , y_2 )$ is the following. The implementation in GNU MathProg uses the `sqrt` built-in function and the operator `^` for exponentiation.

$$P_1 P_2 = \sqrt{(x_1 - x_2 )^2 + (y_1 - y_2 )^2}$$

```
param W {a in Nodes, b in Nodes} := sqrt((X[a]-X[b])^2+(Y[a]-Y[b])^2);
```

We now have all the required data defined in the model. Next, the solution strategy and appropriate decision variables must be determined.

First, observe that **TSP** is closely related to the **assignment problem** (see Section 7.3). For each node in the TSP, we must decide the **next node** in the cycle. Therefore, the solution of the TSP is an assignment from the set of nodes to itself.

The **variable `use`** for each arc and the two constraints ensure that each node has exactly one "next" and one "previous" neighbor.

```
var use {a in Nodes, b in Nodes}, binary;
subject to Path_In {b in Nodes}:
sum {a in Nodes} use[a,b] = 1;
subject to Path_Out {a in Nodes}:
sum {b in Nodes} use[a,b] = 1;
```

Applying the logic of **shortest paths**, we can start a trail and follow the direction of the only selected outgoing arc, obtaining a sequence $A_0 A_1 A_2 . . .$ of nodes. For each $i \geq 1$, the arc going *into* $A_i$ is $A_{i-1} A_i$, and the arc going *out* is $A_i A_{i+1}$. Therefore, it's impossible for the sequence to run from $A_i$ into an already visited node $A_j$, $1 \leq j < i$, because $A_j$ only has one incoming arc, $A_{j-1} A_j$, not $A_i A_j$. This means the only way the trail can end is by running into $A_0$ and closing the cycle. Ideally, we would obtain a **single cycle** of all the nodes this way (see Figure 16).

Unfortunately, this simple solution is **not sufficient**. The mistake in the above reasoning is that the cycle starting from and ending at the **Start** node does **not necessarily include all nodes**. The assignment of nodes to other nodes could potentially form not a single Hamiltonian cycle, but **two or several smaller cycles** (see Figure 17).

To prevent the case of **more than one cycle**, we must ensure **connectivity** of the graph. This is where the technique shown for the **minimum weight spanning tree** (see Section 7.4) is reused: a single "droplet" is placed at each node, and these must **flow** through the selected arcs into the **Start** node. This is possible if and only if the assignment is a **single cycle**.

Note that the resulting graph is not a tree, but the new **variable `flow`** and the corresponding constraints only guarantee **connectivity**, just as they did for the minimum weight spanning tree problem.

```
var flow {a in Nodes, b in Nodes};
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;

subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then (1-card(Nodes)) else 1;
```

The objective is the **total weight** of the selected arcs.

```
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
```

We have finished the model implementation. As we can see, the **TSP model** is simply a **"combination"** of the assignment problem and the minimum weight spanning tree problem. The optimization procedure does not result in a spanning tree, but a **Hamiltonian cycle** because of the assignment rules. Note that because the assignment problem can be solved by a **Linear Program (LP)**, the assignment problem can be used as a **relaxation** of the TSP problem. Solution techniques for TSP can exploit this fact.

We can once again print out the used edges one by one after the `solve` statement, though likely not in their correct order.

```
printf "Shortest Hamiltonian cycle: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
```

Solving example **Problem 47** yields the following result.

```
Shortest Hamiltonian cycle: 44.5948
P00->P31 (3.16228)
P08->P15 (3.16228)
P15->P34 (2.23607)
P22->P00 (2.82843)
P23->P22 (1)
P28->P29 (1)
P29->P08 (2.23607)
P31->P40 (1.41421)
P34->P23 (1.41421)
P40->P60 (2)
P56->P28 (3.60555)
P60->P61 (1)
P61->P90 (3.16228)
P69->P56 (3.16228)
P73->P93 (2)
P90->P73 (3.60555)
P93->P94 (1)
P94->P97 (3)
P97->P69 (3.60555)
```

Note that although there are only **19 nodes**, it still takes some time to solve. The output of `glpsol` clearly shows how the solution was **gradually improved** to optimality.

```
Integer optimization begins...
Long-step dual simplex will be used
+
545: mip =
not found yet >=
+ 1859: >>>>>
5.969014627e+01 >=
+ 4111: >>>>>
4.777953551e+01 >=
+ 7223: >>>>>
4.576632755e+01 >=
+ 15676: >>>>>
4.459475467e+01 >=
+ 39752: mip =
4.459475467e+01 >=
+ 52815: mip =
4.459475467e+01 >=
INTEGER OPTIMAL SOLUTION FOUND
Time used:
9.4 secs
Memory used: 4.7 Mb (4954539 bytes)
```

```
-inf
2.300457897e+01
2.623268810e+01
2.722682823e+01
3.434024294e+01
4.136099600e+01
tree is empty
```

```
(1; 0)
61.5% (48; 1)
45.1% (75; 7)
40.5% (90; 32)
23.0% (154; 77)
7.3% (501; 612)
0.0% (0; 2407)
```

The optimal cycle length is **44.59**. Our manual output provides all the details about the solution but is **difficult to interpret**. Instead, a **visualization** is produced, this time by the model section itself. We will print the solution in **Scalable Vector Graphics (SVG) format** [29].

SVG is a **vector-graphical image representation format**. Instead of storing pixels, the **primitives** that make up the image are described. SVG relies on the **XML data format**. Therefore, we only need to print properly formatted XML containing the grid, the nodes, and the found TSP solution. This entire process happens **after the `solve` statement**.

Producing SVG with GNU MathProg has more spectacular public demonstrations available [30]. We are essentially using the cited approach here. The syntax of neither SVG nor XML will be explained in this Tutorial.

First, for this particular TSP, **Problem 47**, the $\mathbf{X}$ and $\mathbf{Y}$ coordinates range from $\mathbf{0}$ to $\mathbf{9}$. Therefore, the image would fit in a **500 x 500 image** with a **50-pixel distance** between grid lines, and the edges are padded by **25 pixels**. In the SVG to be produced, we reference **x** and **y** coordinates from the **top left corner**, increasing to the right and down. First, we **translate coordinates** in the TSP problem into coordinates in the SVG image as follows.

```
param PX {n in Nodes} := 25 + 50 * X[n];
param PY {n in Nodes} := 475 - 50 * Y[n];
```

We also define an **SVGFILE parameter** to contain the name of the SVG file to be produced. This defaults to `solution.svg` but can be overridden in a data section.

```
param SVGFILE, symbolic, default "solution.svg";
```

We first print an **empty string** using `printf`. However, this is not printed to the `glpsol` result but to the file we specify by adding `>SVGFILE` at the end of the `printf` statement. If we want to **append** to the end of the file instead, we should write `>>SVGFILE`, similar to redirection in the command line.

```
printf "" >SVGFILE;
```

The first `>SVGFILE` **erases the file** if it was present, but all subsequent `printf` statements must end with `>>SVGFILE` to keep the content written previously.

SVG is an XML file, and a properly formatted **header** is needed.

```
printf "<?xml version=""1.0"" standalone=""no""?>\n" >>SVGFILE;
printf "<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" " >>SVGFILE;
printf """http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"">\n" >>SVGFILE;
```

Note that GNU MathProg does not allow overly long symbolic names and character strings in code (not more than 100 characters); therefore, the work is separated into multiple `printf` statements.

Afterward, **XML tags** will be inserted. The SVG content starts with the opening of an **svg tag**, including the **width and height** of the image. Note that we have to use many `"` characters in the SVG code. These must be **escaped** as `""` if we want to print such characters with `printf` in GNU MathProg.

```
printf "<svg width=""500"" height=""500"" version=""1.0"" " >>SVGFILE;
printf "xmlns=""http://www.w3.org/2000/svg"">\n" >>SVGFILE;
```

First, a **"canvas"** is printed, which is a rectangle the same size as the entire image, providing a **uniform pale yellow background**. We can use the `&` operator in GNU MathProg to **concatenate strings** together, separating a single string into multiple lines.

```
printf "<rect x=""0"" y=""0"" width=""500"" height=""500"" " &
"stroke=""none"" fill=""rgb(255,255,208)""/>\n" >>SVGFILE;
```

First, the **grid is drawn**, consisting of **10 vertical** and **10 horizontal**, narrow black lines at the appropriate positions.

```
for {i in 0..9}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25+50*i, 475, 25+50*i, 25 >>SVGFILE;
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25, 25+50*i, 475, 25+50*i >>SVGFILE;
}
```

Next, the **TSP solution is drawn**. A **wide, blue line segment** is placed between each pair of nodes that appear in the optimal cycle. The direction is not represented, as it does not matter anyway.

```
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""blue"" stroke-width=""3""/>\n",
PX[a], PY[a], PX[b], PY[b] >>SVGFILE;
}
```

Finally, the **nodes are printed** on top of the grid and the blue cycle. All nodes except **Start** are printed as **small black circles with red fill**.

```
for {n in Nodes: n!=Start}
{
printf "<circle cx=""%g"" cy=""%g"" r=""%g"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""red""/>\n",
PX[n], PY[n], 8 >>SVGFILE;
}
```

The **Start** node is a **small black rectangle with green fill**.

```
printf "<rect x=""%g"" y=""%g"" width=""16"" height=""16"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""green""/>\n",
PX[Start]-8, PY[Start]-8 >>SVGFILE;
```

Note that the **order of elements** to be printed is **important**, as it determines how they cover each other in the result. Finally, the **svg tag is closed**.

```
printf "</svg>\n" >>SVGFILE;
```

By running `glpsol` to solve TSP, **Problem 47**, we get not only the textual output but also the **SVG image file**, which shows the drawing (see Figure 18).

Note that the TSP problem has **more effective implementations** than the one shown here, and even this one could be significantly improved to find solutions faster for larger TSP problem instances. The focus here was on the **relation to the assignment problem** and the **connectivity constraints**.

Here, we show the **full model section**. Note that the **MILP model logic** is almost as large as the code responsible for the textual and SVG output.

```
set Node_List, dimen 3;
set Nodes := setof {(name,x,y) in Node_List} name;
check card(Nodes)==card(Node_List);
param X {n in Nodes} := sum {(n,x,y) in Node_List} x;
param Y {n in Nodes} := sum {(n,x,y) in Node_List} y;
param Start, symbolic, in Nodes;
param W {a in Nodes, b in Nodes} := sqrt((X[a]-X[b])^2+(Y[a]-Y[b])^2);
var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};
subject to Path_In {b in Nodes}:
sum {a in Nodes} use[a,b] = 1;
subject to Path_Out {a in Nodes}:
sum {b in Nodes} use[a,b] = 1;
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then (1-card(Nodes)) else 1;
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
solve;
printf "Shortest Hamiltonian cycle: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
param PX {n in Nodes} := 25 + 50 * X[n];
param PY {n in Nodes} := 475 - 50 * Y[n];
param SVGFILE, symbolic, default "solution.svg";
printf "" >SVGFILE;
printf "<?xml version=""1.0"" standalone=""no""?>\n" >>SVGFILE;
printf "<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" " >>SVGFILE;
printf """http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"">\n" >>SVGFILE;
printf "<svg width=""500"" height=""500"" version=""1.0"" " >>SVGFILE;
printf "xmlns=""http://www.w3.org/2000/svg"">\n" >>SVGFILE;
printf "<rect x=""0"" y=""0"" width=""500"" height=""500"" " &
"stroke=""none"" fill=""rgb(255,255,208)""/>\n" >>SVGFILE;
for {i in 0..9}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25+50*i, 475, 25+50*i, 25 >>SVGFILE;
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""black"" stroke-width=""1""/>\n",
25, 25+50*i, 475, 25+50*i >>SVGFILE;
}
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "<line x1=""%g"" y1=""%g"" x2=""%g"" y2=""%g"" " &
"stroke=""blue"" stroke-width=""3""/>\n",
PX[a], PY[a], PX[b], PY[b] >>SVGFILE;
}
for {n in Nodes: n!=Start}
{
printf "<circle cx=""%g"" cy=""%g"" r=""%g"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""red""/>\n",
PX[n], PY[n], 8 >>SVGFILE;
}
printf "<rect x=""%g"" y=""%g"" width=""16"" height=""16"" " &
"stroke=""black"" stroke-width=""1.5"" fill=""green""/>\n",
PX[Start]-8, PY[Start]-8 >>SVGFILE;
printf "</svg>\n" >>SVGFILE;
end;
```

-----

## 7.6 MILP Models – Summary

Several optimization problems were presented where **Mixed-Integer Linear Programming (MILP)** models are an appropriate solution technique, while further capabilities of the GNU MathProg language were demonstrated.

  * The **knapsack problem** and the **multi-way number partitioning problem** are easy examples of models involving **discrete decisions** and requiring **integer variables**.
  * **Tiling** can also be addressed by MILP approaches, provided that our choices for tile placement are finite. This was demonstrated on the tiling of an arbitrary rectangle with cross-shaped tiles. Specific **set and parameter definitions** allowed for a more concise model formulation.
  * The **assignment problem** is a well-known optimization problem and was implemented as an MILP model, turning out to be no more difficult than its **Linear Program (LP) relaxation**. The functionality of making **a priori decisions** for a model was demonstrated with the assignment problem.
  * Some problems on **weighted graphs** were also addressed. The **shortest path problem** and the **minimum weight spanning tree problem** were both formulated as an MILP model using similar techniques. The core idea was the **management of imaginary material flows** through the edges of the graph.
  * Finally, the **Traveling Salesperson Problem** was solved as a combination of the **assignment problem** and the **connectivity constraints** from the minimum weight spanning tree problem. **Visual output** was also produced by the GNU MathProg code itself, in **SVG format**.

The examples shown here included some of the most common **linear programming techniques** and their possible implementations. These can be part of more complex, real-world optimization problems. **Integer programming techniques** make a much wider range of problems solvable than pure LP models, but at the cost of **exploding computational complexity**.


