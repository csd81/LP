

## Problem 15.

Given a set of **food types** and a set of **nutrients**. Each food consists of a given, fixed ratio of the nutrients.

We aim to arrange a **diet**, which is any combination of the set of food types, in any amounts. However, for each nutrient, there is a **minimum requirement** that the diet must satisfy in order to be healthy. Also, each food has its own proportional **cost**.

**Find the healthy diet with the lowest total cost of food involved.**

After the general problem definition, let's look at a specific example.

-----

### Problem 16.

Solve the diet problem with the following data. There are five food types, named **F1 to F5**, and four nutrients under focus, named **N1 to N4**. The contents of a unit amount of each food, the unit cost of each food, and the minimum requirement of each nutrient are shown in the following table.

| | **N1** | **N2** | **N3** | **N4** | **Cost (per unit)** |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **F1** | 30 | 5.2 | 0.2 | 0.0001 | **450** |
| **F2** | 20 | 0 | 0.7 | 0.0001 | **220** |
| **F3** | 25 | 2 | 0.1 | 0.0001 | **675** |
| **F4** | 13 | 3.6 | 0 | 0.0002 | **120** |
| **F5** | 19 | 0.1 | 0 | 0.0009 | **500** |
| **Required** | **2000** | **180** | **30** | **0.04** | |

The diet problem is regarded as one of the first problems that led to the field of **Operations Research**.

Note that the underlying dimensions are slightly different in the diet problem and the production problem. Here we have omitted fictional physical dimensions, but the scale of each nutrient suggests which data belong to a single dimension. In this data table, each column corresponds to a single nutrient and, therefore, has its own unit of measure. The last column shows unit costs.

Usually, when implementing a model, the first things we must decide are: how our **freedom of choice** will be implemented as **decision variables**, how the **search space** can be described by **constraints**, and how the **objective** can be calculated. These steps are essential for deciding whether a mathematical programming approach is even suitable for a real-world problem.

However, we will instead start by defining all the data available in the problem and then proceed with the steps above. This makes defining the variables, constraints, and objectives easier afterward. So, the first part of modeling in GNU MathProg is now defining the **sets and parameters**. These are either calculated on the spot or provided later in a data section at the end of the model file or in separate data file(s).

Two sets appear in the problem: one for **food types** and one for **nutrients**. These sets will be used in indexing expressions.

```
set FoodTypes;
set Nutrients;
```

There are three parameters available. One is for denoting **food costs**, obviously defined for each food type. One parameter is for denoting the **minimum required amount of nutrients**, defined for each nutrient. Finally, one parameter is for the **contents of food**, which can be given by a unit amount for each pair of food type and nutrient. In the particular problem, for example, each unit of F2 contains 20 units of N1, 0.7 units of N3, and 0.0001 units of N4. The default values are all set to zero, and all these parameters are nonnegative by nature.

```
param Food_Cost {f in FoodTypes}, >=0, default 0;
param Content {f in FoodTypes, n in Nutrients}, >=0, default 0;
param Requirement {n in Nutrients}, >=0, default 0;
```

Now that all the data are defined as sets and variables, we must identify our freedom of choice. The **amounts of each food used** are clearly under our decision. If we know these amounts, we can easily calculate the total cost and nutrient contents, so we can determine whether the diet is healthy and, if so, how much it costs. This means we should define a variable denoting **food consumption** for each food type separately, and no more variables are needed in the model.

We introduce a variable named `eaten` to denote the amount of each food included in the diet. This variable is obviously nonnegative and is indexed over the set of food types. We also introduce the auxiliary variable `total_costs` so that it can be printed out more easily. We could define bounds for the auxiliary variable, but it is unnecessary as its value will be exactly calculated by a constraint.

```
var eaten {f in FoodTypes}, >=0;
var total_costs;
```

There is one significant factor in our model that restricts which diets are acceptable: the **total nutritional content**. This translates into a constraint for each nutrient. The total amount contained in the selected diet must be summed up, and this total must be **no less than** the minimal requirement for that particular nutrient.

Additionally, there is another constraint for calculating the auxiliary variable denoting the total food costs.

```
s.t. Nutrient_Requirements {n in Nutrients}:
sum {f in FoodTypes} Content[f,n] * eaten[f] >= Requirement[n];
s.t. Total_Costs_Calc: total_costs =
sum {f in FoodTypes} Food_Cost[f] * eaten[f];
```

With the auxiliary `total_costs` variable, defining the objective is straightforward.

```
minimize Total_Costs: total_costs;
```

After the `solve` statement, we can again write our own printing code that will show the solution found by the solver. This time, the amount of each food in the diet is shown, as well as the total consumption per nutrient, along with the lower limit. Our model section is now ready.

```
set FoodTypes;
set Nutrients;
param Food_Cost {f in FoodTypes}, >=0, default 0;
param Content {f in FoodTypes, n in Nutrients}, >=0, default 0;
param Requirement {n in Nutrients}, >=0, default 0;
var eaten {f in FoodTypes}, >=0;
var total_costs;
s.t. Nutrient_Requirements {n in Nutrients}:
sum {f in FoodTypes} Content[f,n] * eaten[f] >= Requirement[n];
s.t. Total_Costs_Calc: total_costs =
sum {f in FoodTypes} Food_Cost[f] * eaten[f];
minimize Total_Costs: total_costs;
solve;
printf "Total Costs: %g\n", total_costs;
param Nutrient_Intake {n in Nutrients} :=
sum {f in FoodTypes} Content[f,n] * eaten[f];
for {f in FoodTypes}
{
printf "Eaten of %s: %g\n", f, eaten[f];
}
for {n in Nutrients}
{
printf "Requirement %g of nutrient %s done with %g\n",
Requirement[n], n, Nutrient_Intake[n];
}
end;
```

Now we also implement the particular problem mentioned. It is described in a single data section as follows.

```
data;
set FoodTypes := F1 F2 F3 F4 F5;
set Nutrients := N1 N2 N3 N4;
param Food_Cost :=
F1 450
F2 220
F3 675
F4 120
F5 500
;
param Content:
N1
N2
N3
N4 :=
F1
30 5.2
0.2 0.0001
F2
20
.
0.7 0.0001
F3
25
2
0.1 0.0001
F4
13 3.6
.
0.0002
F5
19 0.1
.
0.0009
;
param Requirement :=
N1 2000
N2 180
N3 30
N4 0.04
;
end;
```

Now we can solve the problem, and the result is the following.

```
Total Costs: 29707.2
Eaten of F1: 0
Eaten of F2: 42.8571
Eaten of F3: 0
Eaten of F4: 49.2014
Eaten of F5: 28.7489
Requirement 2000 of nutrient N1 done with 2042.99
Requirement 180 of nutrient N2 done with 180
Requirement 30 of nutrient N3 done with 30
Requirement 0.04 of nutrient N4 done with 0.04
```

The optimal objective is **$29,707.2**. This result literally means that any diet containing at least 2,000 units of N1, 180 units of N2, 30 units of N3, and 0.04 units of N4, and consisting of F1 through F5, would cost at least **$29,707.2**, and there exists a solution to obtain exactly this number.

The optimal solution only uses **F2, F4, and F5**. This means that if F1 and F3 were omitted from the problem data altogether, the optimal solution would be exactly the same. This is because introducing a new food type only **increases the freedom** in the model, leaving any previously feasible solutions as feasible afterward, and potentially introducing new feasible solutions that utilize the newly introduced food type. We can also observe that **N1 is the only nutrient** for which the consumption in the optimal diet is **more than** the minimal amount required, with 2,042.99 units rather than 2,000. For the other three nutrients, there is exactly enough. This suggests that the solution shows a diet that is **balanced to the edge** to meet the minimum requirements while optimizing costs.

-----

### 5.6 Arbitrary Recipes

The implementation of the **diet problem** and the **production problem** are surprisingly similar. This is true for the number of sets, parameters, variables, constraints, the content of the constraints, and the objective. In this section, we will show how the diet problem can be viewed as a production problem. Finally, we will show a production problem with **arbitrary recipes** that generalizes both problems at the same time.

There are two ways a diet problem can be represented as a production problem.

1.  **Products are Food Types, Raw Materials are Nutrients.** This can be logical in reality as well. Food can be treated as if it were "**produced**" from its nutrients, in given ratios. In the diet, we eat the products and decompose them into their nutrients, so the process is just reversed in time. The products have costs, like foods, and the amounts exactly define the solution. The only difference is that instead of "storage" amounts for raw materials, which serve as an **upper bound** for usage, we have a **lower bound** because each nutrient must be consumed in a minimal total amount to obtain a good diet. But this feature is already implemented in the limits extension, in Problem 10. Another issue is that in this case, food "production" should be **minimized** instead of maximized, but that can be easily achieved if food costs are represented by **negative revenues** in the model. So, technically, we would have no difficulty rewriting our diet problem into a production problem with limits and negative unit revenues. This works if we consider the **food type as the products** and the **nutrients as the raw materials**.

2.  **Products are Nutrients, Raw Materials are Food Types.** This matches the process in time: the foods are the "**inputs**" that are available first, and then the products are the nutrients that we want to obtain through the whole process. There are more differences in this representation, which may make it seem unnatural. There are no upper or lower limits for foods, but there is a lower limit for nutrients, which means there would be a minimum production amount for each product in the production problem. There are no costs for the nutrients, but for the foods, which means that in the production problem there would be only costs for the raw materials but **zero revenues** for all products.

However, the most important difference, which actually prevents us from utilizing the production problem model directly in this second representation, is that the **logic of production is reversed**. That is, in the production problem, there are **many raw materials producing a single product** in given ratios. However, in the case of the diet problem, there would be a **single raw material (food) producing many products** in given ratios.

So, at this point, we could say that the second representation is flawed, and we should therefore use only the first one. Technically, nothing prevents us from doing that. However, the second representation suggests a valuable generalization for the production problem itself: **What if we relax the rule that there is only a single product in each production step?** This leads to the **production problem with arbitrary recipes**.

A **recipe** describes a process that consumes several **inputs** at once and produces several **outputs** at once, in given amounts. Each recipe can be utilized in an arbitrary volume, and both inputs and outputs are proportionally sized according to this volume.

We can see that this concept of recipes can describe both the production problem and the diet problem:

  * In the **production problem**, there is one recipe for each product. That recipe only produces that particular product as **output** but can consume any given combination of raw materials as **inputs**.
  * In the **diet problem**, there is one recipe for each food type. That recipe consumes only that particular food type as an **input** but can produce any given combination of nutrients as **outputs**.
  * Moreover, there may be other problems where there are **many inputs and many outputs** at the same time in a single recipe. These are covered by neither the production nor the diet problem alone.

Now we can define the production problem with arbitrary recipes as follows.

-----


