

## Problem 19

Solve **Problem 17**, the production problem with arbitrary recipes, where production proceeds as usual, but now includes **orders** that we may acquire. Orders are **optional** but must be acquired (and subsequently fulfilled) **completely**, not partially. Each order has the following characteristics:

  * **Fixed Material and Product Amounts:** If a raw material is included in an order, acquiring the order means we **obtain** that raw material in the specified amount *before* production. If a product is included in an order, acquiring it means we must **deliver** that product in the specified amount *after* it is produced.
  * **Order Price (Cash Flow):** This can be a cash **gain (revenue)** or a **payment (cost)**. The payment occurs either **before** or **after** production takes place.
  * **Maximum Count:** An order can be acquired and fulfilled multiple times, up to a specified upper limit.

Raw materials must either be purchased from the market, as before, or obtained by acquiring an order. Any **leftover** raw materials after production are **lost** without compensation.

Products must either be sold on the market or delivered via an order. The only way to obtain products is by producing them. Fulfilling acquired orders is **mandatory**.

Minimum and maximum usage limitations still apply as before. Limitations correspond to the **total amounts** of materials and products in possession at the same time.

The **Total Costs** include all incomes and expenses from orders where payment is due *before* production, plus the total cost of raw materials purchased from the market in the ordinary way. Total Costs are limited: there is a fixed amount of **initial funds** that cannot be exceeded.

The **Total Revenue** includes all incomes and expenses from orders where payment is due *after* production, plus the total revenue from selling products on the market in the ordinary way.

The objective is to optimize for **Profit**, which is the difference between the Total Revenue and the Total Costs.

-----

### Model Analysis and Compatibility

The first observation is that although this problem definition is extensive, if we assume there are **no orders** in the problem, we revert exactly to the production problem with arbitrary recipes.

If there were no orders, the only way to get raw materials is by purchasing from the market, and the only way to gain revenue is by selling products on the market. We would purchase exactly the amount of raw materials needed and sell all the products produced. There would be no potential loss of materials or alternatives.

For this reason, the new model is designed to work with the data files from the "old" arbitrary recipes model, ensuring **backward compatibility**.

-----

### Data Implementation for Orders

First, let's see how the extra data for orders can be implemented in the model using sets and parameters:

```
set Orders, default {};
param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;
```

  * The additional set **Orders** uses a default value of `{}` (an empty one-dimensional set in GNU MathProg). This ensures that original data files, which do not mention the `Orders` set, will still work.
  * **`Order_Material_Flow`**: Similar to `Recipe_Ratio`. If material $m$ is a **raw material**, the order denotes a **purchase** (input). If $m$ is a **product**, the order denotes a **delivery** (output). By default, material flow is zero.
  * **`Order_Cash_Flow`**: Denotes the cash flow associated with the order. This is the **only parameter that can be negative**.
      * A **positive value** means a **cost** (payment) for acquiring the order.
      * A **negative value** means a **revenue** (cash gain) from the order.
      * A zero value is relevant, as it means the order facilitates a materials/products exchange without immediate cash impact.
      * *Note*: A zero `Order_Material_Flow` for all materials in an order with a non-zero cash flow would represent an investment (an expense now for income later), though the current model only implements cash flow once (before or after production).
  * **`Order_Count`**: Denotes the maximum number of times an order can be acquired. Since orders multiply material flows and prices, this must be a non-negative **integer** ($\ge 0$, `integer` keyword). A default of **1** means the order is either acquired once or not at all.
  * **`Order_Pay_Before`**: A **binary** parameter (0 or 1) that specifies the timing of the cash flow.
      * **1 (True)**: Payment is due **before** production (contributes to Total Costs).
      * **0 (False)**: Payment occurs **after** production (contributes to Total Revenue).
      * The default is **1**.
  * *Note*: The `binary` and `integer` keywords indicate the same value restriction for parameters and variables in this context.

-----

### Decision Variables

The following variables are defined, with a new variable to handle order acquisition:

```
var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
```

  * The main recipe variable (`volume`) and the auxiliary variables (`total_costs`, `total_revenue`, `profit`) remain unchanged.
  * **`ordcnt`**: A new variable that denotes how many times a given order is acquired. It is constrained by the `Order_Count` parameter and is required to be an **integer** (`integer` keyword). This is the **only variable** that changes the model from an LP to an **MILP**. Since orders cannot be partially fulfilled, `ordcnt` must take only whole number values (0, 1, 2, ...).

-----

### Material Usage Variables

The material flow is now more complicated because materials can come from and go to different sources. We introduce several usage variables to track this:

  * **Raw Materials** can be obtained from the market or orders, used up by production, or become wasted leftover.
  * **Products** are obtained only by production, and then sold to the market or delivered via orders. Leftovers are not modeled for products because there's no incentive to keep them instead of selling them on the market.
  * Usage refers to the **total amount** in possession at the same time.

<!-- end list -->

```
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
```

All variables are set as $\ge 0$ to ensure quantities are non-negative.

-----

### Material Balance Constraints

Constraints are used to define the relationships between the new usage variables.

**1. Production and Order Calculations**

These constraints calculate the amounts flowing through production and orders based on the decision variables (`volume` and `ordcnt`).

```
s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];

s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
```

**2. Total Usage and Balance for Raw Materials**

For raw materials, the total amount obtained must equal the total amount consumed (production + leftover).

```
s.t. Material_Balance_Total_Raws_1 {r in Raws}:
usage_total[r] = usage_orders[r] + usage_market[r]; 
// Total amount obtained = (From Orders) + (From Market)

s.t. Material_Balance_Total_Raws_2 {r in Raws}:
usage_total[r] = usage_production[r] + usage_leftover[r];
// Total amount used = (Consumed by Production) + (Leftover)
```

  * `usage_market` and `usage_leftover` are "free" variables that the model selects to satisfy the balance equations, given the calculated `usage_orders` and `usage_production` amounts.

**3. Total Usage and Balance for Products**

For products, the total amount obtained must equal the total amount sold/delivered.

```
s.t. Material_Balance_Total_Products_1 {p in Products}:
usage_total[p] = usage_production[p];
// Total available amount = (Amount Produced)

s.t. Material_Balance_Total_Products_2 {p in Products}:
usage_total[p] = usage_orders[p] + usage_market[p];
// Total disposed = (Delivered to Orders) + (Sold on Market)
```

  * The first constraint makes `usage_total[p]` an auxiliary variable equal to `usage_production[p]`. The second constraint ensures this total produced amount is covered by deliveries to orders and sales to the market (`usage_market[p]` is the "free" variable here).

-----

### Cost, Revenue, and Profit Calculation

These constraints calculate the financial variables, incorporating the timing of cash flows from orders.

```
s.t. Total_Costs_Calc: total_costs =
sum {r in Raws} Value[r] * usage_market[r] +
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];

s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage_market[p] -
sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];

s.t. Profit_Calc: profit = total_revenue - total_costs;
```

#### Order Cash Flow Logic:

The sign of `Order_Cash_Flow` is used to represent cost (positive) or revenue (negative).

1.  **If payment is due BEFORE production (`Order_Pay_Before[o]` is true, or 1):** The cash flow is added to `total_costs`.

      * If the order is an **expense** ($\text{Order\_Cash\_Flow} > 0$), $\text{Cost}$ increases.
      * If the order is an **income** ($\text{Order\_Cash\_Flow} < 0$), $\text{Cost}$ decreases (increases available funds).
      * The term is $\sum \text{Order\_Cash\_Flow}[o] \times \text{ordcnt}[o]$.

2.  **If payment is due AFTER production (`!Order\_Pay\_Before[o]` is true, or 0):** The cash flow is subtracted from `total_revenue`.

      * If the order is an **income** ($\text{Order\_Cash\_Flow} < 0$), subtracting a negative number increases $\text{Revenue}$.
      * If the order is an **expense** ($\text{Order\_Cash\_Flow} > 0$), $\text{Revenue}$ decreases (treated as a negative revenue).
      * The term is $-\sum \text{Order\_Cash\_Flow}[o] \times \text{ordcnt}[o]$.

#### Filtering in GNU MathProg

The selective addition of order cash flow is done using a **filter** in the summation's indexing expression:

  * The syntax $\text{sum \{o in Orders: Order\_Pay\_Before[o]\} ...}$ means the sum only iterates over orders $o$ for which the logical expression $\text{Order\_Pay\_Before}[o]$ evaluates to true (i.e., 1).
  * The condition $\text{!Order\_Pay\_Before}[o]$ means the sum iterates over orders where the parameter evaluates to false (i.e., 0).
  * In GNU MathProg, filtering is allowed on all indexing expressions (e.g., `param`, `set`, `var`, `s.t.`, `for`). A sum over an empty set evaluates to zero.

-----

### Complete Model Section and Output

The final model maximizes the profit:

```
set Raws;
set Products;
set Recipes;
set Orders, default {};
check card(Raws inter Products) == 0;
set Materials := Products union Raws;
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;
var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
s.t. Material_Balance_Total_Raws_1 {r in Raws}:
usage_total[r] = usage_orders[r] + usage_market[r];
s.t. Material_Balance_Total_Raws_2 {r in Raws}:
usage_total[r] = usage_production[r] + usage_leftover[r];
s.t. Material_Balance_Total_Products_1 {p in Products}:
usage_total[p] = usage_production[p];
s.t. Material_Balance_Total_Products_2 {p in Products}:
usage_total[p] = usage_orders[p] + usage_market[p];
s.t. Total_Costs_Calc: total_costs =
sum {r in Raws} Value[r] * usage_market[r] +
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage_market[p] -
sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Profit_Calc: profit = total_revenue - total_costs;
maximize Profit: profit;
solve;

printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
for {o in Orders}
{
printf "Acquiring order %s: %dx\n", o, ordcnt[o];
}
for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}
printf "Raw materials (orders + market -> production + leftover):\n";
for {r in Raws}
{
printf "Consumption of raw %s: %g + %g -> %g + %g (total: %g)\n",
r, usage_orders[r], usage_market[r], usage_production[r],
usage_leftover[r], usage_total[r];
}
printf "Products (production -> orders + market):\n";
for {p in Products}
{
printf "Production of product %s: %g -> %g + %g (total: %g)\n",
p, usage_production[p], usage_orders[p],
usage_market[p], usage_total[p];
}
end;
```

The order of variables and constraints does not affect the solution, but a logical flow helps in understanding the model:

1.  **Decision on Orders:** Set `ordcnt`.
2.  **Calculate Order Flows:** Determine `usage_orders`.
3.  **Decision on Production:** Set `volume`.
4.  **Calculate Production Flows:** Determine `usage_production`.
5.  **Adjust Market/Total Flows:** Set `usage_market` and calculate `usage_total` to satisfy material balance.
6.  **Calculate Leftovers:** Determine `usage_leftover`.
7.  **Calculate Financials:** Determine `total_costs`, `total_revenue`, and `profit`.

-----

### Example 1: Problem 14 Data (No Orders)

The first example uses data from **Problem 14** (arbitrary recipes with costs) but without defining the `Orders` set.

```
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A      B      C      D    P1  P2  P3 :=
MakeP1 200    25     3200   1    1   0   0
MakeP2 50     180    1000   1    0   1   0
MakeP3 0      75     4500   1    0   0   1
;

end;
```

**Results:** The optimal solution is the same as the original: **$1,577.45$** profit, with production of 25.48 units of P1, 164.52 units of P2, and 10 units of P3.

```
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 13322.6 -> 13322.6 + 0 (total: 13322.6)
Consumption of raw B: 0 + 31000 -> 31000 + 0 (total: 31000)
Consumption of raw C: 0 + 291065 -> 291065 + 0 (total: 291065)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 25.4839 -> 0 + 25.4839 (total: 25.4839)
Production of product P2: 164.516 -> 0 + 164.516 (total: 164.516)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

*The model works even without orders defined, demonstrating compatibility.*

-----

### Example 2: Problem 18 Data (No Orders, Explicit Empty Sets)

The second example uses data from **Problem 18** (arbitrary recipes with joint production), but explicitly defines the order-related parameters and sets as empty.

```
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A      B      C      D    P1  P2  P3 :=
MakeP1 200    25     3200   1    1   0   0
MakeP2 50     180    1000   1    0   1   0
MakeP3 0      75     4500   1    0   0   1
Comp1  240    200    4400   2    1   1   0
Comp2  51     250    5400   2    0   1   1
;

param Initial_Funds :=;
set Orders :=;
param Order_Material_Flow :=;
param Order_Cash_Flow :=;
param Order_Count :=;
param Order_Pay_Before :=;
end;
```

**Results:** The optimal solution is again the same as before: **$1,965.63$** profit, using the joint production options `Comp1` and `Comp2`.

```
Total Costs: 30495
Total Revenue: 32460.6
Profit: 1965.63
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 6.25
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 86.875
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 21672.5 -> 21672.5 + 0 (total: 21672.5)
Consumption of raw B: 0 + 21000 -> 21000 + 0 (total: 21000)
Consumption of raw C: 0 + 442500 -> 442500 + 0 (total: 442500)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 86.875 -> 0 + 86.875 (total: 86.875)
Production of product P2: 103.125 -> 0 + 103.125 (total: 103.125)
Production of product P3: 10 -> 0 + 10 (total: 10)
```

*The model successfully handles the empty order definition.*

-----
 
