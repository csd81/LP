---------------
Problem 19.
Solve Problem 17, the production problem with arbitrary recipes, where production goes as usual,
but there are orders we may acquire. Orders are optional but can only be acquired (and subsequently fulfilled) completely, not partially. Each order consists of the following.
• A fixed amounts of raw materials and products. If a raw material is in an order, it means that
by acquiring the order, we obtain that raw material in the given amount before production. If
a product is in an order, it means that we deliver it after produced, in the given amount.
• Price of the order. It can either be a gain or a payment. Payment happens either before or
after the production takes place.
• Maximum count. An order can be acquired multiple times, with an upper limit.
Raw materials must either be purchased from the market, as usual, or purchased via acquiring
an order. Leftover raw materials after production took place are lost without compensation.
Products must either be sold on the market, or delivered via an order. The only way of obtaining
products is by producing it. Fulfilling orders is mandatory once acquired.
Minimum and maximum usage limitations still apply as before. Limitations correspond to the
total amounts that are in possession at the same time.
75

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

The total costs include incomes and expenses of those orders for which the payment is due
before production, plus the total costs of raw materials that are purchased from the market in the
ordinary way. The total costs are limited: there is a fixed amount of initial funds which we cannot
exceed.
The total revenue includes incomes and expenses of those orders for which the payment is due
after production, plus the total revenue from selling products at the market in the ordinary way.
Optimize for profit, which is the difference of the total revenue and total costs.
The first observation shall be the point that although there is much description in this problem definition, if we suppose that there are no orders in the problem, then we get exactly to the
production problem with arbitrary recipes. Let us see why this is true. If there were no orders,
then the only way of getting raw materials is by purchasing from the market, and the only way
to gain revenue is by selling products at the market. Of course, we purchase exactly as many raw
materials as needed, and sell all the products we produced. There is no potential loss of materials,
or alternatives.
For this reason, we expect the new model to be working with data files of the „old” model of
arbitrary recipes. In short, compatibility shall be maintained.
First, let us see how the extra data can be implemented in the model as sets and parameters.
set Orders, default {};
param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;
There is one additional set, Orders. Note that in this case, a default value of {} is used. This
is an empty one-dimensional set in GNU MathProg. By this default value we can ensure that the
original data files will work as they are already written, even if we do not mention the Orders set.
There are four parameters that describe orders.
The first one is Order_Material_Flow. The meaning of this parameter is similar to the meaning
of Recipe_Ratio in the arbitrary recipes implementation. If m is a raw material, then the order
denotes a purchase in the given amount. If m is a product, then the order denotes a delivery. By
default, a material does not appear in an order, which is indicated by zero material flow.
The Order_Cash_Flow parameter denotes the cash flow associated with the order. Note that
this is the only parameter which can be negative. A positive value means a cost that must be paid
for acquiring the order. A negative value means a revenue from the order in cash, if acquired, and
of course, if the production goals are met.
Note that a zero Order_Cash_Flow still has a practical relevance. The other party may only
want to exchange raw materials with products.
On the other hand, there is no point in orders where Order_Material_Flow values are zero for
all materials, because cash flow only occurs once, either before or after production. Nevertheless, it
would be easy to implement cash flows both before and after production, and in this case, orders
with no material flows may represent investments: expenses at present, which give more income in
the future.
Remember that orders can be acquired multiple times, multiplying all the material flows, but
also the prices and revenues. The parameter Order_Count is for denoting how many times and
order can be acquired. We also set this parameter to only take nonnegative integer values by the
>=0 bound and integer keyword. This prevents fractional values to be provided in data sections. If
the value of the Order_Count parameter is 4, for example, then we can completely ignore the order,

76

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

or acquire it 1, 2, 3 or 4 times, multiplying all its effects on cash and material flow. The default
value is 1, which means that the order is either acquired once or not at all.
Finally, the Order_Pay_Before parameter denotes whether cash flow occurs before or after the
production takes place. It is important because the total funds are limited before the production,
but profit is calculated afterwards. We used the binary keyword to denote that this parameter may
only take the values 0 or 1. As a convention, a value of 1 means a true, that is, payment is due
before production, and a 0 means that it occurs after production was done. The default is 1, so
cash flow occurs before production.
Note that both the binary and integer keywords indicate the same value restriction for parameters and variables.
After defining all our necessary data definitions in our model section, we define decision variables
which express our freedom of choice in the optimization model.
var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
The volume main variable for recipes, and auxiliary variables total_costs, total_revenue and
profit are left unchanged.
A new ordcnt variable is introduced to denote how many times a given order is acquired. This
is limited by the Order_Count parameter value of each order, but always nonnegative, and most
importantly, it is an integer variable. It must be an integer, because we either fulfill an order (1),
or ignore it (0), but we cannot fulfill an order partly. Therefore ordcnt can take 0 or 1 (and larger
integers), but cannot take fractional values in between.
The ordcnt is the only variable that makes the model an MILP model instead of LP. The
complexity of the model depends on how many orders are there and how many times they may be
acquired.
The usage of the raw materials and products remains to be defined. In the implementation of
the arbitrary recipes, it was easy, one single usage variable was sufficient for all raw materials and
products. But now, the case is a bit more complicated because materials can come from and go to
different sources. Let us collect the possibilities.
A raw material appears in the model in the following roles.
• It can be obtained as an input from the market, as usual.
• It can be obtained as an input by acquiring orders.
• It can be used up by production, as usual.
• There can be leftover amounts of raw materials which are obtained but not used up. These
are wasted.
We might question why it is possible to have leftover raw materials. In the original problem
without the orders, it was impossible. Or, precisely, it was possible in reality, but the model did
not allow it as usage was directly calculated based on production requirements. The reason is that
there was no point in purchasing more raw materials from the market in the beginning than the
amount actually used by production, therefore the amount purchased and consumed was assumed
to be equal.
But in this case, there are orders. It may happen that an order contains a large amount of
raw materials that cannot be used up by production, meanwhile the order is still needed for other

77

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

purposes. The fact that orders can only be acquired in a whole makes it possible to have leftover
materials.
A product appears in the model in the following ways.
• It can only be obtained by production, as usual.
• It can be turned into revenue by selling it at the market, as usual.
• It can be turned into revenue also by delivery, by fulfilling orders.
In contrast with the raw materials, there is no practical relevance of leftovers in case of products.
The reason is that the only way a product can be obtained is by production, which can be freely
scaled and does not have an integer nature as raw materials obtained from orders. Or, for a second
and more obvious reason, there is no point in keeping a product as leftover instead of selling it at
the market.
If we are unsure about the possibilities, it is a good method of modeling to introduce a variable
for every quantity appearing, and then specify their relations through constraints. For both raw
materials and products, there is activity by orders and market, and also by production. However,
only raw materials may have leftovers.
As the problem definition mentioned, usages refer to the total amounts present at the same time.
So it is a good idea to introduce a total usage variable as well, for which the appropriate bounds
can be specified. The remaining usage variables are the following.
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
The model can surely be implemented with less variable definitions, but it is generally easier to
introduce more variables than needed, implement a correct model, and if we are not satisfied, then
we may think about how the model can be simplified.
Note that all variables are set as nonnegative. This is important, every quantity of materials
must be nonnegative. Otherwise, practically infeasible solutions may be reported.
Now materials balance can be established as constraints. The total amounts of raw materials
used up at production and products produced both can be calculated the same way. For all recipes,
the volume in which it is utilized must be multiplied by the material appearing. Similarly, the
amounts of raw materials obtained and products delivered can also be calculated in a common
way. We have to add the material flow per order, multiplied by the number of times the order is
acquired. These two constraints together means that usage_production and usage_orders are
exactly calculated.
s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
There are a few other usage constraints that must be established. The calculation of the total
usage can be done two ways for both raw materials and products. The total usage of raw materials
equals the total obtained, which comes from orders and from the market. On the other hand, the
total usage of a raw material also equals the amount consumed plus the leftover. Similarly, the
total usage of a product can be determined two different ways that lead to equations. First, all the
products are obtained by production, so these two variables are equal. On the other hand, all the
products are either delivered as an order or sold at the market.
78

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

s.t. Material_Balance_Total_Raws_1 {r in Raws}:
usage_total[r] = usage_orders[r] + usage_market[r];
s.t. Material_Balance_Total_Raws_2 {r in Raws}:
usage_total[r] = usage_production[r] + usage_leftover[r];
s.t. Material_Balance_Total_Products_1 {p in Products}:
usage_total[p] = usage_production[p];
s.t. Material_Balance_Total_Products_2 {p in Products}:
usage_total[p] = usage_orders[p] + usage_market[p];
We can analyze whether the constraints are correct.
As mentioned, usage_production and usage_orders are calculated based on other variables
of the model (recipes and orders). The total usage calculation is different for raw materials and
products.
The equation Material_Balance_Total_Raws_1 expresses that the total amount must be at
least the amount obtained by orders. This is true because usage_market is a nonnegative variable.
Therefore the total amount is first coming from orders, and then we may additionally purchase from
the market. Note that usage_orders is a calculated auxiliary variable, but usage_market is „free”.
The equation Material_Balance_Total_Raws_2 describes that whichever total amount we obtained by orders and market, it must be used up by production or it is a leftover. The amount for
production is calculated, but the leftover amount „can be selected freely” to match the total amount
obtained. Again, it is very important that all these variables are nonnegative, for which reason
neither the amount used at production nor the amount of leftovers can exceed the total.
The two equations for the products are a bit easier.
Constraint Material_Balance_Total_Products_1 expresses that the total available amount is
the production. This effectively makes usage_total itself a calculated auxiliary variable. Then,
Material_Balance_Total_Products_2 ensures that this total must be at least the amount that is
delivered, and anything that remains can be sent to the market. Again, ensured by the nonnegativity
bounds. Note that usage_leftover is a value that we do not care about. It still plays an important
role in the model solely because it must be nonnegative. Also, if the problem definition would
change, for example to limit, penalize or give a refund for leftover raw materials, it would be easy
to implement such a modification because the leftover amount is already represented in a variable.
Remember that it is possible to implement this model with fewer variables and material balance
constraints, even at first, but would require some expertise.
There is another set of constraints left, which is the calculation of the total costs, revenue and
profit, as for the original model. However, in this case, it is a bit more complicated because orders
contribute to costs and revenue.
s.t. Total_Costs_Calc: total_costs =
sum {r in Raws} Value[r] * usage_market[r] +
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage_market[p] sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Profit_Calc: profit = total_revenue - total_costs;
The total value marketed is a cost for raw materials, and a revenue for products. However, we
must add cash flow from orders. For good reason, we did not model orders with cash gain and
payment as different, but simply the sign of the Order_Cash_Flow shows us whether it has a cost,
or it pays. But there is one thing which cannot be modeled by signs: the timing of cash flow.
• If payment occurs before production (denoted by the Order_Pay_Before parameter being 1),
then the cash flow amount must be added to the total costs.
79

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

• If payment occurs after production (denoted by the Order_Pay_Before parameter being 0),
then the cash flow amount must be added to the total revenue. Note that raw material costs
paid after the production are treated as negative revenues instead of costs.
It does not matter whether we gain or pay with an order. If an order is an expense before
production, we simply add the positive value of Order_Cash_Flow to the total costs. If we have
an income before production, then this amount must be subtracted from the total costs, because
this increases our initial funds that can be spent for other purposes before production. For this
reason, the meaning of the variable total_costs slightly changes. It does not represent the actual
total costs anymore, but the total balance of incomes and expenses before production. But because
Order_Cash_Flow is negative for incomes and positive for expenses, we simply add its value to the
total, in both cases.
Similarly, cash flow by an order after production can either be an income or an expense. If it
is an income, it must be added, if it is an expense, it must be subtracted from the total revenue.
Because of the sign of Order_Cash_Flow, we have to subtract this value in both cases.
Finally, let us see how the selective addition is solved in GNU MathProg. The problem is
that not all orders must be added to either the costs or the revenue, but only their subset (where
Order_Pay_Before) has the appropriate value). Therefore, a condition is included into the indexing
expression of the sum. This is called filtering. It means that instead of iterating over the full index
set, only those of them are taken into account for which a given logical expression evaluates true.
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
Here the original index set is the set of o orders from the Orders set. The logical expression
must appear after all the indices. Now this expression is Order_Pay_Before[o] which evaluates to
a number, either 0 or 1, and 1 is the true value. The opposite is done for the revenues where those
orders are taken into account where !Order_Pay_Before[o] is true, therefore it must be 0.
sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o]
In an indexing expression, even though there can be multiple indices, only one filtering logical
expression is allowed, after all indices are listed, following a colon. We can have more or complex
filters by logical operator like &&, || or !, these also have more readable aliases and, or and not.
There are other operators as well. The criteria is that the expression must evaluate to a constant
numeric value. For instance, the filtering expression can only refer to variables after the solve
statement where variables are determined.
Filtering, as could be guessed, can be used on all indexing expressions. Examples other than the
sum just so far included param, set, var, s.t., for and check (there are more statements that can
be indexed). The meaning is always the same, the index set is restricted according to the logical
expression.
Note that it is valid in GNU MathProg for an indexing expression to be evaluated over an empty
set, for example if the logical condition excludes all the indices. In this case, the expression which is
indexed is treated similarly as if it was not present in its context at all. For example, a sum over an
empty set evaluates to zero, or a s.t. statement over an empty set does not define any constraint.
Finally, the objective of the model is the profit, and we are ready. In the post-processing work,
we can print out some of the values to overview the result. The ultimate model section, for the
production problem with arbitrary recipes and orders, is the following.
set Raws;
set Products;
set Recipes;

80

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

set Orders, default {};
check card(Raws inter Products) == 0;
set Materials := Products union Raws;
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
param Order_Material_Flow {o in Orders, m in Materials}, >=0, default 0;
param Order_Cash_Flow {o in Orders}, default 0;
param Order_Count {o in Orders}, >=0, integer, default 1;
param Order_Pay_Before {o in Orders}, binary, default 1;
var volume {c in Recipes}, >=0;
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
var ordcnt {o in Orders}, integer, >=0, <=Order_Count[o];
var usage_orders {m in Materials}, >=0;
var usage_market {m in Materials}, >=0;
var usage_production {m in Materials}, >=0;
var usage_leftover {r in Raws}, >=0;
var usage_total {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
s.t. Material_Balance_Production {m in Materials}: usage_production[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Material_Balance_Orders {m in Materials}: usage_orders[m] =
sum {o in Orders} Order_Material_Flow[o,m] * ordcnt[o];
s.t. Material_Balance_Total_Raws_1 {r in Raws}:
usage_total[r] = usage_orders[r] + usage_market[r];
s.t. Material_Balance_Total_Raws_2 {r in Raws}:
usage_total[r] = usage_production[r] + usage_leftover[r];
s.t. Material_Balance_Total_Products_1 {p in Products}:
usage_total[p] = usage_production[p];
s.t. Material_Balance_Total_Products_2 {p in Products}:
usage_total[p] = usage_orders[p] + usage_market[p];
s.t. Total_Costs_Calc: total_costs =
sum {r in Raws} Value[r] * usage_market[r] +
sum {o in Orders: Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage_market[p] sum {o in Orders: !Order_Pay_Before[o]} Order_Cash_Flow[o] * ordcnt[o];
s.t. Profit_Calc: profit = total_revenue - total_costs;
maximize Profit: profit;
solve;

81

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
for {o in Orders}
{
printf "Acquiring order %s: %dx\n", o, ordcnt[o];
}
for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}
printf "Raw materials (orders + market -> production + leftover):\n";
for {r in Raws}
{
printf "Consumption of raw %s: %g + %g -> %g + %g (total: %g)\n",
r, usage_orders[r], usage_market[r], usage_production[r],
usage_leftover[r], usage_total[r];
}
printf "Products (production -> orders + market):\n";
for {p in Products}
{
printf "Production of product %s: %g -> %g + %g (total: %g)\n",
p, usage_production[p], usage_orders[p],
usage_market[p], usage_total[p];
}
end;
Remember that the order of constraints which is presented here is only important for us to
understand what the model does. The order of constraints and variables does not affect the model
itself and its solutions (although it might possibly affect the solution algorithm, but definitely not
the final answer). On the other hand, it is useful to establish some logical order of the variables
and/or constraints, to understand the model we implement. For example, a logical order can be the
following which explains the model code.
1. We decide how many times each order is acquired (variable ordcnt).
2. Then, we calculate the amount obtained or delivered as part of orders (variable usage_order),
based on our former decisions on ordcnt.
3. We decide how much production we want to perform (variable volume).
4. Then, we calculate the amount of raw materials and products present in the production process
(variable usage_production), based on our former decisions on volume.
5. We adjust the amounts of raw materials purchased and products sold at the market (variable
usage_market) and then calculate the total amounts (variable usage_total) so that there is
enough raw material, and all products are sold, based on our former decisions on production,
orders, and market activity.
6. Then, we calculate the leftover amount of raw materials (variable usage_leftover) based on
decisions of other usages.
82

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

7. Finally, we calculate the total costs, the total revenue, and the objective function, which is
the profit. Their values are based on former decisions.
Meanwhile, if one of the appearing quantities are limited (like usage, or order count), then a
corresponding constraint or bound must be formulated.
The optimization procedure is making these decisions to maximize the profit obtained at the
final step. But for the technical, solution algorithmic point of view, the above logical order does
not matter, statements in GNU MathProg can be defined in any order, provided that each time we
refer to a model object, then its definition is before that reference.
Now try the model with some valid data. The first example is the problem instance introduced
to demonstrate raw material costs, Problem 14. This was solved before.
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A
B
C
MakeP1 200
25 3200
MakeP2
50 180 1000
MakeP3
0
75 4500
;

D
1
1
1

P1
1
0
0

P2
0
1
0

P3 :=
0
0
1

end;
The optimal solution is the same as for the original model for arbitrary recipes, 25.48 units of
83

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

P1, 164.52 units of P2 and 10 units of P3, yielding a profit of 1577.45. What is important here is
that the data section is exactly the same as for the original model. The extension with orders also
works if no orders are defined. However, the output is different because the post-processing work
changed.
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 13322.6 -> 13322.6 + 0 (total: 13322.6)
Consumption of raw B: 0 + 31000 -> 31000 + 0 (total: 31000)
Consumption of raw C: 0 + 291065 -> 291065 + 0 (total: 291065)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 25.4839 -> 0 + 25.4839 (total: 25.4839)
Production of product P2: 164.516 -> 0 + 164.516 (total: 164.516)
Production of product P3: 10 -> 0 + 10 (total: 10)
A second example, still without orders, is Problem 18, where arbitrary recipes were introduced.
In this data section we also included the newly introduced parameters and sets, with empty values.
This is valid, as the Orders set is explicitly set to empty. So that all the other parameters have an
empty index set. They need not be present in the data section, but it is not a mistake to make it
so. At least it reminds us that the data file may provide additional parameters.
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3 Comp1 Comp2;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07

84

5.7. ORDER FULFILLMENT

PRODUCTION PROBLEM

C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A
B
C
MakeP1 200
25 3200
MakeP2
50 180 1000
MakeP3
0
75 4500
Comp1
240 200 4400
Comp2
51 250 5400
;

D
1
1
1
2
2

P1
1
0
0
1
0

P2
0
1
0
1
1

P3 :=
0
0
1
0
1

param Initial_Funds :=;
set Orders :=;
param Order_Material_Flow :=;
param Order_Cash_Flow :=;
param Order_Count :=;
param Order_Pay_Before :=;
end;
The solution is again the same as before, an optimal profit of 1965.62, with 86.88 units of P1,
103.13 units of P2 and 10 units of P3 produced, using the joint production options Comp1 and Comp2.
Total Costs: 30495
Total Revenue: 32460.6
Profit: 1965.63
Volume of recipe MakeP1: 0
Volume of recipe MakeP2: 6.25
Volume of recipe MakeP3: 0
Volume of recipe Comp1: 86.875
Volume of recipe Comp2: 10
Raw materials (orders + market -> production + leftover):
Consumption of raw A: 0 + 21672.5 -> 21672.5 + 0 (total: 21672.5)
Consumption of raw B: 0 + 21000 -> 21000 + 0 (total: 21000)
Consumption of raw C: 0 + 442500 -> 442500 + 0 (total: 442500)
Consumption of raw D: 0 + 200 -> 200 + 0 (total: 200)
Products (production -> orders + market):
Production of product P1: 86.875 -> 0 + 86.875 (total: 86.875)
Production of product P2: 103.125 -> 0 + 103.125 (total: 103.125)
Production of product P3: 10 -> 0 + 10 (total: 10)
And finally let us see a new problem, with orders introduced. The starting point is the previous
problem.
