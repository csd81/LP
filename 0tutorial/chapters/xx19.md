-----------------------
Chapter 6

Transportation problem
Another common optimization problem, the so-called transportation problem is presented.
Given some supply points with known resource availability, and demand points with known resource
requirement, the goal is to arrange transportation of the resource between supplies and demands.
Note that this problem also has very fast algorithmic solution techniques [15]. Again, we are
interested in the modeling techniques instead. As we will see, an LP/MILP formulation can easily
be adapted if the problem definition changes. This can be substantially more difficult for solution
algorithms.
Some additional capabilities of GNU MathProg are presented here. The aim of this chapter is to
show how different cost functions can be handled while remaining in the class of LP and sometimes
MILP models. Finally, an additional level of transportation is added to the problem definition to
show an example of how separately modeled parts of a system can be incorporated into a single
model.

6.1

Basic transportation problem

The basic transportation problem, in general, can be described as follows.

Problem 21.
Given a single material, a set of supply points, and a set of demand points. Each supply
point has a nonnegative availability, and each demand point has a nonnegative requirement for the
material. The material can be transported from supply point to any demand point, in any amounts.
The unit cost for transportation is known for each such pair. Find the transportation amounts so
that the following holds:
• Available amounts at supply points are not exceeded.
• Required amounts at demand nodes are satisfied.
• The total transportation cost is minimal.
For the sake of simplicity, supply points and demand points are simply called supplies and
demands. Note that the term material can be replaced by any other resource as well (e.g. electricity,
water, funds, manpower).
The network of supplies and demands can be described by a directed graph (see Figure 1),
where nodes represent the supplies and demands, and arcs represent connections in between. The
direction of an arc represents the direction of material flow, which is always from supply to demand.
90

6.1. BASIC TRANSPORTATION PROBLEM

TRANSPORTATION PROBLEM

Figure 1: Graph representing the original transportation problem.
As in case of the production problem, we provide an example for the transportation problem.
The following problem data will be used throughout this chapter.

Problem 22.
There are four supplies named S1 to S4 and six demands named D1 to D6. The amount of
available materials at each supply, required materials at each demand, and unit transportation costs
between each pair of a supply and a demand, are all summarized in the following table.

S1
S2
S3
S4
Required

D1
5
1
6
9
120

D2
10
2
5
10
140

D3
3
6
1
6
170

D4
9
1
6
8
90

D5
5
2
4
9
110

D6
12
6
8
7
120

Available
100
250
190
210

(Numbers in the last row and column refer to material amounts, elsewhere numbers refer to costs
per amount of material transported.)
Transport materials from the supplies to the demands to satisfy requirements at minimal cost.
As discussed in Section 5.6, the first task when considering mathematical programming is to find
suitable decision variables. However, in GNU MathProg, we can start with the implementation of
parameters and sets for problem data.
In this problem, there are two sets of arbitrary size each: the set of supplies and the set of
demands. There are three kinds of numeric parameters determining the transportation problem,
namely the following.
91

6.1. BASIC TRANSPORTATION PROBLEM

TRANSPORTATION PROBLEM

• The availability, provided for each supply.
• The requirement, provided for each demand.
• The unit transportation cost, provided for each pair of a supply and a demand.
Therefore the implementation can be the following. Note that all parameters are indicated as
nonnegative to prevent wrong data to be provided. The names of the sets and parameters are
self-explanatory.
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
param Cost {s in Supplies, D in Demands}, >=0;
The decisions to be made in a transportation problem are the exact transportation amounts. This
amount shall be decided for each pair of a supply and a demand, and these decisions are independent.
For example, the problem mentioned has 4 supplies and 6 demands, therefore 24 individual decisions
shall be made about transported amounts between supplies and demands. Each of these decisions
corresponds to a single variable in the model. With indexing, this can be expressed in a single var
statement. The name of the variable is tran.
var tran {s in Supplies, D in Demands}, >=0;
Transportation amounts are nonnegative. A negative transportation amount could model a
transportation in backwards direction (i.e. from a demand to a supply). This may be justified in
some practical applications, but definitely prohibited here.
We can see that the transportation amounts describe the situation fully. Based on them, we
can easily calculate total activity at each supply and demand node, whether available and required
amounts are not violated, and also calculate the costs. Therefore no more decision variables are
needed.
Now the constraints in the model are formulated. Of course, not all possible nonnegative real
values of the transportation amounts result in a feasible solution in reality, because there are two
kinds of restrictions that must be taken into account. First, the total amount transported from a
supply cannot exceed the availability at that supply. This is a constraint for each supply. Note that
the summation goes through all demands, as there can be transportation to all demands from a
particular supply.
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
Similarly, the total amount transported to a demand cannot be less than the requirement at that
demand. This constraint is for each demand, and the summation now goes through all supplies, as
there can be transportation from all supplies to a particular demand.
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
The objective is the total cost. Each transportation amount must be multiplied by the unit cost
on that particular connection, then summed over all connections between supplies and demands.

92

6.1. BASIC TRANSPORTATION PROBLEM

TRANSPORTATION PROBLEM

minimize Total_Costs:
sum {s in Supplies, d in Demands} tran[s,d] * Cost[s,d];
At this point, let us think a bit about whether the problem has a solution at all. Two quantities
are of special interest: the total amount of available supply, denote it by S, and the total amount
of required demand, denote it by D. There are three cases.
• If S < D, then the problem is infeasible, as there is simply not enough supply anywhere to fit
all demands.
• If S = D, then the problem is feasible, but all supply must be used up, and each demand shall
get exactly the required amount, no more.
• If S > D, then there can (and will) be leftover material at supplies, or exceeding deliveries at
demands, or both.
Without solving the model, we can check problem data whether the problem is feasible. This
check statement is ideally positioned after the parameters but before variable and constraint definitions. This check is useful, because we get a dedicated error message referring to this check
statement if a problem is infeasible.
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
Note that in our model formulation, we allow both leftover materials at supplies, or exceeding
deliveries at demands. If these were not allowed, the corresponding two constraints should be equations instead. Note that if transporting costs are positive, then there is no benefit in transporting
over the demand, so that case is eliminated by optimization anyways.
In some formulations of the transportation problem, S = D is assumed. Note that in a problem
with S > D we can introduce a dummy demand with requirement S − D, and zero transportation costs from all supplies. The meaning of the dummy demand is that leftover amounts are all
transported here. Therefore this new problem is equivalent to the original one, but has equal total
supplies and demands. In conclusion, the case S > D is essentially not more general than S = D.
The model description for Problem 21, the transportation problem, is ready. The model section
can be appended with printf statements to show the result once found. Note that we only show
transportation amounts that are nonzero. The full model section is the following.
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
param Cost {s in Supplies, D in Demands}, >=0;
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {s in Supplies, D in Demands}, >=0;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
minimize Total_Costs:

93

6.1. BASIC TRANSPORTATION PROBLEM

TRANSPORTATION PROBLEM

sum {s in Supplies, d in Demands} tran[s,d] * Cost[s,d];
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {s in Supplies, d in Demands: tran[s,d] > 0}
{
printf "From %s to %s, transport %g amount for %g (unit cost: %g).\n",
s, d, tran[s,d], tran[s,d] * Cost[s,d], Cost[s,d];
}
end;
For sake of completeness, we also show the data section corresponding to  
Problem 22.
data;
set Supplies := S1 S2 S3 S4;
set Demands := D1 D2 D3 D4 D5 D6;
param Available :=
S1 100
S2 250
S3 190
S4 210
;
param Required :=
D1 120
D2 140
D3 170
D4 90
D5 110
D6 120
;
param Cost:
D1 D2 D3 D4
S1
5 10
3
9
S2
1
2
6
1
S3
6
5
1
6
S4
9 10
6
8
;

D5
5
2
4
9

D6 :=
12
6
8
7

end;
Solving the problem with glpsol gives the following result.
Optimal cost: 2700.
From S1 to D1, transport 10 amount for 50 (unit cost: 5).
From S1 to D5, transport 90 amount for 450 (unit cost: 5).
From S2 to D1, transport 110 amount for 110 (unit cost: 1).

94

6.2. CONNECTIONS AS INDEX SET

TRANSPORTATION PROBLEM

From S2 to D2, transport 140 amount for 280 (unit cost: 2).
From S3 to D3, transport 170 amount for 170 (unit cost: 1).
From S3 to D5, transport 20 amount for 80 (unit cost: 4).
From S4 to D4, transport 90 amount for 720 (unit cost: 8).
From S4 to D6, transport 120 amount for 840 (unit cost: 7).
The result of the transportation problem can be fit into the original data table, by substituting
the unit costs with the decided transportation amounts. Zero amounts can be omitted at all.

S1
S2
S3
S4
Required

D1
10
110

D2

D3

D4

D6

140
170

120

D5
90

140

20
90
90

170

110

120
120

Available
100
250
190
210

This representation better explains the elements of the model. Decisions are represented by inner
cells, while constraints are represented by the rightmost column and bottom row. Each constraint
for a supply expresses that the sum in that row must be at most the number on the right. Each
constraint for a demand expresses that the sum in that column is at least the number at the
bottom. Since total supplies and demands are equal, these can only be true if all constraints hold
as an equation. This is exactly the case throughout the table.
Investigating the results, we can see that the optimal solution tries to use the cheapest unit costs
wherever possible, but not always. For example, S4 to D4 is chosen, despite not being the cheapest
method, neither from supply S4, nor to demand D4, but proven to be a good choice because the rest
of the transportation can be done cheaper. Note that with this single run of the model, we cannot
be sure that this is the only optimal solution.
There are plenty of other examples for the transportation problem publicly available, see for
example [16].

6.2

Connections as index set

Based on the complete solution presented in Section 6.1, we now enhance the implementation a
bit. As mentioned before, in GNU MathProg we can introduce additional parameters and sets in
order to simplify model formulation. These can either be defined on spot, read from a separate data
section outside the model, or allowing both as a default value.
Observe that the indexing expression s in Supplies, d in Demands appears in four different
contexts:
• In the Cost parameter, as it is defined for all such pairs.
• In the tran variable, as it is defined for all such pairs.
• In the objective, as it is a sum over all such pairs.
• In the post-processing work, because transport amounts are printed for all such pairs. Note
that in this case, there is a filter that only allows nonzero amounts to be reported.
It would be fatal to make a mistake in this indexing, for example, if we exchanged the order of
Supplies and Demands, resulting in a modeling error. To avoid such errors and decrease redundancy
95

6.2. CONNECTIONS AS INDEX SET

TRANSPORTATION PROBLEM

in the model formulation a bit, we can introduce a two-dimensional set of these pairs to be used
later. Each supply and each demand are said to be in a connection. Therefore, the transportation
problem involves the decision of transportation amounts for each connection. The set Connections
can be introduced in the following way.
set Connections := setof {s in Supplies, d in Demands} (s,d);
A new GNU MathProg operator setof is used here. This is a general way of defining sets based
on data previously defined in the model section. The setof operator is followed by an indexing
expression, then by a simple expression. The resulting set is formed by the expression at the back
evaluated for all possible indices in the indexing expression. It is similar to sum, but rather to adding
elements up, a set of them is formed. Note that the indexing expression in setof can be filtered,
which gives us a fine control over the set to be defined. As the result is a set, duplicates are removed,
and the result can also be empty if everything is filtered out, but these are not the cases here.
In fact, this usage of setof is rather simple, just all possible pairs formed by two sets are
collected. The set Connections is a Cartesian product of sets Supplies and Demands. There is
another built-in operator called cross for Cartesian product of two sets, which allows a simpler
definition of the set Connections as follows. Either definition can be used, they are equivalent.
set Connections := Supplies cross Demands;
The dimension of sets Supplies and Demands is 1 because they contain simple elements,
whereas the dimension of Connections is 2, because it contains pairs. There can be as many
as 20 dimensions in a set in GNU MathProg. If the set contains n-tuples, then its dimension is n.
Sets with different dimensions cannot be mixed together with set operations like union, inter or
diff. Even a one-dimensional empty set is considered different from a two-dimensional empty set.
The dimension of a set determines how it can be used in indexing expressions. One-dimensional
sets are indexed by a single introduced symbol, like s in Supplies or d in Demands. However,
two- (and more) dimensional sets are indexed by a tuple element, like (s,d) in Connections. In
general, an indexing expression may contain many sets with different dimensions, each of which
introducing one or more new index symbol that can be referred to.
In short, everywhere instead of s in Supplies, d in Demands in an indexing expression, we
can write (s,d) in Connections as follows.
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];

96

6.2. CONNECTIONS AS INDEX SET

TRANSPORTATION PROBLEM

minimize Total_Costs:
sum {(s,d) in Connections} tran[s,d] * Cost[s,d];
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g amount for %g (unit cost: %g).\n",
s, d, tran[s,d], tran[s,d] * Cost[s,d], Cost[s,d];
}
end;
The resulting new model file is equivalent to the original one, therefore solving the same data
file describing Problem 22 shall yield the same result.
To illustrate how it can be useful to introduce an index set like Connections explicitly in the
model, consider the following new problem.
