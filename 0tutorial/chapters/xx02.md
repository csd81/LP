
---

# Chapter 2: Optimization

## 2.1 Equations

Equations are among the simplest and most powerful tools we have for mathematical modeling. Let's look at an example problem that can be solved using a single equation.



**Problem 1.**
Alice's train departs in 75 minutes. She lives 3 km away from the station and plans to walk, but she also needs 30 minutes to get ready. How fast must she walk to the station to catch the train?

We can see that we are actually looking for the minimum average speed Alice must maintain. She might walk faster at some points or slower at others, but her overall average speed determines her arrival time. She could even walk at a constant speed to achieve the same result. We are specifically looking for the minimal speed at which she *just* catches the train. Of course, she could walk faster and have some waiting time at the station. These assumptions may seem trivial, but they are part of the modeling process: we have simplified the problem to finding a single minimal speed value, assuming Alice walks at that constant speed to arrive precisely on time.

We can solve this problem by expressing the time until she reaches the station in two different ways. First, based on the train schedule, her arrival time is 75 minutes from now. Second, her arrival time is the sum of the 30 minutes needed for preparation plus the time spent walking. The walking time is the unknown term because it depends on Alice's speed. We now introduce a variable, $x$, to represent Alice's speed—this is what we need to find. The variable $x$ represents a value that can be chosen, giving Alice control over the outcome. She can adjust her speed to arrive at the station sooner or later.

Using $x$, we can easily express the time she spends walking as $\frac{3 \text{ km}}{x}$. We can now formulate an equation based on the fact that Alice's arrival time is expressed in these two different ways.

$$30 \text{ min} + \frac{3 km}{x} = 75 \text{ min}$$

(1)

Alice's task is to choose an appropriate $x$ so that this equation holds true. At this point, the equation is formulated, so we can set aside the real-world scenario and apply our mathematical knowledge to solve it. This one is easy. For example, we can subtract 30 minutes from both sides, multiply by $x$ (assuming $x$ is not zero), and then divide by 3 km, in that order. We arrive at the following:

$$x = \frac{4 km}{h}$$

(2)

## 2.2 Finding the "Best" Solution

When we solve an equation, we are essentially transforming it into simpler forms, where each new form is a direct consequence of the previous one. The final form is $x = \frac{4 \text{ km}}{\text{h}}$, which literally means: "If $30 \text{ min} + \frac{3 \text{ km}}{x} = 75 \text{ min}$, then the direct consequence is $x = \frac{4 \text{ km}}{\text{h}}$." So, if Alice wants to *just* catch the train, her average speed must be $\frac{4 \text{ km}}{\text{h}}$. At this point, we have the mathematical result and can interpret it in reality. This is the general approach to using equations in problem-solving. First, we identify the degree of freedom in the problem (in this case, $x$, the speed). Then, we use equations as modeling tools to express the rules of reality that must be followed (Equation 1). Once the model is ready, we apply solution techniques that are typically general for all types of equations and independent of the underlying real-world problem. In this case, the equation is transformed through a chain of direct consequences until the variable is expressed directly as a constant value. Finally, once we obtain the result from the mathematical model, we interpret it as the solution to our initial real-world problem.

Of course, there are much more difficult examples of equation solving (such as multiple solutions for single equations, extraneous solutions, multiple variables, systems of multiple equations, etc.) that we won't cover here. However, the scheme is always similar: we formulate a mathematical model that describes the real-world situation, solve that model using well-known general techniques, and then interpret the model's solution as the answer to the original problem.

## 2.3 Main Concepts

Notice that in Problem 1, the question asked how fast Alice *must* go. The answer was $x = \frac{4 \text{ km}}{\text{h}}$, but that isn't entirely accurate. In reality, $x = \frac{5 \text{ km}}{\text{h}}$, $x = \frac{10 \text{ km}}{\text{h}}$, or even $x = \frac{15 \text{ km}}{\text{h}}$ are also valid solutions for her, assuming she can walk that fast. However, $x = \frac{3 \text{ km}}{\text{h}}$ is not a solution, because she would miss the train at that speed. While we understand that $x = \frac{4 \text{ km}}{\text{h}}$ is the *minimum* speed required for Alice to make the train on time, a more precise formulation would be the following inequality:

$$30 \text{ min} + \frac{3 \text{ km}}{x} \leq 75 \text{ min}$$

(3)

Here, two quantities are compared: the time Alice needs to reach the station if her speed is $x$ (which is $30 \text{ min} + \frac{3 \text{ km}}{x}$) and the time the train departs (75 min). These two quantities are related: Alice must arrive at or before the train is due (in other words, no later). This is best expressed as an inequality rather than an equation, though the goal is the same. We must find a speed $x$ for Alice for which the inequality holds. Technically, this can be solved in exactly the same way as the equation, leading to $x \geq \frac{4 \text{ km}}{\text{h}}$. This means the solutions effectively include all speeds $x$ that are at least $\frac{4 \text{ km}}{\text{h}}$. Since there are infinitely many solutions to the inequality, Alice can choose from infinitely many speeds.

While this is more precise, Alice is likely interested in the minimum speed she can get away with—meaning let $x$ be as small as possible. The formulation is as follows:

$$\begin{aligned} \text{minimize} &: x \\ 
\text{subject to} &: 30 \text{ min} + \frac{3 \text{ km}}{x} \leq 75 \text{ min}\end{aligned}$$ 

(4)

At this point, the formulated problem is an **optimization problem**. The goal isn't just to find *a* suitable solution for a real-world problem, but to find the **most suitable** one based on specific criteria. From a mathematical perspective, optimization involves finding the *best* solution, not just any solution, for an equation, inequality, or set of such statements. Optimization is a sub-field of Operations Research, as it is an essential tool for supporting business decisions: given a complex real-world situation, what is the best course of action?

Now that we have seen some optimization in Problem 1, it is time to establish some basic concepts regarding optimization models.

When we solve a real-world problem by defining variables, equations, inequalities, and so on, we are formulating a **mathematical model** for the problem. That model is then solved using mathematical knowledge that is usually independent of the original, real-world problem. If the solution procedure is carried out by software (which is usually the case), that software is called a **solver**.

An optimization model contains **variables**. These represent our freedom of choice: the different values a variable can take represent our different potential actions. In Problem 1, there is a single variable, $x$, representing Alice's average speed.

A **solution** to an optimization model occurs when all the variables are assigned a value. If the model has multiple variables, a single solution consists of values for all of those variables. Two solutions are considered different if any of the variables take a different value. In Problem 1, there are infinitely many solutions, such as $x = \frac{4 \text{ km}}{\text{h}}$, $x = \frac{10 \text{ km}}{\text{h}}$, and even $x = \frac{1 \text{ km}}{\text{h}}$ (see below), though in the latter case, Alice misses the train.

Usually, variables cannot take arbitrary values. In Problem 1, Alice cannot choose a speed that would cause her to miss the train. Such mandatory restrictions are called **constraints**. In our example problem, there is a single constraint, which is expressed by Inequality (3).

A wide range of constraints may appear in an optimization problem; some cannot even be expressed as simple inequalities. We should also mention the concept of **bounds**: these are constraints that require a single variable to be no less than or no more than a given constant limit. For example, $x \geq \frac{0 \text{ km}}{\text{h}}$ is a bound that must also be enforced. The problem required Alice to move at a positive speed, so this was implicitly enforced rather than explicitly stated. In many optimization problems, however, we must explicitly consider bounds; otherwise, the solutions might not reflect reality. Bounds also have great practical importance in model solution algorithms.

Constraints determine whether solutions are **feasible** or **infeasible**. A feasible solution is one where all variables take values for which all the constraints hold true. Otherwise, it is an infeasible solution. In Problem 1, solutions $x = \frac{4 \text{ km}}{\text{h}}$ and $x = \frac{10 \text{ km}}{\text{h}}$ are feasible, while $x = \frac{1 \text{ km}}{\text{h}}$ is infeasible. We could simply say that $x = \frac{4 \text{ km}}{\text{h}}$ is a solution and $x = \frac{1 \text{ km}}{\text{h}}$ is not, but we prefer the terminology of feasible and infeasible solutions.

The way we differentiate between feasible solutions—determining which ones are more or less suitable—is expressed in the model as an **objective function**, which is to be minimized (or maximized). Like constraints, an objective function evaluates an expression based on the model variables. The goal of optimization is to find a feasible solution where the objective function is minimal (or maximal). A solution with this property is an **optimal solution** of the model. If a solution is optimal, we can be sure that any other solution is either infeasible, has an equal or worse objective value, or both. There can be multiple optimal solutions for the same model. In Problem 1, we have a very simple objective function, $c(x) = x$, which is minimal at the solution $x = \frac{4 \text{ km}}{\text{h}}$. The optimal objective for the problem is therefore $\frac{4 \text{ km}}{\text{h}}$. Sometimes, we refer to the objective value as the solution of an optimization problem. Therefore, we can say that the optimal solution to Problem 1 is $\frac{4 \text{ km}}{\text{h}}$.

It may happen that an optimization model does not have a feasible solution at all, meaning there are no optimal solutions either. In this case, we say the model is **infeasible**. For example, consider the following modification (Problem 2), where the resulting System (5) would be infeasible: Alice is too far away and cannot walk fast enough; she will miss the train by at least 3 minutes.

**Problem 2.**

Alice’s train departs in 75 minutes. She lives 8 km away from the station and plans to walk, and she needs 30 minutes to get ready. Furthermore, she cannot maintain an average speed faster than $\frac{10 \text{ km}}{\text{h}}$. How fast must she walk to the station to catch the train?

$$\begin{aligned} \text{minimize} &: x \\ 
\text{subject to} &: 30 \text{ min} + \frac{8 \text{ km}}{x} \leq 75 \text{ min} \\ 
& x \leq \frac{10 \text{ km}}{\text{h}}\end{aligned}$$ 

(5)

In rare cases, a model may be **unbounded**. This means that feasible solutions exist, but none are optimal because there are always better and better feasible solutions available. For example, if Alice’s goal was to go as fast as possible to catch the train, rather than as slow as possible, then neither $\frac{4 \text{ km}}{\text{h}}$, $\frac{10 \text{ km}}{\text{h}}$, $\frac{1000 \text{ km}}{\text{h}}$, nor the speed of light would be optimal solutions, because there would always be a feasible solution with a higher speed. Of course, this scenario is nonsensical. Typically, when our model turns out to be unbounded, we either made a mistake in solving it, or it does not accurately describe reality—perhaps because we omitted a real-world constraint. The latter was the case in our example because, in practice, Alice cannot walk as fast as she wishes.

We can also call the set of feasible solutions of the model the **search space**, emphasizing that our actual goal in optimization is to maximize or minimize an objective function value over that set. If all the variables are treated together as a mathematical vector, each solution can be considered a point in that vector space. The set of all feasible solutions is a set of points in space that may have special properties. For instance, in LP problems, it is a convex polytope. Constraints (and bounds) are used to define the search space. Each constraint may exclude some values, making them no longer feasible within the search space.

It may appear that a constraint does not exclude any solutions from the search space at all. We call those constraints **redundant**. Note that redundant constraints do not affect the model's solutions and therefore do not change the optimal solution, but they might affect the solution procedure itself, either positively or negatively. We may also refer to constraints as redundant if they do exclude some solutions, but only those that are not interesting to us (for example, because they cannot be optimal for some reason and will not be reported by the solution algorithm anyway).

Now, let's look at a slightly more elaborate example of an optimization problem.



**Problem 3.**

A company wants to design a new type of chocolate in the form of a rectangular block of uniform material. They want the block to contain as much mass as possible; however, shipping regulations limit the size of the block's faces. One face must have an area no greater than $6 \text{ cm}^2$, another face cannot be greater than $8 \text{ cm}^2$, and the largest face cannot be greater than $12 \text{ cm}^2$. What is the greatest possible mass for a piece of chocolate?

This example could be part of a business decision-making problem. The company aims to maximize its profit but must find a suitable solution for production. Operations Research assists in decision-making, for instance, through optimization models.

In this case, defining the variables isn't even straightforward. Though not explicitly mentioned in the problem description, the three edge lengths of the block—say, $x$, $y$, and $z$—are appropriate variables for the following reasons. First, using these lengths, we can easily express the other quantities specified in the problem: $xy$, $xz$, and $yz$ are the face areas, and $xyz$ is the total volume, which is to be maximized. Note that if the chocolate is homogeneous, volume is proportional to mass, so maximizing volume is equivalent to maximizing mass. Second, $x$, $y$, and $z$ are independent of one another: selecting $x$ does not directly affect the selection of $y$, as all possible combinations can form a block. If they were not independent, additional constraints would need to be formalized.

The most important requirement for a set of variables is that if $x$, $y$, and $z$ are given, the solution to the real-world problem is well-defined. That is, we can accurately determine whether the constraints are satisfied and what the objective value is. Now, let's express the three face area constraints and the volume objective to formulate the optimization model. Note that $x$, $y$, and $z$ should also be positive, but these bounds will be implicitly enforced by an optimal solution of the model.

$$\begin{aligned} \text{maximize} &: xyz \\ 
\text{subject to} &: xy \leq 6 \text{ cm}^2 \\ 
& xz \leq 8 \text{ cm}^2 \\ 
& yz \leq 12 \text{ cm}^2 \\ 
& x, y, z \geq 0\end{aligned}$$ 

(6)

There are many feasible solutions for this model; for example, $x = y = z = 2 \text{ cm}$ is feasible, but $x = y = z = 2.5 \text{ cm}$ is infeasible. There is a single optimal solution, which is $x = 2 \text{ cm}$, $y = 3 \text{ cm}$, and $z = 4 \text{ cm}$; the total volume in this case is $24 \text{ cm}^3$.

The method for finding this optimal solution and unequivocally proving its optimality is non-trivial and beyond the scope of this tutorial. Here’s a hint, if you wish to solve it: $(xyz)^2 = (xy) \cdot (xz) \cdot (yz)$.

---

## 2.4 Mathematical Programming

We've examined two very simple optimization problems so far. However, for the second one, we would have trouble if we had to actually solve it and prove that our solution is indeed optimal.

The key idea of mathematical programming is that **we are not the ones who actually solve the models**. We are the ones who translate the real-world problem into an optimization model; then, software specifically designed for solving models typically does the heavy lifting for us. Finally, we only need to verify that the model's solution is suitable for the real-world problem.

A mathematical programming model consists of the **model variables** that represent our freedom of choice, the **constraints** that express the requirements for a solution to be feasible and suitable for the real-world problem, and finally, the **objective function**, which determines the criteria for finding the best among the feasible solutions.

Although the general concept is that we are only formulating a model, we still need to be careful about which class of model we choose. The main reason is that the class greatly affects the available solution methods. Solving a model from a more specialized class, as opposed to a more general one, can be drastically cheaper in terms of computational effort. We explicitly mention two model classes that are highly important in Operations Research.



In **Linear Programming (LP)** models, the variables can take arbitrary real values. The constraints are equations or non-strict inequalities involving **linear expressions** of the variables. A linear expression is the sum of variables, each multiplied by a constant. Linear expressions cannot contain multiplication or division of variables with each other, or any other mathematical functions or operations: only addition, subtraction, and multiplication by a constant are allowed. The objective function itself must be a linear expression of the variables, the minimization or maximization of which is the optimization goal. The following is an example of an LP problem:

$$\begin{aligned} \text{minimize} &: 3x + 4y - z \\ 
\text{subject to} &: 2x + 5 = z + 2 \\ 
& x - y \leq 0 \\ 
& x + y + z \leq 2 (x + y) \\ 
& x, y, z \geq 0\end{aligned}$$ 

(7)

An important point about LP models is that only non-strict constraints are allowed ($\leq$, $\geq$, or $=$), while strict constraints ($<$, $>$ ) are not. Also, note that Problem 1 about Alice is formulated as an LP model, while Problem 3 about the chocolate blocks is **not** an LP because it contains a product of variables ($xyz$), which is a nonlinear term.

An LP model is solvable in polynomial time based on the number of constraints and variables. This means large models can be formulated and solved in an acceptable amount of time using a modern computer. LP problems have several interesting properties that make them solvable with efficient algorithms, for example, the Simplex Method (see Chapter 8). One such property is that the set of feasible solutions in space is always a closed, convex set.

In **Mixed-Integer Linear Programming (MILP)** models, we may also require some variables to only take integer values in feasible solutions, contrary to LP problems. This difference makes solving the generally broader class of MILP models an **NP-complete problem** regarding the number of integer variables. This means that if there are many integer variables in an MILP model, we generally cannot expect a complete solution in an acceptable amount of computational time. However, the number of applications that MILP models can cover is surprisingly much wider than for LP problems, making MILP models a popular method for solving complex optimization problems. Effective software tools utilizing heuristic algorithms often solve non-complex MILP models very quickly.

In this manual, we focus on MILP and LP models. In both cases, only linear expressions of the variables appear in the formulations. There are other problem classes, such as Nonlinear Programming (NLP) and Mixed-Integer Nonlinear Programming (MINLP), with corresponding solvers, but these are not covered here.