
----

# Chapter 9: Summary

We have explored the capabilities of the **GNU MathProg modeling language** through various examples. This included solving linear equation systems, the production and diet problems (along with their common extensions), the transportation problem, various general cost functions, and integer programming techniques applied to common optimization problems.

**Mathematical programming** generally offers a simple, practical solution for the types of problems it is designed to handle. While **$\text{MILP}$** models cover a much wider range of scenarios than their purely **$\text{LP}$** counterparts, both problem classes are useful in their own right.

Gaining expertise in GNU MathProg provides us with a **unique tool** for solving complex optimization problems. Although the solution speed might not be the absolute fastest for every specific problem, the **ease of implementation**, **maintenance**, and **adaptability to changes** in the problem definition make this methodology highly valuable for both industrial and scientific applications.

Typically, you develop a single **model file** to handle all instances of a problem, while the specific data for each instance is stored in separate **data files**. The **glpsol** solver can parse the language and solve the model in a single run, and it can also generate user-defined output.

We also provided insight into how $\text{LP}$ models are solved using the **Simplex Method** and introduced one technique for integer programming: the **Gomory cut**. These serve only as an introduction to how $\text{LP}/\text{MILP}$ solver software operates in the background. While we can often treat solvers as **black boxes**, having a basic understanding of them is useful for developing and improving mathematical programming models, as well as interpreting their results.

Note that there are many approaches beyond the primary workflow demonstrated in this tutorial. Here are a few concluding points:

* The GNU MathProg language and a parser/solver like glpsol can be used alone to develop and solve models, but the GLPK software kit offers **other features**, most notably a **callable library**. Accessing linear programming tools directly from a programming language is often better in the long run than relying on standalone GNU MathProg model files. For instance, you cannot "change" the value of a parameter within GNU MathProg logic, which limits your ability to process input data dynamically.
* We only briefly touched on the different **configurations** of the glpsol solver in this tutorial. Applying the appropriate **heuristics** or **alternative solution methods** can significantly speed up the search.
* While the glpsol solver is an easy-to-use tool, it is likely **not the fastest** $\text{LP}/\text{MILP}$ solver available. Other free solvers, such as **$\text{CBC}$** [7] or **$\text{lpsolve}$** [8], may be superior if performance is a concern. **Commercial $\text{MILP}$ solvers** can be significantly faster. You can still use these alternative solvers with GNU MathProg models because glpsol supports exporting models into well-known formats.
* GNU MathProg is **not the only language** for linear programming. There are dozens of other languages, each supporting its own class of models, input/output formats, and solvers.
* **$\text{LP}$ and $\text{MILP}$ are not the only mathematical programming problem classes** with general-purpose solvers. If you need specific **nonlinear objectives and constraints** to model a situation, you might try developing a **Nonlinear or Mixed-Integer Nonlinear Programming ($\text{NLP}$ or $\text{MINLP}$)** model in an appropriate environment. Just remember that more general tools can be much more costly in terms of running time.
* Mathematical programming is a powerful tool, but some problems have **much more effective algorithmic solutions**. Sometimes, writing a specific algorithm yields better results, though it often requires more coding effort.
* Throughout this tutorial, we solved models **in their entirety** to get a final answer. Generally, however, mathematical programming tools can be used as **part of a larger algorithmic framework**. For example, a large problem can be **decomposed** into several different models that are solved separately or sequentially. Alternatively, an $\text{LP}/\text{MILP}$ model can serve as a **relaxation** for a more complex optimization problem, providing a **bound** for its objective function.

We hope you find this tutorial helpful and motivating as you tackle real-life optimization problems in the future.