-----------------------
Chapter 5

Production problem
In this chapter, a fundamental LP problem is explored, in terms of model implementation. This
is the production problem: determining which products we shall fabricate to obtain the most
profit, if our resources are limited. It is also called product mix problem, or production planning
problem. The production problem is one of the oldest problems in Operations Research, plenty of
alternative tutorials use it as introduction to mathematical programming (see for example [11, 12]).
The diet problem is also presented, where the least expensive food mix shall be found to support
all nutrient needs. The two problems can have a common generalization which is also shown. A
lookout into integer programming is also presented in the final section, where „packages” of raw
materials and products can be bought and sold at once.
The chapter focuses on how a single model can be extended to incorporate various circumstances
one-by-one. We start from a common exercise that can even be done by hand, and finally arrive at
a very general and complex optimization model.

5.1

Basic production problem

The simplest case of the production problem can be described as follows, in general.
 
Problem 8.
Given a set of products, and a set of raw materials needed for them. Production is linear and
can be done in any amount, with consumption rates of raw materials given: we know how much of
each raw material is consumed to produce 1 unit of each product. We have a fixed amount of each
raw material available, and a fixed unit revenue for each product.
Determine the optimal amounts of all products to be made, so that we do not consume more of
each raw material than available, and the total revenue from all products is maximized.
This above definition can be a bit difficult to understand. This actually correspond only to the
model logic, and will be implemented in a model file. However, let us see a particular example for
the production problem, with the data supported.

Problem 9.
We have a manufacturing plant, which is capable of producing three different products, named
P1, P2 and P3. There are four raw materials that are required for production, named A, B, C and D.
We have exact data for the following.
• Amount of each raw material required for producing 1 unit of each product.
• Available amount of each raw material that can be used for production.
43

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

• Revenue for 1 unit of each product.
These can be viewed in a single table, as shown below.

A (electricity)
B (working time)
C (materials)
D (production quota)
Revenue (per unit)

P1
200 kWh
25 h
3200 kg
1
252 $

P2
50 kWh
180 h
1000 kg
1
89 $

P3
0 kWh
75 h
4500 kg
1
139 $

Available
23000 kWh
31000 h
450000 kg
200

Note that any amounts of each product can be produced, the raw material requirements are exactly
proportional. There is no other limitation than total availability of each raw material. Amounts can
also be fractional.
Determine the optimal amount of P1, P2 and P3 to be produced, so that raw material availability
is respected, and the total revenue after products is maximized.
(Note that problem data are entirely fictional.)
Note that compared to „pure mathematical” models as the system of linear equations we have
seen before, there are units in the problem data. However, GNU MathProg does not have a builtin feature to remember the quantities, currencies of model elements (variables, parameters, constraints). We have to work with scalars only. The general approach of handling units is that data
corresponding to the same quantity are converted to the same unit, and treated consistently in the
whole model. This must always be kept in mind during model formulation.
However, understanding the units in the problem is recommended, because it helps us evading
mistakes, by remembering that only scalars of the same unit shall be added together at any time.
For example, amounts of kW h and kg cannot be added. Then, either adding them is wrong at all,
or we are missing one or more factors that will bring these quantities to the same dimension and
same unit.
Now let us start formulating the model. The first step is the selection of the decision variables.
The goal of optimization is to determine the values of these decision variables. Each solution obtained
describes a decision of how the plan will be operated. Of course, generally not all solutions are be
feasible, and the revenues are also generally different. Therefore we look for the feasible solution
with the highest revenue.
The decision variables can be directly read from the problem text. The amounts of each product
to be determined are the decision variables, these must definitely be determined by the optimization.
The question arises, whether there shall be more variables or not? If we only know the amounts
produced, we can calculate everything in the plant which is relevant now: the exact amounts
consumed of each raw material, and the total revenue. So, at this point, we do not need any
more variables in our optimization model.
The objective function can be easily determined. The amounts of production each must be
multiplied by the unit revenue for that product, and the total revenue is the sum of such products.
What remains are the constraints, and variable bounds. In general, what we only need is
that a production can be zero, or a positive number. But, it definitely cannot be negative. So each
variable shall be nonnegative, this is a lower bound. There is no upper bound, as any production
amount is considered feasible as long as there is sufficient raw material for it. And here we arrived
to the only constraint, which is about raw material availability. Based on the amounts produced
(these are denoted by the variables), we can easily calculate how much of each raw material is used
per product, and in total. These must not be greater than the availability of each particular raw
material.
44

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

We defined the variables, the objective, constraints and bounds, so we are ready to implement our
model in GNU MathProg. First, we do not apply indexing, and work with the most straightforward
way.
The variables denote production amounts. For convention, these are all in $ currency.
var P1, >=0;
var P2, >=0;
var P3, >=0;
Constraints are formulated next. For each production amount, it must be multiplied by the
coefficient that describes raw material consumption per product unit. These shall be added for all
three products to obtain the total consumption for a given raw material.
Note how the tabular data of the problem correspond to the implementation of constraints.
s.t. Raw_material_A: 200 * P1 +
50 * P2 +
0 * P3 <= 23000;
s.t. Raw_material_B:
25 * P1 + 180 * P2 +
50 * P3 <= 31000;
s.t. Raw_material_C: 3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:
1 * P1 +
1 * P2 +
1 * P3 <= 200;
Finally, the objective can be defined based on production amounts as well. Note that each
constraint is within its own unit for the raw material, and the objective is in $ unit. From now on,
we use units consistently and do not refer to them.
maximize Raw_material: 252 * P1 +

89 * P2 +

139 * P3;

A solve statement can be inserted in the model, after which some additional post-processing
work can be done to print out the solution. The full code is the following. We print the total
revenue (the objective), the production of each products (the variables), and the usage of each raw
material. In the usage part, we print both the total amount consumed for production, and the
amount remained available.
var P1, >=0;
var P2, >=0;
var P3, >=0;
s.t. Raw_material_A: 200 * P1 +
50 * P2 +
0 * P3 <= 23000;
s.t. Raw_material_B:
25 * P1 + 180 * P2 +
50 * P3 <= 31000;
s.t. Raw_material_C: 3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:
1 * P1 +
1 * P2 +
1 * P3 <= 200;
maximize Raw_material: 252 * P1 +

89 * P2 +

139 * P3;

solve;
printf "Total Revenue: %g\n", ( 252 * P1 +
printf "Production of P1: %g\n", P1;
printf "Production of P2: %g\n", P2;
printf "Production of P3: %g\n", P3;
printf "Usage of A: %g, remaining: %g\n",

45

89 * P2 +

139 * P3);

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

( 200 * P1 +
50 * P2 +
0 * P3),
23000 - ( 200 * P1 +
50 * P2 +
0 * P3);
printf "Usage of B: %g, remaining: %g\n",
( 25 * P1 + 180 * P2 +
75 * P3),
31000 - ( 25 * P1 + 180 * P2 +
75 * P3);
printf "Usage of C: %g, remaining: %g\n",
(3200 * P1 + 1000 * P2 + 4500 * P3),
450000 - (3200 * P1 + 1000 * P2 + 4500 * P3);
printf "Usage of D: %g, remaining: %g\n",
(
1 * P1 +
1 * P2 +
1 * P3),
200
- (
1 * P1 +
1 * P2 +
1 * P3);
end;
In this model file, there is no data section at all, data is hard-coded into the model. Therefore we
can solve it with glpsol without providing any additional data files, and by doing so the following
result is obtained. Only our own printf results are shown here.
Total Revenue: 33389
Production of P1: 91.3386
Production of P2: 94.6457
Production of P3: 14.0157
Usage of A: 23000, remaining: -3.63798e-12
Usage of B: 20370.9, remaining: 10629.1
Usage of C: 450000, remaining: -5.82077e-11
Usage of D: 200, remaining: 0
We interpret the solutions as follows. It turns out that 33389 is the maximal revenue that can be
obtained. The method of obtaining this revenue is that 91.34, 94.65 and 14.02 units of P1, P2 and P3
must be produced. Note that, in this case it is allowed to produce fractional amounts of a product –
this can be the case in practice for example if the products and raw materials are chemicals, fluids,
heat, electricity or other quantity that can be divided.
Production consumes all of A, C and D, but there is a surplus of B which is not used up. Some
remaining amounts are reported to be extremely small positive numbers. These are actually small
numerical errors from the actual value of zero in the optimal solution, because glpsol uses floatingpoint arithmetic and it is not perfect. If this output is inconvenient, we may use the format specifier
%f instead of %g, or alternatively, round down the numbers to be printed explicitly in the model
with the built-in floor() function.
Another option is to add --xcheck as command line argument to glpsol. This forces the final
solution to be recalculated with exact arithmetic, eliminating rounding errors.
glpsol -m model.mod -d data.dat --xcheck
One interesting thing about the solution is that three of the remaining amounts are zero. If
we varied the problem data and solve the model again and again, it would turn out that from
the seven values printed (three production amounts and four remaining amounts), there are almost
always three zeroes. In general, the number of zeroes is the number of products, and the number
of nonzeroes is the number of raw materials. (Exceptions arise in some special cases.) This is a
beautiful property of production problems that is better understood if we know how the solution
algorithms (particularly the simplex method) work, generally for LP problems. However, we do not

46

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

focus on the algorithms here, only the model implementations. Nevertheless, understanding of how
a good solution looks like is a very valuable skill.
We now have a working implementation for the particular production problem described. However, we know that this solution is not very general. If another production problem is in question,
we must understand and tamper with the code describing the model logic. Also note that the exact
expressions describing the total consumption of each raw material is appearing three times: once
in the constraints, and twice in the post-processing work. This level of redundancy is usually bad
code design, regardless of programming language.
Our next task is a more general, indexed model, which requires only a properly formatted data
section to solve any production problems.
In the production problem, there are two sets that are in question, these are the set of products
and the set of raw materials.
set Products;
set Raw_Materials;
We can also identify three important parameters. One for the ratios of production, this is defined
for each pairs of raw materials and products, we will call it Consumption_Rate. One parameter is
for availability. This is defined for each raw material, we name it Storage. The name „storage”
captures the logic of how raw materials work in the modeling point of view: they are present in a
given amount beforehand, like physically stored material, then no more than this amount can be
used up for production. Another parameter is the Revenue, which is defined for each product.
param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
Notice how indexing is used so that each param statement refer to not only a single scalar, but
a collection of values instead. For the Consumption_Rate and Revenue, we also provide a default
value of zero. That means if we do not provide data, then we assume no raw material need or
revenue for that particular case.
Also, in GNU MathProg, we are able to define bounds and other value restrictions for parameters.
In this case, all three parameters are forced to be nonnegative, by the >=0 restriction. This is
generally a good practice if we do not except specific values for a given parameter. If a restriction
is violated by a value given for the parameter (for example, in the data section, or calculated on
spot), then model processing terminates with an error describing the exact situation. It is much
easier to notice and correct errors in this case, than allowing a wrong parameter value in the model,
which can be solvable to an invalid solution. It is generally difficult to debug a model once it can
be processed, so it is recommended to explicitly check data as much as possible.
The variables can be defined now. They denote production amounts, and each are nonnegative.
var production {p in Products}, >=0;
Finally, all the constraints can be described by one general s.t. statement. The logic is the
following. There is a single inequality for each raw material: its total consumption cannot exceed
its availability. The availability is simply described as a parameter, but the total consumption is
obtained by a summation. We must sum, for each product, its amount multiplied by the consumption
rate of that particular raw material.

47

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

s.t. Material_Balance {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p]
<= Storage[r];
The objective is obtained as a sum for all products, the amounts must be multiplied by the unit
revenues.
maximize Total_Revenue:
sum {p in Products} Revenue[p] * production[p];
Finally, we can implement a general post-processing work to print the total revenue, production
amounts and raw material usages. The full model file is the following.
set Products;
set Raw_Materials;
param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
var production {p in Products}, >=0;
s.t. Material_Balance {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p]
<= Storage[r];
maximize Total_Revenue: sum {p in Products} Revenue[p] * production[p];
solve;
printf "Total Revenue: %g\n", sum {p in Products} Revenue[p] * production[p];
for {p in Products}
{
printf "Production of %s: %g\n", p, production[p];
}
for {r in Raw_Materials}
{
printf "Usage of %s: %g, remaining: %g\n",
r, sum {p in Products} Consumption_Rate[r,p] * production[p],
Storage[r] - sum {p in Products} Consumption_Rate[r,p] * production[p];
}
end;
If the corresponding data file is implemented as follows, we should get the same result as for the
straightforward implementation.

48

5.1. BASIC PRODUCTION PROBLEM

PRODUCTION PROBLEM

data;
set Products := P1 P2 P3;
set Raw_Materials := A B C D;
param Storage :=
A 23000
B 31000
C 450000
D 200
;
param Consumption_Rate:
P1
P2
P3 :=
A
200
50
0
B
25
180
75
C 3200 1000 4500
D
1
1
1
;
param Revenue :=
P1 252
P2 89
P3 139
;
end;
Although the model is very general and compact, it still contains some redundancy. The total
consumed amount of each raw material is still represented three times in the code. At least, we do
not have to rewrite that code ever again if another problem data is given, we only have to modify
the data section. However, we still want to eliminate this redundancy.
Remember that we can introduce parameters in the model section and calculate values on spot.
If we are after the solve statement, then even variable values can be referred to, as their values are
already determined by the solver. We introduce Material_Consumed and Material_Remained to
denote the total amount consumed, and remained, for each material.
param Material_Consumed {r in Raw_Materials} :=
sum {p in Products} Consumption_Rate[r,p] * production[p];
param Material_Remained {r in Raw_Materials} :=
Storage[r] - Material_Consumed[r];
for {p in Products}
{
printf "Production of %s: %g\n", p, production[p];
}
for {r in Raw_Materials}
{
printf "Usage of %s: %g, remaining: %g\n",

49

5.2. INTRODUCING LIMITS

}

PRODUCTION PROBLEM

r, Material_Consumed[r], Material_Remained[r];

The solution shall be exactly the same as before again, for the same data file. But now, some
of the redundancy is eliminated from the model section. Unfortunately, the parameter for the total
amounts consumed cannot be used in the constraints where it appears first. More on that later.

5.2

Introducing limits

Now that we have a working implementation for arbitrary production problems, let us change the
problem description itself.
