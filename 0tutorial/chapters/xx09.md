

# Chapter 5

### Production Problem

This chapter explores a **fundamental Linear Programming (LP) problem** in terms of model implementation: the **production problem**. This problem involves determining which products to manufacture in order to achieve the **maximum profit** when resources are limited. It is also referred to as the **product mix problem** or **production planning problem**.

The production problem is one of the oldest problems in **Operations Research**, and numerous tutorials use it as an introduction to mathematical programming (see, for example, [11, 12]). The **diet problem**, which seeks to find the least expensive combination of foods that meets all nutritional requirements, is also presented. A common generalization of these two problems is also shown. The final section includes an overview of **integer programming**, where "packages" of raw materials and products can be bought and sold all at once.

The chapter focuses on how a single model can be extended to incorporate various circumstances one-by-one. We begin with a simple exercise that can even be solved manually and conclude with a very general and complex optimization model.

-----

### 5.1 Basic Production Problem

The simplest version of the production problem can be generally described as follows.

#### Problem 8.

Given a set of **products** and a set of **raw materials** needed for their production. Production is linear and can occur in any amount, with fixed **consumption rates** of raw materials: we know exactly how much of each raw material is consumed to produce **one unit** of each product. We have a fixed amount of each raw material available and a fixed unit revenue for each product.

**Determine the optimal amounts of all products to be manufactured** such that the consumption of each raw material does not exceed its availability, and the **total revenue** from all products is maximized.

This definition might be a little challenging to grasp. It primarily outlines the **model logic** and will be implemented in a model file. Let's look at a specific example of the production problem with supporting data.

#### Problem 9.

We have a manufacturing plant capable of producing three different products, named **P1, P2, and P3**. Four raw materials are required for production, named **A, B, C, and D**. We have precise data for the following:

  * Amount of each raw material required for producing 1 unit of each product.
  * Available amount of each raw material that can be used for production.
  * Revenue for 1 unit of each product.

This information can be viewed in a single table, as shown below.

| | **P1** | **P2** | **P3** | **Available** |
| :--- | :--- | :--- | :--- | :--- |
| **A** (electricity) | 200 kWh | 50 kWh | 0 kWh | 23000 kWh |
| **B** (working time) | 25 h | 180 h | 75 h | 31000 h |
| **C** (materials) | 3200 kg | 1000 kg | 4500 kg | 450000 kg |
| **D** (production quota) | 1 | 1 | 1 | 200 |
| **Revenue (per unit)** | **$252** | **$89** | **$139** | |

Note that any amount of each product can be produced, and the raw material requirements are **exactly proportional**. There is no other limitation than the **total availability** of each raw material. Amounts can also be fractional.

**Determine the optimal amount of P1, P2, and P3 to be produced** such that raw material availability is respected, and the total revenue from the products is maximized.

(Note that problem data are entirely fictional.)

Compared to "pure mathematical" models like the system of linear equations we saw previously, the problem data here includes **units**. However, **GNU MathProg** does not have a built-in feature to track the quantities or currencies of model elements (variables, parameters, constraints). We must work only with **scalars**. The general approach for handling units is to convert all data corresponding to the same quantity to the **same unit** and treat them consistently throughout the model. This must always be kept in mind during model formulation.

However, understanding the units in the problem is recommended because it helps us avoid mistakes by reminding us that **only scalars of the same unit should ever be added together**. For example, amounts in kWh and kg cannot be added. If adding them appears necessary, it means either the operation is wrong entirely, or we are missing one or more factors that would bring these quantities to the same dimension and unit.

Let's begin formulating the model. The first step is selecting the **decision variables**. The goal of optimization is to determine the values of these variables. Each solution obtained describes a decision on how the plant will be operated. Of course, not all solutions are generally feasible, and the revenues are also usually different. Therefore, we seek the **feasible solution with the highest revenue**.

The decision variables can be read directly from the problem description. The **amounts of each product to be determined** are the decision variables; these must definitely be determined by the optimization. The question is, should there be more variables? If we only know the amounts produced, we can calculate everything relevant in the plant: the exact amounts consumed of each raw material and the total revenue. Therefore, at this point, we do not need any more variables in our optimization model.

The **objective function** is easy to determine. The production amount of each product must be multiplied by its **unit revenue**, and the total revenue is the sum of these products.

What remains are the **constraints** and **variable bounds**. In general, the only requirement is that production can be zero or a positive number, but it definitely **cannot be negative**. So, each variable must be **nonnegative**; this is a **lower bound**. There is no upper bound, as any production amount is considered feasible as long as there is sufficient raw material for it. This brings us to the **only constraint**, which is about **raw material availability**. Based on the amounts produced (which are denoted by the variables), we can easily calculate how much of each raw material is used per product and in total. This total usage must not be greater than the availability of that particular raw material.

We have defined the variables, the objective, constraints, and bounds, so we are ready to implement our model in **GNU MathProg**. First, we will not use indexing and will implement it in the most straightforward way.

The variables denote production amounts. For convention, these are all in the **dollar ($)** currency.

```
var P1, >=0;
var P2, >=0;
var P3, >=0;
```

Constraints are formulated next. For each production amount, it must be multiplied by the coefficient that describes **raw material consumption per product unit**. These must be summed for all three products to obtain the total consumption for a given raw material.

Note how the tabular data of the problem correspond to the implementation of constraints.

```
s.t. Raw_material_A: 200 * P1 +
50 * P2 +
0 * P3 <= 23000;
s.t. Raw_material_B:
25 * P1 + 180 * P2 +
75 * P3 <= 31000;
s.t. Raw_material_C: 3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:
1 * P1 +
1 * P2 +
1 * P3 <= 200;
```

Finally, the objective can also be defined based on production amounts. Note that each constraint is within its own unit for the raw material, and the objective is in the **$** unit. From now on, we use units consistently and will not refer to them.

```
maximize Raw_material: 252 * P1 +

89 * P2 +

139 * P3;
```

A `solve` statement can be inserted in the model, after which some additional post-processing work can be done to print the solution. The full code is the following. We print the total revenue (the objective), the production of each product (the variables), and the usage of each raw material. In the usage part, we print both the total amount consumed for production and the amount remaining available.

```
var P1, >=0;
var P2, >=0;
var P3, >=0;
s.t. Raw_material_A: 200 * P1 +
50 * P2 +
0 * P3 <= 23000;
s.t. Raw_material_B:
25 * P1 + 180 * P2 +
75 * P3 <= 31000;
s.t. Raw_material_C: 3200 * P1 + 1000 * P2 + 4500 * P3 <= 450000;
s.t. Raw_material_D:
1 * P1 +
1 * P2 +
1 * P3 <= 200;
maximize Raw_material: 252 * P1 +

89 * P2 +

139 * P3;

solve;
printf "Total Revenue: %g\n", ( 252 * P1 +
printf "Production of P1: %g\n", P1;
printf "Production of P2: %g\n", P2;
printf "Production of P3: %g\n", P3;
printf "Usage of A: %g, remaining: %g\n",

89 * P2 +

139 * P3);

( 200 * P1 +
50 * P2 +
0 * P3),
23000 - ( 200 * P1 +
50 * P2 +
0 * P3);
printf "Usage of B: %g, remaining: %g\n",
( 25 * P1 + 180 * P2 +
75 * P3),
31000 - ( 25 * P1 + 180 * P2 +
75 * P3);
printf "Usage of C: %g, remaining: %g\n",
(3200 * P1 + 1000 * P2 + 4500 * P3),
450000 - (3200 * P1 + 1000 * P2 + 4500 * P3);
printf "Usage of D: %g, remaining: %g\n",
(
1 * P1 +
1 * P2 +
1 * P3),
200
- (
1 * P1 +
1 * P2 +
1 * P3);
end;
```

In this model file, there is **no data section at all**; the data is **hard-coded** into the model. Therefore, we can solve it with `glpsol` without providing any additional data files, yielding the following result (showing only our `printf` results).

```
Total Revenue: 33389
Production of P1: 91.3386
Production of P2: 94.6457
Production of P3: 14.0157
Usage of A: 23000, remaining: -3.63798e-12
Usage of B: 20370.9, remaining: 10629.1
Usage of C: 450000, remaining: -5.82077e-11
Usage of D: 200, remaining: 0
```

We interpret the solutions as follows: **$33,389** is the **maximum revenue** that can be obtained. The way to obtain this revenue is to produce **91.34 units of P1**, **94.65 units of P2**, and **14.02 units of P3**. Note that, in this case, it is allowed to produce **fractional amounts** of a productâ€”this can occur in practice, for example, if the products and raw materials are chemicals, fluids, heat, electricity, or other divisible quantities.

Production consumes **all of A, C, and D**, but there is a **surplus of B** that is not used up. Some remaining amounts are reported as extremely small positive numbers. These are actually tiny **numerical errors** from the actual value of zero in the optimal solution because `glpsol` uses floating-point arithmetic, which is not perfect. If this output is inconvenient, we can use the format specifier `%f` instead of `%g`, or alternatively, explicitly round down the numbers to be printed in the model using the built-in `floor()` function.

Another option is to add `--xcheck` as a command-line argument to `glpsol`. This forces the final solution to be recalculated with **exact arithmetic**, eliminating rounding errors.

```
glpsol -m model.mod -d data.dat --xcheck
```

One interesting observation about the solution is that **three of the remaining amounts are zero**. If we varied the problem data and solved the model repeatedly, it would turn out that, from the seven values printed (three production amounts and four remaining amounts), there are almost always **three zeroes**. In general, the number of zeroes is the number of products, and the number of nonzeroes is the number of raw materials. (Exceptions occur in some special cases.) This is a beautiful property of production problems that is better understood by knowing how the solution algorithms (particularly the **simplex method**) work, generally for LP problems. However, we are not focusing on the algorithms here, only the model implementations. Nevertheless, understanding what a good solution looks like is a very valuable skill.

We now have a working implementation for the particular production problem described. However, we know this solution is not very general. If a different production problem is in question, we must understand and **tamper with the code** describing the model logic. Also note that the exact expressions describing the total consumption of each raw material appear **three times**: once in the constraints and twice in the post-processing work. This level of **redundancy** is typically considered bad code design, regardless of the programming language.

Our next task is to create a more general, **indexed model** that requires only a properly formatted data section to solve any production problem.

In the production problem, two sets are relevant: the set of **products** and the set of **raw materials**.

```
set Products;
set Raw_Materials;
```

We can also identify three important **parameters**. One for the production ratios, which is defined for each pair of raw materials and products; we'll call it `Consumption_Rate`. One parameter is for availability. This is defined for each raw material, and we name it `Storage`. The name "storage" captures the logic of how raw materials work from a modeling perspective: they are present in a given amount beforehand, like physically stored material, and no more than this amount can be used for production. Another parameter is the `Revenue`, which is defined for each product.

```
param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
```

Notice how **indexing** is used so that each `param` statement refers not just to a single scalar but to a **collection of values** instead. For `Consumption_Rate` and `Revenue`, we also provide a default value of **zero**. This means if we do not provide data, we assume no raw material need or revenue for that particular case.

Also, in GNU MathProg, we can define **bounds and other value restrictions for parameters**. In this case, all three parameters are forced to be **nonnegative** by the `>=0` restriction. This is generally good practice if we do not expect specific values for a given parameter. If a restriction is violated by a value provided for the parameter (for example, in the data section or calculated on the spot), model processing terminates with an error describing the exact situation. It's much easier to notice and correct errors this way than to allow a wrong parameter value in the model, which could lead to an invalid solution. It is typically difficult to debug a model once it can be processed, so it is recommended to explicitly check data as much as possible.

The variables can now be defined. They denote production amounts, and each must be nonnegative.

```
var production {p in Products}, >=0;
```

Finally, all the constraints can be described by one general `s.t.` statement. The logic is as follows: There is a single inequality for each raw material: its **total consumption cannot exceed its availability**. The availability is simply described as a parameter, but the total consumption is obtained by a **summation**. We must sum, for each product, its amount multiplied by the consumption rate of that particular raw material.

$$
\sum_{p \in \text{Products}} \text{Consumption\_Rate}[r,p] \cdot \text{production}[p] \le \text{Storage}[r]
$$

```
s.t. Material_Balance {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p]
<= Storage[r];
```

The objective is obtained as a **sum** for all products, where the amounts must be multiplied by the unit revenues.

$$
\text{Maximize Total\_Revenue} = \sum_{p \in \text{Products}} \text{Revenue}[p] \cdot \text{production}[p]
$$

```
maximize Total_Revenue:
sum {p in Products} Revenue[p] * production[p];
```

Finally, we can implement a general post-processing routine to print the total revenue, production amounts, and raw material usages. The full model file is the following.

```
set Products;
set Raw_Materials;
param Storage {r in Raw_Materials}, >=0;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
var production {p in Products}, >=0;
s.t. Material_Balance {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p]
<= Storage[r];
maximize Total_Revenue: sum {p in Products} Revenue[p] * production[p];
solve;
printf "Total Revenue: %g\n", sum {p in Products} Revenue[p] * production[p];
for {p in Products}
{
printf "Production of %s: %g\n", p, production[p];
}
for {r in Raw_Materials}
{
printf "Usage of %s: %g, remaining: %g\n",
r, sum {p in Products} Consumption_Rate[r,p] * production[p],
Storage[r] - sum {p in Products} Consumption_Rate[r,p] * production[p];
}
end;
```

If the corresponding data file is implemented as follows, we should get the same result as with the straightforward implementation.

```
data;
set Products := P1 P2 P3;
set Raw_Materials := A B C D;
param Storage :=
A 23000
B 31000
C 450000
D 200
;
param Consumption_Rate:
P1
P2
P3 :=
A
200
50
0
B
25
180
75
C 3200 1000 4500
D
1
1
1
;
param Revenue :=
P1 252
P2 89
P3 139
;
end;
```

Although the model is very general and compact, it still contains some **redundancy**. The total consumed amount of each raw material is still represented three times in the code. At least, we do not have to rewrite that code ever again if another problem's data is given; we only have to modify the data section. However, we still want to eliminate this redundancy.

Remember that we can introduce parameters in the model section and calculate values on the spot. If we are after the `solve` statement, then even variable values can be referred to, as their values have already been determined by the solver. We introduce `Material_Consumed` and `Material_Remained` to denote the total amount consumed and the amount remaining for each material.

```
param Material_Consumed {r in Raw_Materials} :=
sum {p in Products} Consumption_Rate[r,p] * production[p];
param Material_Remained {r in Raw_Materials} :=
Storage[r] - Material_Consumed[r];
for {p in Products}
{
printf "Production of %s: %g\n", p, production[p];
}
for {r in Raw_Materials}
{
printf "Usage of %s: %g, remaining: %g\n",
r, Material_Consumed[r], Material_Remained[r];
}
```

The solution should be exactly the same as before again, for the same data file. But now, some of the redundancy has been eliminated from the model section. Unfortunately, the parameter for the total amounts consumed **cannot be used** in the constraints where it appears first. More on that later.

-----

### 5.2 Introducing Limits

Now that we have a working implementation for arbitrary production problems, let's change the problem description itself.

-----

I've rephrased the text using modern American English spelling (**"maximize"** instead of "maximise," **"modeling"** instead of "modelling"), punctuation (e.g., using a **colon** before a list or example rather than an en-dash), vocabulary (e.g., **"tamper with the code"** is more common than "tamper with the code describing"), and grammar conventions while maintaining the original structure, paragraphs, and data.



