Here is the rephrased text, adapted for natural American English flow while preserving your original structure, paragraphs, and data.

-----

# Chapter 6: Transportation Problem

We'll introduce another common **optimization problem**, known as the **transportation problem**.

Given a set of **supply points** with a known amount of available resources and a set of **demand points** with a known resource requirement, the objective is to organize the transportation of the resource between these supplies and demands.

It's worth noting that this problem has very fast algorithmic solution techniques [15]. However, we're primarily focused on **modeling techniques**. As we'll see, an LP (Linear Programming) or MILP (Mixed-Integer Linear Programming) formulation can be easily adjusted if the problem definition changes. This can be significantly harder to do with specific solution algorithms.

This chapter also presents some additional capabilities of **GNU MathProg**. The goal is to demonstrate how to handle different cost functions while keeping the model within the class of LP and sometimes MILP models. Finally, we'll add an extra layer of transportation to the problem to show how separately modeled parts of a system can be incorporated into a single, cohesive model.

-----

## 6.1 Basic Transportation Problem

The basic transportation problem can be generally described as follows:

**Problem 21.**

Given a **single material**, a set of **supply points**, and a set of **demand points**. Each supply point has a nonnegative **availability**, and each demand point has a nonnegative **requirement** for the material. The material can be transported from any supply point to any demand point, in any amount. The **unit cost** for transportation is known for each specific pair. The task is to find the transportation amounts such that the following conditions are met:

  * **Available amounts** at supply points are not exceeded.
  * **Required amounts** at demand nodes are satisfied.
  * The **total transportation cost** is minimal.

For simplicity, we'll call the supply points and demand points **supplies** and **demands**. Note that the term "material" can be replaced by any other resource, such as electricity, water, funds, or manpower.

The network connecting the supplies and demands can be represented by a **directed graph** (see Figure 1), where the nodes are the supplies and demands, and the arcs represent the connections between them. The direction of an arc shows the direction of material flow, which always goes from a supply to a demand.

Similar to the production problem, we'll provide an example for the transportation problem. The following data will be used throughout this chapter.

**Problem 22.**

There are four supplies, labeled **S1** through **S4**, and six demands, labeled **D1** through **D6**. The amount of materials available at each supply, required at each demand, and the unit transportation costs between each supply-demand pair are summarized in the following table.

| | **D1** | **D2** | **D3** | **D4** | **D5** | **D6** | **Available** |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **S1** | 5 | 10 | 3 | 9 | 5 | 12 | 100 |
| **S2** | 1 | 2 | 6 | 1 | 2 | 6 | 250 |
| **S3** | 6 | 5 | 1 | 6 | 4 | 8 | 190 |
| **S4** | 9 | 10 | 6 | 8 | 9 | 7 | 210 |
| **Required** | 120 | 140 | 170 | 90 | 110 | 120 | |

(The numbers in the last row and column refer to material amounts; all other numbers refer to the cost per unit of material transported.)

The goal is to transport materials from the supplies to the demands to satisfy requirements at the **minimal cost**.

As discussed in Section 5.6, the first step in mathematical programming is to determine the appropriate **decision variables**. However, in GNU MathProg, we can start by implementing the parameters and sets for the problem data.

In this problem, there are two sets of arbitrary size: the set of **supplies** and the set of **demands**. There are three kinds of numeric parameters that define the transportation problem:

  * The **availability**, provided for each supply.
  * The **requirement**, provided for each demand.
  * The **unit transportation cost**, provided for each supply-demand pair.

Therefore, the implementation can be written as follows. Note that all parameters are specified as nonnegative to prevent incorrect data from being supplied. The names of the sets and parameters are self-explanatory.

```glp
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
param Cost {s in Supplies, D in Demands}, >=0;
```

The decisions to be made in a transportation problem are the **exact transportation amounts**. This amount must be determined for each supply-demand pair, and these decisions are independent. For example, the problem above has 4 supplies and 6 demands, meaning 24 individual decisions must be made about the amounts transported between them. Each of these decisions corresponds to a single variable in the model. Using indexing, this can be expressed in a single `var` statement. The variable name is `tran`.

```glp
var tran {s in Supplies, D in Demands}, >=0;
```

Transportation amounts must be **nonnegative**. A negative amount would model a backward transportation (i.e., from a demand to a supply). While this might be valid in some practical applications, it is explicitly prohibited here.

We can see that the transportation amounts fully describe the situation. Based on these amounts, we can easily calculate the total activity at each supply and demand node, check whether the availability and required amounts are violated, and calculate the total costs. Therefore, no additional decision variables are needed.

Now, we formulate the constraints for the model. Not all possible nonnegative real values for the transportation amounts will result in a feasible solution because there are two restrictions we must account for.

First, the total amount transported **from** a supply **cannot exceed** the availability at that supply. This is a constraint for each supply. Note that the summation is over all demands, as material can be transported to all demands from a specific supply.

```glp
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
```

Similarly, the total amount transported **to** a demand **cannot be less than** the requirement at that demand. This constraint is for each demand, and the summation is now over all supplies, as material can be transported to a specific demand from all supplies.

```glp
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
```

The **objective** is to minimize the **total cost**. Each transportation amount must be multiplied by the unit cost for that particular connection, and then summed over all connections between supplies and demands.

```glp
minimize Total_Costs:
sum {s in Supplies, d in Demands} tran[s,d] * Cost[s,d];
```

At this point, let's consider whether the problem even has a solution. Two quantities are of special interest: the **total amount of available supply**, which we'll denote as $S$, and the **total amount of required demand**, which we'll denote as $D$. There are three possible scenarios:

  * If $S < D$, the problem is **infeasible**, as there is simply not enough supply available to meet all demands.
  * If $S = D$, the problem is **feasible**, but all supply must be used, and each demand must receive exactly the required amount—no more.
  * If $S > D$, the problem is **feasible**. There can (and will) be leftover material at the supplies, excess deliveries at the demands, or both.

Without actually solving the model, we can check the problem data to ensure it's feasible. This check statement is ideally placed after the parameters but before the variable and constraint definitions. This check is useful because it provides a dedicated error message referring to the `check` statement if a problem is infeasible.

```glp
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
```

Note that in our current model formulation, we allow both leftover materials at supplies (via the $\le$ constraint) and excess deliveries at demands (via the $\ge$ constraint). If these were not allowed, the corresponding two constraints would have to be specified as equations ($\text{=}$) instead. It's worth pointing out that if the transport costs are positive, there's no benefit to transporting more than the demand requires, so the optimization process will eliminate that case anyway.

In some formulations of the transportation problem, $S = D$ is an assumption. Note that in a problem where $S > D$, we can introduce a **dummy demand** with a requirement of $S - D$ and zero transportation costs from all supplies. The purpose of this dummy demand is to receive all the leftover amounts. Therefore, this new problem is equivalent to the original one but has equal total supplies and demands. In conclusion, the $S > D$ case is essentially no more general than the $S = D$ case.

The model description for Problem 21 is now complete. The model section can be enhanced with `printf` statements to display the result once it's found. We'll only show transportation amounts that are greater than zero. The full model section is as follows:

```glp
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
param Cost {s in Supplies, D in Demands}, >=0;
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {s in Supplies, D in Demands}, >=0;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
minimize Total_Costs:
sum {s in Supplies, d in Demands} tran[s,d] * Cost[s,d];
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {s in Supplies, d in Demands: tran[s,d] > 0}
{
printf "From %s to %s, transport %g amount for %g (unit cost: %g).\n",
s, d, tran[s,d], tran[s,d] * Cost[s,d], Cost[s,d];
}
end;
```

For completeness, we also show the **data section** corresponding to **Problem 22**.

```glp
data;
set Supplies := S1 S2 S3 S4;
set Demands := D1 D2 D3 D4 D5 D6;
param Available :=
S1 100
S2 250
S3 190
S4 210
;
param Required :=
D1 120
D2 140
D3 170
D4 90
D5 110
D6 120
;
param Cost:
D1 D2 D3 D4 D5 D6 :=
S1
5 10
3
9
5 12
S2
1
2
6
1
2
6
S3
6
5
1
6
4
8
S4
9 10
6
8
9
7
;
end;
```

Solving the problem with `glpsol` yields the following result:

```
Optimal cost: 2700.
From S1 to D1, transport 10 amount for 50 (unit cost: 5).
From S1 to D5, transport 90 amount for 450 (unit cost: 5).
From S2 to D1, transport 110 amount for 110 (unit cost: 1).
From S2 to D2, transport 140 amount for 280 (unit cost: 2).
From S3 to D3, transport 170 amount for 170 (unit cost: 1).
From S3 to D5, transport 20 amount for 80 (unit cost: 4).
From S4 to D4, transport 90 amount for 720 (unit cost: 8).
From S4 to D6, transport 120 amount for 840 (unit cost: 7).
```

The results of the transportation problem can be fitted back into the original data table by substituting the unit costs with the decided transportation amounts. Zero amounts can be omitted entirely.

| | **D1** | **D2** | **D3** | **D4** | **D5** | **D6** | **Available** |
|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **S1** | 10 | | | | 90 | | 100 |
| **S2** | 110 | 140 | | | | | 250 |
| **S3** | | | 170 | | 20 | | 190 |
| **S4** | | | | 90 | | 120 | 210 |
| **Required** | 120 | 140 | 170 | 90 | 110 | 120 | |

This representation clarifies the elements of the model. The **decisions** are represented by the inner cells, while the **constraints** are represented by the rightmost column and the bottom row. Each supply constraint dictates that the sum in that row must be at most the number on the right. Each demand constraint dictates that the sum in that column must be at least the number at the bottom. Since the total supply and total demand are equal in this example, all constraints can only hold true as an **equation** ($\text{=}$). This is exactly the case throughout the table.

Examining the results, we can see that the optimal solution attempts to use the **cheapest unit costs** whenever possible, but not always. For instance, transport from **S4 to D4** is chosen despite not being the absolute cheapest method, either from supply S4 or to demand D4. However, it proves to be a good choice because the remaining transportation can then be done more cheaply. Note that based on this single run of the model, we cannot be certain that this is the only optimal solution.

There are many other examples of the transportation problem publicly available; see, for example, [16].

-----

## 6.2 Connections as an Index Set

Based on the complete solution presented in Section 6.1, we will now slightly enhance the implementation. As mentioned previously, in GNU MathProg, we can introduce additional parameters and sets to simplify the model formulation. These can either be defined on the spot, read from a separate data section outside the model, or allow both as a default value.

Notice that the indexing expression `s in Supplies, d in Demands` appears in four different contexts:

  * In the `Cost` parameter, as it is defined for all such pairs.
  * In the `tran` variable, as it is defined for all such pairs.
  * In the objective function, as it is a sum over all such pairs.
  * In the post-processing work, because transport amounts are printed for all such pairs. (In this case, there is a filter that only allows nonzero amounts to be reported.)

It would be a serious error to make a mistake in this indexing—for example, by switching the order of `Supplies` and `Demands`. To avoid such errors and slightly reduce redundancy, we can introduce a two-dimensional set of these pairs. Each supply and each demand are considered to be part of a **connection**. Thus, the transportation problem involves deciding on transportation amounts for each connection. The set `Connections` can be introduced as follows:

```glp
set Connections := setof {s in Supplies, d in Demands} (s,d);
```

We are using a new GNU MathProg operator here: `setof`. This is a general method for defining sets based on data previously defined in the model section. The `setof` operator is followed by an indexing expression, then by a simple expression. The resulting set is formed by evaluating the final expression for all possible indices in the indexing expression. It's similar to `sum`, but instead of adding elements up, it forms a set of them. Note that the indexing expression in `setof` can be filtered, giving us fine control over the set being defined. Since the result is a set, duplicates are removed, and the result can also be empty if everything is filtered out; however, neither of these is the case here.

In fact, this usage of `setof` is quite simple: it just collects all possible pairs formed by the two sets. The set `Connections` is a **Cartesian product** of the sets `Supplies` and `Demands`. There is another built-in operator called `cross` for the Cartesian product of two sets, which allows for a simpler definition of the set `Connections` as follows. Either definition can be used, as they are equivalent.

```glp
set Connections := Supplies cross Demands;
```

The dimension of the sets `Supplies` and `Demands` is 1 because they contain simple elements, whereas the dimension of `Connections` is 2 because it contains pairs (or 2-tuples). In GNU MathProg, a set can have as many as 20 dimensions. If a set contains $n$-tuples, then its dimension is $n$. Sets with different dimensions **cannot be mixed** together with set operations like `union`, `inter`, or `diff`. Even a one-dimensional empty set is considered different from a two-dimensional empty set.

The dimension of a set determines how it can be used in indexing expressions. One-dimensional sets are indexed by a single introduced symbol, like `s in Supplies` or `d in Demands`. However, two- (and higher-) dimensional sets are indexed by a tuple element, like `(s,d) in Connections`. In general, an indexing expression may contain many sets with different dimensions, each one introducing one or more new index symbols that can be referenced.

In short, everywhere we see `s in Supplies, d in Demands` in an indexing expression, we can now write `(s,d) in Connections`, as shown in the complete model below.

```glp
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
minimize Total_Costs:
sum {(s,d) in Connections} tran[s,d] * Cost[s,d];
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g amount for %g (unit cost: %g).\n",
s, d, tran[s,d], tran[s,d] * Cost[s,d], Cost[s,d];
}
end;
```

The resulting new model file is **equivalent** to the original one; therefore, solving the same data file describing **Problem 22** should yield the exact same result.

To illustrate how explicitly introducing an index set like `Connections` can be beneficial, consider the following new problem:

**Problem 23.**

Solve **Problem 22**, the original example transportation problem, with one modification: only connections whose unit costs are **no greater than 7** are allowed.

We introduce a parameter to denote the unit cost limit.

```
param Max_Unit_Cost, default 7;
```

Note that by providing a default value of **7** instead of setting the parameter equal to **7**, we allow the possibility to **alter** `Max_Unit_Cost` by providing a value in the data section, if we ever want to choose a different limit.

One possible solution is to express a new constraint that explicitly finds each prohibited connection and sets the transported amount there to zero, effectively excluding the connection from the model.

```
s.t. Connections_Prohibited
{s in Supplies, d in Demands: Cost[s,d] > Max_Unit_Cost}: tran[s,d] = 0;
```

However, in this case, we use many variables in the model just to fix them at zero. It's possible **not to include** those variables in the model formulation at all, and this can be done by introducing a **filter** in the `setof` expression defining the **`Connections`** set.

```
set Connections :=
setof {s in Supplies, d in Demands: Cost[s,d] <= Max_Unit_Cost} (s,d);
```

With this filter, we only include allowed connections in the **`Connections`** set. Therefore, without modifying other parts of the model, the exclusion is implemented—the indexing expressions `(s,d)` in `Connections` just iterate over a **smaller set** in the background.

Note that **care must be taken** with this method, because now the following constraint would cause an **out-of-domain error**:

```
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
```

The problem is that `tran[s,d]` is iterated over **all pairs** of `s` in **`Supplies`** and `d` in **`Demands`**, but the variable is simply **not defined** for all such pairs now. This is in strong contrast with the first approach where they **are defined**, but explicitly set to zero. We must now ensure that the sum only considers **allowed connections**, which can be done as follows:

```
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {(s,d) in Connections} tran[s,d] <= Available[s];
```

In this case, the role of $s$ and $d$ are different in the sum operator. Despite being used as an index, $s$ is a **constant value**. But $d$ is introduced **inside** the indexing expression, so it can be freely chosen by the sum. The meaning of the indexing expression is that all $(s,d)$ pairs are selected for which $s$ is a given value. This effectively sums over all demands that are allowed to be connected to the particular $s$, and the constraint works as desired.

The point is that an $n$-tuple index in an indexing expression can have **constant coordinates** as long as it contains **at least one new, free symbol** for a coordinate. In the GNU MathProg language documentation, an index symbol introduced by an indexing expression is called a **dummy index**. Dummy indices are **freely selected** by the indexing expression in all possible ways and can be used as constants afterward. Here, $s$ is a dummy index from the indexing of the constraint, whereas $d$ is a dummy index from the indexing expression of the sum operator, but **both** can be referred to in the operand of the sum (`tran[s,d]`).

The model contains another constraint for the demands; this must also be updated similarly, by replacing `s in Supplies` with `(s,d) in Connections`. Our model section for the new problem is now ready.

Solving it with the original problem data reports an optimal solution of **2790**, slightly worse than the original solution of **2700**. This isn't surprising, as the original solution used a unit cost of **8**. By excluding it, it's theoretically possible to obtain the same objective another way, but that's not the case here. The moral of the story is that, contrary to first thought, excluding expensive connections can be a **disadvantage** in the transportation problem.

Note that while the transportation problem has feasible solutions if total supplies are **no less** than total demands, this is **no longer guaranteed** if certain connections are prohibited.

-----

## 6.3. Increasing Unit Costs

So far, we've assumed a **linear transportation cost** at each connection. The amount is simply multiplied by a constant to obtain the cost. The relationship between the total amount transported and the total cost incurred can be schematically represented as in Figure 2. The red line represents the calculated total costs, but the area above that curve can be regarded as "feasible" too. The logic behind this is that we're allowed to pay more than needed; it just doesn't make sense to do so.

[Image of cost vs amount linear graph]

The term **proportional cost** is also widely used. Proportional cost means a cost where the ratio of total amounts and costs is a **parameter constant**.

In practice, the total cost to be paid for some resource is **not always proportional** to the amount used. A few common examples are shown in this and the following sections, which can be modeled as a **Linear Program (LP)** or at least as a **Mixed-Integer Linear Program (MILP)** model.

The first example is when the unit cost is constant up to a certain threshold, after which it **increases** to a higher constant value. This is common in practice, often called the **law of diminishing returns**. This means that spending an additional unit for costs yields **less and less return**. This is equivalent to having a unit price that **increases** with the total amount already obtained.

**Problem 24.**

Solve Problem 21, the **transportation problem**, with one modification: there are two **unit costs** for transportation—one for amounts **below** a given **threshold** and a higher unit cost for **surplus amounts above** that threshold.

-----

**Problem 25.**

Solve Problem 22, the original example transportation problem, with one modification: the given unit costs are only for transportation amounts **below 100 units**. Above that limit, costs are **increased by 25%** per material unit transported.

Schematically, the **cost function** can be represented as in **Figure 3**. Again, the region above the red curve denoting the **total costs** can be termed as **feasible** because we can pay more if we want; it's just not advantageous and, therefore, will never happen.

In the example problem, all thresholds and increased costs are **uniform** across the connections. Note that this isn't necessarily always the case. In other problem definitions, each connection may have **unique thresholds**, basic, and increased unit costs.

The first step is to define the **data** in the model needed to calculate the alternative cost function. Two parameters are introduced: **`CostThreshold`** is the amount over which the unit costs increase, and **`CostIncPercent`** denotes the rate of increase in **percent**. Note that the increase must be positive.

```
param CostThreshold, >=0;
param CostIncPercent, >0;
```

In Problem 25, the following values can be given in the **data** section.

```
param CostThreshold := 100;
param CostIncPercent := 25;
```

We introduce another parameter, **`CostOverThreshold`**, which calculates the increased unit cost using the following formula. Note that the original unit cost is `Cost[s,d]`.

```
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 + CostIncPercent / 100);
```

At this point, we have all the required data defined in the model. The question is how to **implement the correct calculation of total costs**, regardless of whether the amount is below or above the threshold.

First, we can simply introduce two variables: **`tranBase`** for amounts below and **`tranOver`** for amounts above the threshold.

```
var tranBase {(s,d) in Connections}, >=0, <=CostThreshold;
var tranOver {(s,d) in Connections}, >=0;
```

Note that both quantities are **nonnegative**. The amount to be transported over the threshold for the increased cost (`tranOver`) is **unlimited**; however, we can only transport a **limited amount** at the original cost (`tranBase`). Therefore, `tranBase` gets an **upper bound**: the threshold itself. Note that the decision of transported amounts is **individual for each connection**; therefore, all these variables are defined for each connection.

The amounts represented by `tranBase` and `tranOver` are simply a **separation of the total amount** represented by `tran`. Therefore, a **constraint** is provided to ensure that the sum of the former two equals `tran` for each connection.

```
s.t. Total_Transported {(s,d) in Connections}:
tran[s,d] = tranBase[s,d] + tranOver[s,d];
```

Instead of using `tran` in the objective, we can refer to the **`tranBase` and `tranOver` parts separately** and multiply these amounts by their corresponding unit costs (`Cost` and `CostOverThreshold`).

```
minimize Total_Costs: sum {(s,d) in Connections}
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]);
```

Our model is ready, but consider one thing. Now, the `tranBase` and `tranOver` amounts can be set **freely**. For example, if the threshold is **100**, then transporting **130 units** in total can be done as $\text{tranBase}=100$ and $\text{tranOver}=30$, but also as $\text{tranBase}=50$ and $\text{tranOver}=80$. In the latter case, the total cost is not calculated correctly in the objective, but it is **still allowed by the constraints**.

But the model works because the unit cost above the threshold is **strictly higher** than the cost below it. Therefore, the optimal solution would **not attempt** transporting any amounts over the threshold unless all possible amounts are transported below it (i.e., $\text{tranBase}=100$ in the example). Spending more is allowed as **feasible solutions** in the model, but these cases are **eliminated by the optimization procedure**. Consequently, in the optimal solution, there is either **zero amount above the threshold** or the **full amount below it** for each connection. The costs are calculated correctly in both scenarios.

-----

The full model section for the transportation problem with increasing rates is shown here.

```
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
param CostThreshold, >=0;
param CostIncPercent, >0;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 + CostIncPercent / 100);
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
var tranBase {(s,d) in Connections}, >=0, <=CostThreshold;
var tranOver {(s,d) in Connections}, >=0;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
s.t. Total_Transported {(s,d) in Connections}:
tran[s,d] = tranBase[s,d] + tranOver[s,d];
minimize Total_Costs: sum {(s,d) in Connections}
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]);
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g=%g+%g " &
"amount for %g (unit cost: %g/%g).\n",
s, d, tran[s,d], tranBase[s,d], tranOver[s,d],
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]),
Cost[s,d], CostOverThreshold[s,d];
}
```

Solving the model with a value of **100** for `CostThreshold` and **25** for `CostIncPercent`, we get the following result.

```
Optimal cost: 2772.5.
From S1 to D5, transport 100=100+0 amount for 500 (unit cost: 5/6.25).
From S2 to D1, transport 120=100+20 amount for 125 (unit cost: 1/1.25).
From S2 to D2, transport 130=100+30 amount for 275 (unit cost: 2/2.5).
From S3 to D2, transport 10=10+0 amount for 50 (unit cost: 5/6.25).
From S3 to D3, transport 170=100+70 amount for 187.5 (unit cost: 1/1.25).
From S3 to D5, transport 10=10+0 amount for 40 (unit cost: 4/5).
From S4 to D4, transport 90=90+0 amount for 720 (unit cost: 8/10).
From S4 to D6, transport 120=100+20 amount for 875 (unit cost: 7/8.75).
```

The **optimal solution is 2,772.5 units**, and in some cases, the thresholds are **surpassed**. The objective is slightly worse than the original 2,700. This is not surprising because the current and original problems only differ due to the **increased costs**. If we look closely at the transportation amounts, we can observe that the increased unit costs over the **100 threshold** not only change the pricing but also affect the **optimal transportation decisions**.

-----

## 6.4 Economy of Scale

The previous section dealt with **increased unit costs**, but what happens when unit costs **decrease above the threshold**?

The case where larger amounts provide **lower unit prices** is called **economy of scale**. This is common in practice. In production, higher volume allows investment costs to be **shared** among more products, decreasing the **cost per product**. In trade, you might get a **discount** for purchasing in larger volumes.

Here, we present the simplest case of **economy of scale**, where unit costs simply decrease above a threshold.

**Problem 26.**

Solve Problem 21, the **transportation problem**, with one modification: there are two **unit costs** for transportation—one for amounts **below** a given **threshold** and a **lower** unit cost for **surplus amounts above** that threshold.

-----

**Problem 27.**

Solve Problem 22, the original example transportation problem, with one modification: the given unit costs are only for transportation amounts **below 100 units**. Above that limit, costs are **decreased by 25%** per amount transported.

The only difference between this problem and the previous one is that the unit costs above the threshold are now **lower**, not higher. It is tempting to address this by slightly modifying our code to calculate decreasing costs. The parameter `CostIncPercent` is renamed to **`CostDecPercent`**, and `CostOverThreshold` is calculated accordingly.

```
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
```

However, if we solve the model, the results **do not reflect reality**.

```
Optimal cost: 2025.
From S1 to D1, transport 10=0+10 amount for 37.5 (unit cost: 5/3.75).
From S1 to D5, transport 90=0+90 amount for 337.5 (unit cost: 5/3.75).
From S2 to D1, transport 110=0+110 amount for 82.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=0+140 amount for 210 (unit cost: 2/1.5).
From S3 to D3, transport 170=0+170 amount for 127.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=0+20 amount for 60 (unit cost: 4/3).
From S4 to D4, transport 90=0+90 amount for 540 (unit cost: 8/6).
From S4 to D6, transport 120=0+120 amount for 630 (unit cost: 7/5.25).
```

The optimal solution is **2,025**, which is much better than the original 2,700. But the details show **zero transportation amounts below the threshold** ($\text{tranBase}=0$), meaning the total amount is being transported at the lower price. This is clearly **not allowed**, as we can only use lower unit costs *after* filling the amounts below the threshold at the higher rate.

When the cost above the threshold was **higher**, the model worked perfectly. Now that the cost above the threshold is **lower**, the model is incorrect. Why?

  * If unit costs **increase**, amounts below the threshold ($\text{tranBase}$) are filled first because it's cheaper. Non-optimal approaches are **ruled out by the optimization procedure**.
  * If unit costs **decrease**, optimization **prefers amounts above the threshold** ($\text{tranOver}$) because of the lower cost. However, this lower cost is a "**right**" that must be earned by filling the base amount first. This is **not enforced by the constraints**, so the reported solution is **infeasible in reality**.

To understand this, observe the schematic representation of the economy of scale (see **Figure 4**).

One property of **Linear Programming (LP)** problems is that their search space is always **convex**. This means if you have two feasible solutions and take a **convex combination** of them, the result is also feasible.

However, in **Figure 4**, the feasible region is **not convex**. We must allow feasibility on both red line segments, but their **convex combinations fall into the infeasible region**. We can see why this wasn't a problem with increasing costs: the convex combinations fell into the **feasible region**—those cases didn't make sense in reality, but the model included them, and the problem could be modeled by LP.

Since the feasible region is not convex, the **economy of scale cannot be modeled by LP**. We must add **integer variables**, making the model a **Mixed-Integer Linear Program (MILP)**. Our goal is to ensure that amounts below the threshold ($\text{tranBase}$) are **fully utilized** whenever any amounts are transported above the threshold ($\text{tranOver}$).

For each connection, we introduce a **binary variable**, $\text{isOver}$.

```
var isOver {(s,d) in Connections}, binary;
```

$\text{isOver}$ determines whether we are **entitled** (= 1) or not (= 0) to transport for the lower unit cost. This binary variable introduces a **discrete nature** to the problem, making the search space **non-convex**. Depending on the value of $\text{isOver}$:

  * If $\text{isOver}=0$, we **cannot** use the lower cost, so amounts above the threshold ($\text{tranOver}$) **must be zero**.
  * If $\text{isOver}=1$, we **must** earn the right to use lower costs, so amounts below the threshold ($\text{tranBase}$) **must be maximal** (equal to $\text{CostThreshold}$).

**The Big-M Constraint Technique**

It's a common problem to want a linear constraint (like $A \ge B$) to be **active only if a condition is met**. The condition is often represented by a binary variable $x$.

The modeling technique used is called the **big-M constraint**. First, arrange the constraint into the form $B - A \le 0$, then find a **positive upper bound** for $B - A$ (denoted $\mathbf{M}$). This bound must be large enough to include all possible values for variables in the expression.

Then, include the following constraint:

$$B - A \le M \cdot (1 - x)$$

Let's investigate what this does:

1.  If **$x = 1$**, the constraint reduces to $B - A \le 0$, which is what we wanted.
2.  If **$x = 0$**, the constraint reduces to $B - A \le M$. Since $M$ is larger than any possible value of $B - A$, the constraint becomes **redundant**—exactly what we wanted.

This is a general technique for the **conditional inclusion of linear constraints** in MILP models.

**Implementing the Economy of Scale Constraints**

There are two conditional constraints to implement:

1.  If $\text{isOver}=0$, then $\text{tranOver}=0$ must hold.
2.  If $\text{isOver}=1$, then $\text{tranBase}=\text{CostThreshold}$ must hold.

For the first constraint, we define the big-M parameter as the sum of all available supplies.

```
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];
```

When $\text{isOver}[s,d]=0$, then $\text{tranOver}[s,d] \le 0$ is enforced (so it must be zero). $M$ must be larger than any sensible value of $\text{tranOver}[s,d]$.

For the second constraint:

```
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
```

However, we can use a **smarter big-M**. The big-M can be set as low as $\mathbf{CostThreshold}$. With this value, the constraint can be rearranged into a more readable form:

```
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
tranBase[s,d] >= CostThreshold * isOver[s,d];
```

If $\text{isOver}[s,d]=1$, then $\text{tranBase}[s,d] \ge \text{CostThreshold}$ is enforced. If $\text{isOver}[s,d]=0$, the constraint is redundant.

We added the variable $\text{isOver}$ and these two constraints to the previous model, and now our model for the transportation problem with **economy of scale** is ready.

**Full MILP Model for Economy of Scale**

```
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
param CostThreshold, >=0;
param CostDecPercent, >0, <=100;
param CostOverThreshold {(s,d) in Connections} :=
Cost[s,d] * (1 - CostDecPercent / 100);
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
var tranBase {(s,d) in Connections}, >=0, <=CostThreshold;
var tranOver {(s,d) in Connections}, >=0;
var isOver {(s,d) in Connections}, binary;

s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
s.t. Total_Transported {(s,d) in Connections}:
tran[s,d] = tranBase[s,d] + tranOver[s,d];
param M := sum {s in Supplies} Available[s];
s.t. Zero_Over_Threshold_if_Threshold_Not_Chosen {(s,d) in Connections}:
tranOver[s,d] <= M * isOver[s,d];
s.t. Full_Below_Threshold_if_Threshold_Chosen {(s,d) in Connections}:
# tranBase[s,d] >= CostThreshold - M * (1 - isOver[s,d]);
tranBase[s,d] >= CostThreshold * isOver[s,d];
minimize Total_Costs: sum {(s,d) in Connections}
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]);
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g=%g+%g " &
"amount for %g (unit cost: %g/%g).\n",
s, d, tran[s,d], tranBase[s,d], tranOver[s,d],
(tranBase[s,d] * Cost[s,d] + tranOver[s,d] * CostOverThreshold[s,d]),
Cost[s,d], CostOverThreshold[s,d];
}
```

We get the following results for **Problem 27**:

```
Optimal cost: 2625.
From S1 to D1, transport 10=10+0 amount for 50 (unit cost: 5/3.75).
From S1 to D5, transport 90=90+0 amount for 450 (unit cost: 5/3.75).
From S2 to D1, transport 110=100+10 amount for 107.5 (unit cost: 1/0.75).
From S2 to D2, transport 140=100+40 amount for 260 (unit cost: 2/1.5).
From S3 to D3, transport 170=100+70 amount for 152.5 (unit cost: 1/0.75).
From S3 to D5, transport 20=20+0 amount for 80 (unit cost: 4/3).
From S4 to D4, transport 90=90+0 amount for 720 (unit cost: 8/6).
From S4 to D6, transport 120=100+20 amount for 805 (unit cost: 7/5.25).
```

Now, the optimal solution is **2,625**. Observe that each time a lower cost is used (i.e., $\text{tranOver}>0$), the **full threshold of 100 is first reached** ($\text{tranBase}=100$). Unlike the case for increasing unit costs, the reduced costs above the threshold now only affect the objective through pricing; the optimal solution remains the same in terms of transported amounts.

Remember that this model contains **binary variables**, making it an **MILP**. If the number of binary variables is large, computational time may increase dramatically.

-----

## 6.5 Fixed Costs

We have considered different scenarios for unit costs. These were all **proportional costs**. In some cases, **fixed costs** may also be present.

**Problem 28.**

Solve Problem 21, the transportation problem, with the following modification: for each connection, there is a **fixed cost** to be paid once for **establishing it** in order to use that connection.

The **fixed cost** does not depend on the actual amounts. We pay it once to use a connection. We may choose **not to establish a connection**, but then we cannot transport anything between that supply and demand point.

The example problem to be solved here is:

**Problem 29.**

Solve Problem 28 using data from the original **Problem 22**, and the following fixed establishment costs per connection.

| | **D1** | **D2** | **D3** | **D4** | **D5** | **D6** |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **S1** | 50 | 50 | 80 | 50 | 200 | 50 |
| **S2** | 200 | 50 | 50 | 50 | 200 | 50 |
| **S3** | 50 | 200 | 200 | 50 | 50 | 50 |
| **S4** | 50 | 50 | 50 | 200 | 200 | 200 |

We start with the general implementation from **Section 6.2**. We add a new parameter, **`FixedCost`**, and implement the matrix in Problem 29 in the data section.

```
param FixedCost {(s,d) in Connections}, >=0;
```

```
param FixedCost:
D1 D2 D3 D4 D5 D6 :=
S1 50 50 80 50 200 50
S2 200 50 50 50 200 50
S3 50 200 200 50 50 50
S4 50 50 50 200 200 200
;
```

If we observe the schematic representation of the fixed cost (**Figure 5**), we can see that the curve is again **not convex**.

We need a **binary decision variable** to distinguish the two cases. **`tranUsed`** equals one if we choose to establish the connection. If `tranUsed` is zero, then transportation on that connection **must also be zero**.

```
var tranUsed {(s,d) in Connections}, binary;
```

Two things must be enforced. First, if we **do not establish the connection** ($\text{tranUsed}=0$), there must be **no amount transported** ($\text{tran}=0$). This can be done with a **big-M constraint**.

```
param M := sum {s in Supplies} Available[s];
s.t. Zero_Transport_If_Fix_Cost_Not_Paid {(s,d) in Connections}:
tran[s,d] <= M * tranUsed[s,d];
```

The coefficient $M$ must be large enough not to exclude legitimate solutions. To create **stricter constraints**, we can use the **minimum of the available amount at the supply and the required amount at the demand**.

```
s.t. Zero_Transport_If_Fix_Cost_Not_Paid {(s,d) in Connections}:
tran[s,d] <= min(Available[s],Required[d]) * tranUsed[s,d];
```

Second, we must include the fixed establishment cost in the **objective function**.

```
minimize Total_Costs: sum {(s,d) in Connections}
(tran[s,d] * Cost[s,d] + tranUsed[s,d] * FixedCost[s,d]);
```

The full model section is the following.

**Full MILP Model for Fixed Costs**

```
set Supplies;
set Demands;
param Available {s in Supplies}, >=0;
param Required {d in Demands}, >=0;
set Connections := Supplies cross Demands;
param Cost {(s,d) in Connections}, >=0;
param FixedCost {(s,d) in Connections}, >=0;
check sum {s in Supplies} Available[s] >= sum {d in Demands} Required[d];
var tran {(s,d) in Connections}, >=0;
var tranUsed {(s,d) in Connections}, binary;
s.t. Availability_at_Supply_Points {s in Supplies}:
sum {d in Demands} tran[s,d] <= Available[s];
s.t. Requirement_at_Demand_Points {d in Demands}:
sum {s in Supplies} tran[s,d] >= Required[d];
s.t. Zero_Transport_If_Fix_Cost_Not_Paid {(s,d) in Connections}:
tran[s,d] <= min(Available[s],Required[d]) * tranUsed[s,d];
minimize Total_Costs: sum {(s,d) in Connections}
(tran[s,d] * Cost[s,d] + tranUsed[s,d] * FixedCost[s,d]);
solve;
printf "Optimal cost: %g.\n", Total_Costs;
for {(s,d) in Connections: tran[s,d] > 0}
{
printf "From %s to %s, transport %g " &
"amount for %g (unit cost: %g, fixed: %g).\n",
s, d, tran[s,d],
tran[s,d] * Cost[s,d] + FixedCost[s,d], Cost[s,d], FixedCost[s,d];
}
end;
```

The original optimal solution (zero fixed costs) is **2,700**. If nonzero fixed costs are present, the following output is reported:

```
Optimal cost: 3640.
From S1 to D1, transport 100 amount for 550 (unit cost: 5, fixed: 50).
From S2 to D1, transport 20 amount for 220 (unit cost: 1, fixed: 200).
From S2 to D2, transport 140 amount for 330 (unit cost: 2, fixed: 50).
From S2 to D4, transport 90 amount for 140 (unit cost: 1, fixed: 50).
From S3 to D3, transport 80 amount for 280 (unit cost: 1, fixed: 200).
From S3 to D5, transport 110 amount for 490 (unit cost: 4, fixed: 50).
From S4 to D3, transport 90 amount for 590 (unit cost: 6, fixed: 50).
From S4 to D6, transport 120 amount for 1040 (unit cost: 7, fixed: 200).
```

The objective is **3,640**. The connections used are **different**. The total establishment cost paid is **850**.

-----

## 6.6 Flexible Demands

In some cases, constraints are **soft constraints**. This means we are interested in solutions that **violate them**, provided the **extent of the violation** is minimized. This can be handled using **penalties**, terms added to the objective function proportional to the extent a constraint is violated.

**Problem 30.**

Solve Problem 21, the transportation problem with the addition of **flexible demands**. For each demand point, we do not require the exact requirement to be served. Instead, a **penalty** is introduced proportional to the difference between the required amount and the actually served amount.

-----

**Problem 31.**

Solve Problem 22 with flexible demands. There is a **surplus** and a **shortage penalty constant**.

Two scenarios:

  * **"Small" penalty:** Shortage penalty 3, surplus penalty 1.
  * **"Large" penalty:** Shortage penalty 15, surplus penalty 10.

The starting point is the model with connections from **Section 6.2**. We add parameters **`ShortagePenalty`** and **`SurplusPenalty`**.

Let's investigate penalties as a function of the total materials delivered (**Figure 6**). **Linear penalty functions** are assumed. Although the curve is "broken," the **feasible region is still convex**, suggesting a **pure LP model**.

We introduce an auxiliary variable, **`satisfied`**, denoting the **total amount delivered** to a demand.

```
var satisfied {d in Demands}, >=0;
s.t. Calculating_Demand_Satisfied {d in Demands}:
satisfied[d] = sum {s in Supplies} tran[s,d];
```

**Method 1: Single Penalty Variable**

The penalty function can be modeled by two linear constraints.

```
var penalty {d in Demands}, >=0;
s.t. Shortage_Penalty_Constraint {d in Demands}:
penalty[d] >= ShortagePenalty * (Required[d] - satisfied[d]);
s.t. Surplus_Penalty_Constraint {d in Demands}:
penalty[d] >= SurplusPenalty * (satisfied[d] - Required[d]);
```

The penalty variable is included in the objective function. The optimization procedure eliminates excessively high penalty values, so in the optimal solution, one constraint will be strict (or both if the requirement is met exactly).

```
minimize Total_Costs:
sum {(s,d) in Connections} tran[s,d] * Cost[s,d] +
sum {d in Demands} penalty[d];
```

**Method 2: Shortage and Surplus Variables**

Alternatively, we can use variables for the exact shortage and surplus amounts.

```
var surplus {d in Demands}, >=0;
var shortage {d in Demands}, >=0;
s.t. Calculating_Exact_Demands {d in Demands}:
Required[d] - shortage[d] + surplus[d] = satisfied[d];
```

The optimization procedure ensures that **either shortage or surplus is zero** in the optimal solution.

```
minimize Total_Costs:
sum {(s,d) in Connections} tran[s,d] * Cost[s,d] +
sum {d in Demands} (shortage[d] * ShortagePenalty +
surplus[d] * SurplusPenalty);
```

**Results**

For the **"small" penalty scenario** ($\text{ShortagePenalty}=3, \text{SurplusPenalty}=1$), total costs are cut by nearly half (**1,450**). There are **vast shortages** because the unit cost of transportation exceeds the gain from satisfying demand.

For the **"large" penalty scenario** ($\text{ShortagePenalty}=15, \text{SurplusPenalty}=10$), the solution is **exactly the same as the original** (2,700). The shortage penalty is more costly than transporting the material, so there are no shortages.

-----

## 6.7 Adding a Middle Level

What happens when the network is more complex, for example, if there is a **third set of nodes**?

**Problem 32.**

Solve **Problem 21** extended by introducing a middle level of **centers**.

Material flows from supply nodes to center nodes (A-type connections), then from center nodes to demand nodes (B-type connections). If a center is utilized, a **one-time establishment cost** must be paid.

**Problem 33.**

Solve **Problem 21** with centers using specific data (S1-S4, C1-C2, D1-D6). Two scenarios:

  * **"Small" establishment cost:** C1=1200, C2=1400.
  * **"Large" establishment cost:** C1=12000, C2=14000.

We define sets `Supplies`, `Centers`, `Demands`, and parameters `Available`, `Required`, `CostA`, `CostB`, and `EstablishCost`.

We define variables `tranA` and `tranB` for transportation amounts. We also need `atCenter` (amount through center) and the binary variable `useCenter` (is center used?).

```
var tranA {(s,c) in ConnectionsA}, >=0;
var tranB {(c,d) in ConnectionsB}, >=0;
var atCenter {c in Centers}, >=0;
var useCenter {c in Centers}, binary;
```

Constraints ensure consistency:

1.  Supply limits.
2.  Flow into center equals `atCenter`.
3.  Flow out of center equals `atCenter`.
4.  Demand requirements.
5.  Center usage (Big-M constraint).

The objective function sums all costs.

**Results**

**Small scenario:** Optimal cost **$7,350**. Both centers are used.

**Large scenario:** Optimal cost **$21,310**. Only center C2 is used (fixed cost 14,000). C2 is chosen despite being more expensive to establish because overall transportation costs are lower.

-----

## 6.8. TRANSPORTATION PROBLEM – SUMMARY

We started with the basic transportation problem involving supply and demand nodes. We improved implementation using index sets.

The problem results in an **LP model**. We presented four elaborate cost functions:

  * **Increasing Unit Costs:** Uses an **LP** model.
  * **Economy of Scale:** Uses **binary variables**, making it an **MILP** model.
  * **Fixed Costs:** Uses a **binary variable**, making it an **MILP**.
  * **Linear Penalties:** Results in an **LP** model.

Finally, we extended the problem with **center nodes**, combining two sub-problems and a fixed cost decision.