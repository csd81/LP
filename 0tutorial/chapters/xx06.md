---------------
Problem 5.
Take the equations defined by Equation system 4 as initial, within its aligned form described in
either Equation system 9 or 10. Then, obtain another system by applying the following modifications.
1. Change the coefficient of x everywhere from 2 to 4.
2. Add z in Eq1 with a coefficient of 3.
3. Delete y from Eq2 (zeroize its coefficient).
4. Change the RHS of Eq3 to 1.5.
5. Add a fifth variable v, with no bounds.
6. Add the equation x + 3v + 0.5 = −2z as Eq5.
7. Introduce v in Eq4 with a coefficient of 5.
8. Print out the newly introduced variable v after the solve statement as the others.
These modifications can be done one-by-one in a straightforward way until the following model
is obtained.
21

4.2. MODIFICATIONS IN CODE

EQUATION SYSTEMS

var x;
var y;
var z;
var w;
var v;
s.t. Eq1: 4 * x + (-2) * y +
3 * z +
0 * w +
s.t. Eq2: 0 * x +
0 * y + (-1) * z + (-1) * w +
s.t. Eq3: 0 * x +
1 * y +
1 * z +
0 * w +
s.t. Eq4: 4 * x + (-7) * y +
0 * z +
2 * w +
s.t. Eq5: 1 * x +
0 * y +
2 * z +
0 * w +

0 * v = -5;
0 * v = -5;
0 * v = 1.5;
5 * v = 0;
3 * v = -0.5;

solve;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
printf "v = %g\n", v;
end;
The solution of the new system is x = 2, y = 3.5, z = −2, w = 7, v = 0.5. Although not proven
here, but this solution is unique.
Now observe which kind of modifications we have to implement in code to obtain the results.
The first four tasks were just replacing, introducing and erasing coefficients from the corresponding
equations. In these cases, one must find the corresponding constraints, the corresponding variable
in it and apply the changes.
However, the introduction of the new variable requires some more work besides declaring v as a
variable with no bounds. If we wanted to maintain the arrangement of the equations, then all must
be expanded with a single column for coefficients of v. These coefficients are initially zero, for not
being used. Then, in Eq4 and Eq5, we can insert a nonzero coefficient for v afterwards. We also
need to manually modify the printing code after the solve statement to involve v.
Insertion of the new equation Eq5 would also require some more work. Again, if we wanted
to keep the code easy to read and maintain the arrangement, the new code line for Eq5 must be
formatted accordingly.
Although this was still a small problem, we can feel that modification of a system of equations to
accommodate another problem might be a bit frustrating. It gets worse if the number of variables
and equations increase – note that several thousands of both are still considered a problem with
reasonable size.
One problem is that the model code includes some redundancy – we have to maintain arrangement to preserve readability, although it is not possible for very large problems. However, the
greatest drawback is that we have to understand and tamper with model code – although we only
need to change the actual problem itself, which is still a system of linear equations.
It would be wise to somehow separate the modeling logic of systems of linear equations, and actual
data of the linear equations to be solved (that is, the number of variables, equations, coefficients
and right-hand side constants). This is exactly what we will do in the next sections. Afterwards,
what we only need is to alter the data, and the model can remain unchanged, which helps us in
reusing code in the future, and implementation of problems with large data.

22

4.3. PARAMETERS

4.3

EQUATION SYSTEMS

Parameters

The first thing we do to separate problem data from the model logic is the introduction of parameters. This case, the modified problem is to be implemented. We only change the code, not the
underlying problem.
Parameters can be introduced with the param statement. It is similar in syntax to the var
statement for introducing variables. However, the param statement defines constant values that can
be used in the model formulation. Parameters are by default numeric values, and are used here as
such, but note that they can also represent symbolic values (like strings).
The fundamental difference is that variables are the values to be found by the optimization
procedure, to satisfy all constraints and optimize a given objective function. For the implementation
point of view, the values of variables are only available after the solve statement. Parameters, on
the other hand, are constant values that are initially given, and are typically used to formulate the
model itself.
Note that parameters defined by the param statement, similarly to variables defined in the var
statement, must have a unique name, and they can only be used in the model file after definition.
Hence, in any expression, we can only refer to parameters which are defined earlier in the code. For
this reason, parameter definitions typically precede constraint and even variable definitions.
First, we only introduce parameters for the right-hand values of the equations, as follows.
var x;
var y;
var z;
var w;
var v;
param Rhs1 := -5;
param Rhs2 := -5;
param Rhs3 := 1.5;
param Rhs4 := 0;
param Rhs5 := -0.5;
s.t. Eq1: 4 * x + (-2) * y +
3 * z +
0 * w +
s.t. Eq2: 0 * x +
0 * y + (-1) * z + (-1) * w +
s.t. Eq3: 0 * x +
1 * y +
1 * z +
0 * w +
s.t. Eq4: 4 * x + (-7) * y +
0 * z +
2 * w +
s.t. Eq5: 1 * x +
0 * y +
2 * z +
0 * w +

0 * v = Rhs1;
0 * v = Rhs2;
0 * v = Rhs3;
5 * v = Rhs4;
3 * v = Rhs5;

solve;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
printf "v = %g\n", v;
end;
From now on, if we need to modify the RHS of an equation, we do not need to modify the code
of the constraint describing that equation. Instead, we only need to replace the definition of the
given RHS parameter.
23

4.4. DATA BLOCKS

EQUATION SYSTEMS

In the same manner, we can also introduce parameters for the coefficients of the equations. Because there are coefficients for all 5 equations and all 5 variables, a total of 25 additional parameters
are needed.
var x;
var y;
var z;
var w;
var v;
param Rhs1 := -5;
param Rhs2 := -5;
param Rhs3 := 1.5;
param Rhs4 := 0;
param Rhs5 := -0.5;
param c1x:=4; param c1y:=-2; param c1z:= 3; param c1w:= 0; param c1v:= 0;
param c2x:=0; param c2y:= 0; param c2z:=-1; param c2w:=-1; param c2v:= 0;
param c3x:=0; param c3y:= 1; param c3z:= 1; param c3w:= 0; param c3v:= 0;
param c4x:=4; param c4y:=-7; param c4z:= 0; param c4w:= 2; param c4v:= 5;
param c5x:=1; param c5y:= 0; param c5z:= 2; param c5w:= 0; param c5v:= 3;
s.t. Eq1: c1x * x + c1y * y + c1z * z + c1w * w + c1v * v = Rhs1;
s.t. Eq2: c2x * x + c2y * y + c2z * z + c2w * w + c2v * v = Rhs2;
s.t. Eq3: c3x * x + c3y * y + c3z * z + c3w * w + c3v * v = Rhs3;
s.t. Eq4: c4x * x + c4y * y + c4z * z + c4w * w + c4v * v = Rhs4;
s.t. Eq5: c5x * x + c5y * y + c5z * z + c5w * w + c5v * v = Rhs5;
solve;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
printf "v = %g\n", v;
end;
Note that param statements can be put in a single line for the sake of readability, and to
preserve the arrangement of the equations. After the total of 30 parameters are introduced, the
implementation of the equations can be considered final. With the sole modification of the parameter
statements in the model file, we can solve arbitrary systems of linear equations with 5 variables and
5 equations.
Note that the solution of any of these two models are exactly the same as before, as the system
of equations itself did not change, only its implementation.

4.4

Data blocks

We had separated the coefficients and RHS values from the equations they are in, but still, we need
to modify the param statements in the model file to alter the problem. We used a single model file
24

4.4. DATA BLOCKS

EQUATION SYSTEMS

each time so far. Now we introduce the concept of the model section and the data section, with
which we can separate the model logic with the problem data entirely.
Parameter values in GNU MathProg can be determined in two ways.
• A parameter value is explicitly given where it is defined: as a constant value, or some expression
of other constant values, other parameters, and built-in functions and operators of the GNU
MathProg language.
• A parameter value in not given in the model section, but in a separate data section.
Now let us see how we can modify the model file to obtain a separate model section and data
section. In case where only the RHS parameters were introduced, the complete separation is the
following.
var x;
var y;
var z;
var w;
var v;
param Rhs1;
param Rhs2;
param Rhs3;
param Rhs4;
param Rhs5;
s.t. Eq1: 4 * x + (-2) * y +
3 * z +
0 * w +
s.t. Eq2: 0 * x +
0 * y + (-1) * z + (-1) * w +
s.t. Eq3: 0 * x +
1 * y +
1 * z +
0 * w +
s.t. Eq4: 4 * x + (-7) * y +
0 * z +
2 * w +
s.t. Eq5: 1 * x +
0 * y +
2 * z +
0 * w +

0 * v = Rhs1;
0 * v = Rhs2;
0 * v = Rhs3;
5 * v = Rhs4;
3 * v = Rhs5;

solve;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
printf "v = %g\n", v;
data;
param Rhs1 := -5;
param Rhs2 := -5;
param Rhs3 := 1.5;
param Rhs4 := 0;
param Rhs5 := -0.5;
end;
We can observe that the parameters are only defined, without a value given in the model section.
Then, after the model construction, and the post-processing procedures (here, printing the variables
25

4.4. DATA BLOCKS

EQUATION SYSTEMS

out), there comes a data statement. There can be a single data statement at the end of a model
file, which denotes the end of the model section and the start of the data section. The data section
contains the actual values of parameters which were defined in the model without a value provided
there.
This can be done for the full parameterization example as well.
var x;
var y;
var z;
var w;
var v;
param Rhs1;
param Rhs2;
param Rhs3;
param Rhs4;
param Rhs5;
param c1x; param c1y; param c1z; param c1w; param c1v;
param c2x; param c2y; param c2z; param c2w; param c2v;
param c3x; param c3y; param c3z; param c3w; param c3v;
param c4x; param c4y; param c4z; param c4w; param c4v;
param c5x; param c5y; param c5z; param c5w; param c5v;
s.t. Eq1: c1x * x + c1y * y + c1z * z + c1w * w + c1v * v = Rhs1;
s.t. Eq2: c2x * x + c2y * y + c2z * z + c2w * w + c2v * v = Rhs2;
s.t. Eq3: c3x * x + c3y * y + c3z * z + c3w * w + c3v * v = Rhs3;
s.t. Eq4: c4x * x + c4y * y + c4z * z + c4w * w + c4v * v = Rhs4;
s.t. Eq5: c5x * x + c5y * y + c5z * z + c5w * w + c5v * v = Rhs5;
solve;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
printf "w = %g\n", w;
printf "v = %g\n", v;
data;
param Rhs1 := -5;
param Rhs2 := -5;
param Rhs3 := 1.5;
param Rhs4 := 0;
param Rhs5 := -0.5;
param c1x:=4; param c1y:=-2; param c1z:= 3; param c1w:= 0; param c1v:= 0;
param c2x:=0; param c2y:= 0; param c2z:=-1; param c2w:=-1; param c2v:= 0;
param c3x:=0; param c3y:= 1; param c3z:= 1; param c3w:= 0; param c3v:= 0;
param c4x:=4; param c4y:=-7; param c4z:= 0; param c4w:= 2; param c4v:= 5;

26

4.4. DATA BLOCKS

EQUATION SYSTEMS

param c5x:=1; param c5y:= 0; param c5z:= 2; param c5w:= 0; param c5v:= 3;
end;
The solution obtained by solving these model files is exactly the same in all the parameterization
examples, because the system of linear equations is still the same. But now, if one wants to solve
an arbitrary system of 5 linear equations on 5 variables, then only the data section of this model
file must be modified accordingly.
There are more complex data sections required for more complex models. However, the syntax
for data sections is generally more permissive than in the model section. That means, even if we only
want to implement a single model and only solve it with a single problem, it is still a good choice to
write its data to a separate data section rather than hard-coding parameter values into the model
section. The more permissive syntax also makes shorter and more readable data representation
possible.
One thing that makes data sections useful is that they can be implemented in a separate data
file. A data file is a data section written in a separate file. Its content shall be simply all the code
between the data and end statements. Note that both statements are optional in this case, but
increase readability.
The model file shall only contain the full model section and no data sections. Suppose that
we had a model file named equations.mod, and we write the data section of the actual system of
equations into the eq-example.dat file. Then, solution with the glpsol command line tool can be
done with the following command.
glpsol -m equations.mod -d eq-example.dat
Unlike in the model section where referring to model elements defined afterwards is illegal, the
statements in the data section can be in arbitrary order. Moreover, multiple data files are allowed
to be solved with a single model file, therefore we can further separate problem data. It does not
mean that we are solving different problems at the same time, but a single problem instance where
its different parameters are separated into different data files.
For example, if we have n different variations for the value of a given parameter, and k different
variables for the value of another parameter, then we can implement these as n + k data files. We
actually have nk different problem instances, all can be solved with the same single model file, by
providing glpsol the corresponding two variations for the two parameters.
One important property of parameters in GNU MathProg that should be kept in mind is that parameter values are only calculated if they are actually required, for example to define model elements
(like constraints, variable bounds, objectives), or printing them out, or, if they are required in the
calculation of other parameters which are themselves required. This might cause, for example that
an erroneously defined parameter value is only reported as a modeling error when the constraint it
first appears in is reached in the model file. Note that, basic syntax check is done by glpsol even
in this case, just the substitution of parameter values is „lazy”.
One particular example for this is when we do not give a value for a parameter, and use it
afterwards. It is legal in GNU MathProg to define a parameter without a value – for example, when
we want to give value to it in the data section after the whole model section, or even in a separate
file. If the parameter is not actually used at all in the model, then it is not an error. However, if
the parameter is used and there is no value at definition, or any data sections, an error is generated.
To demonstrate this, erase the param c3z := 1; statement from the data section of the model and
try to solve it with glpsol as before. The following error message is shown.

27

4.5. INDEXING

EQUATION SYSTEMS

Generating Eq1...
Generating Eq2...
Generating Eq3...
eqsystem-data-blocks-full.mod:21: no value for c3z
MathProg model processing error
We can see that the first two equations Eq1 and Eq2 were generated successfully. However,
Eq3 utilized the parameter c3z in its definition, but there was no value given for that particular
parameter: neither in the model section, nor in the data section (or any data sections). The model
could not be generated and solved.
Note that, it is also illegal to provide a parameter value twice (in the model and in a data section,
or in any two data sections). However, there is a way we can „optionally” provide parameters values
in data files, by providing default values at the model file. More on that later.

4.5

Indexing

At this point, we are able to completely separate the model logic and the problem data – at least for
the case of systems of linear equations. However, one might argue that it did not actually help much.
The model section including all the constraints are not needed to be touched, but the parameter
definition part of the model, and also their values in a data section, require even more code to be
written. It is still very complicated to modify the data of the problem.
Not to mention that the number of variables and the number of equations cannot be altered
solely by redefining parameters. A new variable or a new equation would require many additional
parameters also.
However, we can understand the logic behind systems of linear equations: we know the exact
way how a system with any number of variables and any number of equations, can be implemented.
The model formulation is redundant: model elements are defined very similarly, much of the code
can be copy-pasted – it seems like the model implementation does not exploit the underlying logic
of systems of linear equations.
First, let us try to express how the solution of a systems of linear equations generally work.
1. There are variables. The number of variables is not known. These each are reals with no
bounds.
2. There are equations. The number of equations is not known.
3. All equations have a single right-hand side value. This means there exists a parameter for all
equations that define these RHS constants.
4. All the equations have a left-hand side where we add all the variables up, each with a single
coefficient, which is a parameter. This means there exists a parameter for all equations, AND
all variables that define the coefficients. Note that here „AND” means for all pairs of equations
and variables. That implies, if there are n equations and k variables, there are a total of nk
parameters.
5. After the solve statement, we simply write a printf statement individually for all variables,
to print their values found by the solution algorithm.
We can see that the for all parts of the logic is where the redundancy is introduced into the
model file, and also the data section. The reason is that in these cases, code must be reused many
times. We need a uniform way to tell the solver that we actually want to do many similar things
at once. For example, to write var and printf statements for all variables in the system, s.t.
28

4.5. INDEXING

EQUATION SYSTEMS

statements, and param statements denoting RHS constants for all equations in the system. Also,
to define param statements for all equations and variables that describe the coefficients, and to
appropriately implement each of these constraints that involve summing up a particular coefficient
multiplied by the particular variable, for all variables.
In GNU MathProg, this can be achieved by indexing expressions, which also requires the
concept of sets.
Sets contain many different elements (possibly zero, in which case we have an empty set). There
are many ways in the language sets can be defined. Note that there are also literals that denote
sets. For example, 1..10 denote the set of integers from 1 to 10. However, in this example, we
define our own sets with the set statement.
There are two sets needed in our model. One is for the variables, and one is for the equations.
set UnknownValues;
set Equations;
The set UnknownValues correspond to the variables of the system of linear equations. In our
previous example, they were namely x, y, z, w, and v. The set Equations correspond to the
equations in the system, they were Eq1, Eq2, Eq3, Eq4 and Eq5.
We used the name UnknownValues to differentiate the variables of the system of linear equations
to be solved (these are the „unknown values”) from the variables defined in the GNU MathProg
model by a var statement. These are in a one-to-one correspondence in this particular model: for
each unknown value in the system of equations, there will be exactly one GNU MathProg model
variable defined. Just remember that these are different concepts.
At this point, the contents of the sets are not defined. The reason is exactly the same as when
parameters are only given values in the data section. The actual content of the sets are not part
of the model logic, as the set of unknown values and equations both may vary. The procedure for
giving values for sets is the same as parameters defined by the param statement. They can be given
a value at definition, or only afterwards in a data section. In this case, we choose the latter.
Now, let us define the parameters in our model by the following code.
param Rhs {e in Equations};
param Coef {e in Equations, u in UnknownValues};
This is the first time we use indexing expressions. They are denoted by the curly braces. In
the first example, Equations is the set providing the possible indices for the parameter Rhs. The
line literally means that we define a parameter named Rhs for all e, for which e is an element of
the Equations set. This means that whatever the number of equations is, there is an individual
parameter for each of these equations.
Note that we could also legally provide a value for the parameter Rhs, like we did for the
individual parameters before. We do not want that now, as constants at the RHS are not part of
the model logic, they are represented in the data section. Note that we have much more freedom
on indexing expressions, not mentioned for now, refer to the GNU MathProg language manual for
the possibilities.
The parameter Coef is defined similarly, but there are two indices separated by a comma. This
literally means that there is a parameter defined for all (e, u) ordered pairs, for which e is an equation
and u is an unknown value. In other words, we define a parameter for each element in the Cartesian
product of the two sets. There can be many indices in an indexing expression, the maximum is
currently 20. They always mean the same: the index set is obtained by all possible combinations of
the individual indices. We also call the number of indices as the number of dimensions of a set.
The parameter Rhs has a one-dimensional index, while Coef has a two-dimensional index.
Now we can define the variables in the model.
29

4.5. INDEXING

EQUATION SYSTEMS

var value {u in UnknownValues};
There is only one variable in this model, introducing the „unknown values” to be found in the
system of linear equations. We define each model variable to be found, for each unknown value in
the system of equations. The name of the model variable will be value.
Note that index names like u for UnknownValues can be arbitrary each time we refer to the
same set, but it is strongly recommended that they are consistent throughout the model section for
readability purposes. Here we use e for equations and u for unknown values.
Also note that the variables luckily have consistently no bounds, they all can take arbitrary real
values.
Now that we have defined the required parameters and variables in the model we can express
the constraints.
s.t. Cts {e in Equations}:
sum {u in UnknownValues} Coef[e,u] * value[u] = Rhs[e];
Now let us see the parts of this implementation one-by-one. Whitespace characters, including
newlines are for better readability. Note that this is a single constraint in GNU MathProg, and it
is named Cts, but due to the indexing, it will generate a set of individual equations in the model.
First, there must be exactly one constraint written up for each equation in the system. This
is established by the first indexing expression before the colon, e in Equations. This does not
only causes the number of the equation constraints to be determined, but it also introduces e as a
constant that we can refer to in the definition part.
The RHS of the constraint is the simpler, as it is the Rhs parameter itself. But here we can
see how indexing works for parameters. When Rhs was defined, it was defined for all equations.
That means, for example if there are three equations in the system, named Eq1, Eq2 and Eq3,
then exactly one parameter is defined in the model for each of these. They can be referred to as
Rhs[’Eq1’], Rhs[’Eq2’] and Rhs[’Eq3’] respectively. Remember that these are three different
parameters. However, we do not write something like Rhs[’Eq1’] in the model section, because the
exact equation name is not part of the model logic, it is rather arbitrarily given in a data section.
Instead, we refer to Rhs[e]. Remember that e denotes the current element of the Equations set
we are writing a constraint for. The result is that in each constraint, the RHS is the Rhs parameter
for the corresponding equation.
The LHS of the constraint is more complicated, because it contains a summation of an undetermined number of terms. Note that the logic is that for each unknown value, we multiply the
variable with the corresponding coefficient of the system, and these terms are added up. The sum
operator does exactly this job for us. It involves an indexing expression, where we denote that we
want to sum up terms for all unknown values u, and the term to be summed is followed. The sum
operator in GNU MathProg is later in precedence than multiplication, so there is no need to use
parentheses, Coef[e,u] * value[u] is the term that is summed up for all u. Each of these terms
refers to the variable of the corresponding unknown value u, which is value[u]. The term also
refers to Coef[e,u], which is the coefficient parameter for the equation e and the unknown value u.
Note that inside the scope of the sum operator, the u index is also available, as e inside the whole
indexed constraint. However, u would not be available outside the sum, for example, in the RHS.
It would not even make sense, because u is introduced only to define the terms of the sum.
Now that we have a single s.t. constraint statement describing the model of systems of linear
equations, the solve statement may come, after which we can print the values of the variables.
Again, we do not know the exact set of variables, but indexing can be used to do something for all
variables.

30

4.5. INDEXING

EQUATION SYSTEMS

for {u in UnknownValues}
{
printf "%s = %g\n", u, value[u];
}
The for statement requires an indexing expression, and effectively repeats the statements written
inside the block following it, throughout the index set given. Note that the statements allowed in
a for block is limited, but it includes printf and another for, which are enough for very complex
tasks to be implemented simply. The for statement cannot be used to define model elements like
parameters, variables, constraints or the objective, but is useful for displaying information.
Now, for each u unknown value, we want to print out the given value in the solution of the
system of equations. Therefore the printf statement refers to u itself, the name of the variable of
the system of equations, and its value, which is value[u].
At this point, we are ready with the model section. That means, any systems of linear equations
can be translated into a data section, and if done with correct syntax, can be solved without altering
the model file. Now, let us translate the previous problem instance into a well-formed data section.
set UnknownValues := x y z w v;
set Equations := Eq1 Eq2 Eq3 Eq4 Eq5;
The sets are given values here. That means, names of the unknown values and equations are
given one-by-one. Note that in the data section, there is no need for apostrophes. If we wanted to
hard-code a set definition into the model section, we would need apostrophes or quotation marks to
denote string constraints.
One of the parameters that require values to be given is the RHS constants.
param Rhs :=
Eq1 -5
Eq2 -5
Eq3 1.5
Eq4 0
Eq5 -0.5
;
There are multiple ways parameter data can be provided, refer to the GNU MathProg language
manual for more details [1]. The simplest is shown here. The index and value pairs are simply
enumerated, delimited by whitespace. One row for each pair is just a recommendation for readability.
Note that here we must refer to the equation names we gave for the Equations set.
This similar format can also be applied if the index has more dimensions, as Coef.
param Coef :=
Eq1 x 4
Eq1 y -2
Eq1 z 3
Eq1 w 0
Eq1 v 0
Eq2 x 0
Eq2 y 0
Eq2 z -1
Eq2 w -1

31

4.5. INDEXING

Eq2
Eq3
Eq3
Eq3
Eq3
Eq3
Eq4
Eq4
Eq4
Eq4
Eq4
Eq5
Eq5
Eq5
Eq5
Eq5
;

v
x
y
z
w
v
x
y
z
w
v
x
y
z
w
v

EQUATION SYSTEMS

0
0
1
1
0
0
4
-7
0
2
5
1
0
2
0
3

The scheme is the same. Pairs for indices and their corresponding values are enumerated.
However, each such pair now actually consists of three elements, because the first part of the index
is for the equation, and the second is for the unknown variable. Again, here we must refer to the
names we given in the set definitions in the data block.
And now we are ready. The model section attained its most general form. From now on, solution
of any system of linear equations can be done solely by writing a well-formed data section. This
data section may come after the model section in the model file itself, or more practically, it can be
put in separate file. Typically, each problem instance (in this case, each system of linear equations
to be solved) can be implemented in a single data file, containing the data section.
The complete model file and one possible data section are the following. The solution is again
exactly the same as before: x = 2, y = 3.5, z = −2, w = 7, v = 0.5.
set UnknownValues;
set Equations;
param Rhs {e in Equations};
param Coef {e in Equations, u in UnknownValues};
var value {u in UnknownValues};
s.t. ImplementingEquations {e in Equations}:
sum {u in UnknownValues} Coef[e,u] * value[u] = Rhs[e];
solve;
for {u in UnknownValues}
{
printf "%s = %g\n", u, value[u];
}
end;

32

4.6. OTHER OPTIONS FOR DATA

EQUATION SYSTEMS

data;
set UnknownValues := x y z w v;
set Equations := Eq1 Eq2 Eq3 Eq4 Eq5;
param Rhs :=
Eq1 -5
Eq2 -5
Eq3 1.5
Eq4 0
Eq5 -0.5
;
param Coef :=
Eq1 x 4
Eq1 y -2
Eq1 z 3
Eq1 w 0
Eq1 v 0
Eq2 x 0
Eq2 y 0
Eq2 z -1
Eq2 w -1
Eq2 v 0
Eq3 x 0
Eq3 y 1
Eq3 z 1
Eq3 w 0
Eq3 v 0
Eq4 x 4
Eq4 y -7
Eq4 z 0
Eq4 w 2
Eq4 v 5
Eq5 x 1
Eq5 y 0
Eq5 z 2
Eq5 w 0
Eq5 v 3
;
end;

4.6

Other options for data

Although we now have a single model file suitable for all possible systems of linear equations regardless of variable and equation count, there are other tricks in GNU MathProg that further help
us by allowing shorter and/or more readable implementation of data sections. Two of these options
are presented here: default values, and matrix data format. A common modeling error, the
33

4.6. OTHER OPTIONS FOR DATA

EQUATION SYSTEMS

out of domain error is also demonstrated here.
We have already mentioned that parameters (and also, sets) that we use in the model need a
value to be provided. This value is either calculated on spot, or not given in the model at all, so that
it can be provided separately in a data section. If a parameter has a calculated value hard-coded in
the model, then providing data for it is forbidden, but if it is not hard-coded, there must be a value
in the data sections.
However, we see that many of the coefficients in the system of linear equations can be zero.
Actually it is something like a default behavior: an equality might only refer to a subset of the
variables. If an equality does not refer to a variable, then it still has a zero coefficient due to the
modeling logic. But we do not want to provide these zero parameters for all variables each time we
write a new equation. Instead, we want to only provide those parameter values that are different
than this default zero.
This can be achieved by indicating a default value for a given parameter in the model section.
In this case, the model parameter does not have a hard-coded calculated value, but a given default
value instead. If there is a value provided in a data section, that value is used. If there are no
values provided, then the default value is used. Note that default values can also be given for
sets. However, they cannot be given for variables, as variables are determined by the optimization
procedure, so it does not make sense to provide default values for them.
To add a default value to a parameter, we must do the following.
param Coef {e in Equations, u in UnknownValues}, default 0;
Note that the default value in this example is zero, but in general it could be any expression that
can be calculated on spot. For instance, it can depend on e and u, the indices of the parameter.
After the default value of zero is given for Coef, all entries in the data section that indicate a
value of zero can be omitted, trimming the size of the data section significantly.
param Coef :=
Eq1 x 4
Eq1 y -2
Eq1 z 3
Eq2 z -1
Eq2 w -1
Eq3 y 1
Eq3 z 1
Eq4 x 4
Eq4 y -7
Eq4 w 2
Eq4 v 5
Eq5 x 1
Eq5 z 2
Eq5 v 3
;
Note that, while maintaining the code of this data section, care must be taken when adding a
new index to a parameter data set, as it may already be there. Duplicate indices are forbidden in
the data section, as common sense dictates.
Another trick that may help in designing shorter and more readable data sections is the matrix
data format. It works in many situations where two-dimensional data must be provided – like in
this case. Values for parameter Coef can be implemented in matrix format in the following way.

34

4.6. OTHER OPTIONS FOR DATA

param Coef:
x
y
Eq1
4
-2
Eq2
.
.
Eq3
.
1
Eq4
4
-7
Eq5
1
.
;

z
3
-1
1
.
2

w
.
-1
.
2
.

EQUATION SYSTEMS

v :=
.
.
.
5
3

Note that the colon and the := are denoting the matrix data format, whitespace indentation is
optional. It is recommended for readability that the data is indented similarly to the way shown.
The rows of the matrix correspond to the values of the first index, while the columns correspond
to the second index. Each entry in the matrix gives a value for the parameter identified by the row
and the column.
Note that in such a matrix, we do not have to mention all possible rows and columns. Those
parameter indices for which we do not give a value will be defaulted. Also, using the . character
instead of a value in the matrix makes that particular value to be defaulted.
If one wants to refer to the first indices by the columns and the second indices by the rows, it is
also possible: it is called the transposed matrix format, and it is simply obtained by inserting
(tr) before the colon.
There are more advanced data description formats in GNU MathProg, which are not mentioned
here. For example, it is possible to give multi-dimensional data by describing several different
matrices one after another.
An important issue about indexing is the out of domain error. For all parameters, variables
that are indexed, there is a well described index set. If at any time, a parameter or variable is
referred with an index that is not in its defined index set, then – not surprisingly – an error occurs.
Let us demonstrate it by changing the u and e indices in the constraint where the Coef parameter
is indexed. The following message is obtained, and the model cannot be processed.
Generating Cts...
eqsystem-indexing-matrix-ERROR-outofdomain.mod:10: Coef[x,Eq1] out of domain
MathProg model processing error
This is an error because the correct indexing would be Coef[Eq1,x], not Coef[x,Eq1]. The
latter is not a valid index for parameter Coef, because neither x is in the set Equations, nor Eq1
is in the set UnknownValues. The same error message may be reported if we do not use the indices
properly in the data section.
This example suggests an important source of error: indexing must be done properly. In this
case, the out of domain error is raised and the mistake could be corrected easily. However, the
situation can be much worse, for example, if a wrong indexing would actually mean a valid index
in the index set. In that case, the error remains unnoticed, and the wrong model is solved. This is
especially dangerous if the two indices are from the same set, as they can be switched by mistake.
For example, in a directed graph of vertices A, B and C, the arc AB is different from BA, but both
describe an arc, and are valid if implemented in GNU MathProg.
In our example, the two indices are from two different sets, so it is unlikely that a wrong indexing
is not reported. However, it may be the case if the two sets have common elements. For example, if
both the variables are labeled from 1 to 5, and all the equations are labeled also from 1 to 5, there
is nothing that forbids this. The correspondingly edited data section is the following.

35

4.7. GENERAL COLUMNS

EQUATION SYSTEMS

data;
set UnknownValues := 1 2 3 4 5;
set Equations := 1 2 3 4 5;
param Rhs :=
1 -5
2 -5
3 1.5
4 0
5 -0.5
;
param Coef:
1
2
1
4
-2
2
.
.
3
.
1
4
4
-7
5
1
.
;

3
3
-1
1
.
2

4
.
-1
.
2
.

5 :=
.
.
.
5
3

end;
Now, if this is the data section, and it is paired with the wrongly indexed model section we
presented before, then there are no out of domain errors, as all wrong indices are actually valid.
So a wrong model is solved now, which has a substantially different result than the original: 4.8,
−20.6, −67.5, −10.3 and 17. Remember that, the result was originally 2, 3.5, −2, 7, 0.5. Conclusion:
always pay special care for indexing, use meaningful and unique names even in the data sections,
and always validate the result of model solution.
A valid question arises: what was the problem that the wrongly indexed model had solved? We
leave it up to the reader, with a small hint: if the two indices are switched, then we effectively
transpose the data matrix.

4.7

General columns

We have seen some capabilities of the GNU MathProg language with which we can make compact
and more readable data sections. Now we will show how the already available techniques can be
utilized to further decrease the redundancy in a data section.
There is still a bit of redundancy in case of the rows of the equations. The RHS of the equations
are provided as a separate parameter where all the equation names must appear. The coefficient
matrix for the system of equations is described by another parameter, now in matrix format, but
the rows must start with the equation names again. It would be nice if these two kinds of data
could appear in a single data matrix.
We can easily solve it in GNU MathProg. Now, a common EqConstants parameter is introduced
which works as the following. Its indices are the columns of the problem in general. Each column
can correspond to a variable (unknown value) in the system of equations, or the RHS of the equation.
We can implement this by the following code.

36

4.7. GENERAL COLUMNS

EQUATION SYSTEMS

set UnknownValues;
set Equations;
set Columns := UnknownValues union {'RHS'};
param EqConstants {e in Equations, u in Columns}, default 0;
Note that the Columns is a set just like UnknownValues and Equations. However, this set is not
provided by a data section, but instead calculated on spot. The Columns is the set UnknownValues,
with the string RHS added to it.
var value {u in UnknownValues};
s.t. ImplementingEquations {e in Equations}:
sum {u in UnknownValues} EqConstants[e,u] * value[u]
= EqConstants[e,'RHS'];
The rest of the model is basically the same, but instead of the RHS parameter, we refer to the
EqConstants parameter with either the index of an unknown value u to access the coefficients, or
the RHS string to access the RHS constant in the given equation.
The data section is the following. The only parameter is EqConstants. Note that the solution
shall be exactly the same as before, the modifications only affected the format of the data section,
but the data content remained the same.
data;
set UnknownValues := x y z w v;
set Equations := Eq1 Eq2 Eq3 Eq4 Eq5;
param EqConstants:
x
y
z
Eq1
4
-2 3
Eq2
.
.
-1
Eq3
.
1
1
Eq4
4
-7 .
Eq5
1
.
2
;

w
.
-1
.
2
.

v
.
.
.
5
3

RHS :=
-5
-5
1.5
0
-0.5

end;
Note that this implementation does not work in one extreme situation: where one of the unknown
values are named RHS, in which case it is interchangeable with the string RHS denoting the right-hand
side column instead of ordinary variables in the system. So, for this model, the usage of keyword
RHS is forbidden for unknown values in the data section. But this restriction is a fair trade for the
more compact data section we got instead.
We can make our model foolproof by establishing this rule with a check statement. It works
like an assertion: a logical expression is evaluated, and if the result is false, the model generation is
aborted.
In this example we state that UnknownValues shall not contain the string RHS. In other words,
no variables in the system of equations shall be named RHS. The statement is best positioned soon
after the definition of the UnknownValues set.
37

4.8. MINIMIZING ERROR

EQUATION SYSTEMS

check 'RHS' !in UnknownValues;
Note that the check statement can also be indexed, which is an effective way of testing multiple
logical statements at once.
The evaluation of a check statement is also reported in the output generated by glpsol as
follows.
Checking (line 4)...
Checking is used to rule out wrong data by reporting it. Identifying bugs caused by unreported
data errors can be substantially more difficult.

4.8

Minimizing error

After implementing a model for arbitrary systems of linear equations, let us consider a bit different
problem: solving a system of equations „as well as we can”.
Although we do not focus on mathematical proofs here, it is worth mentioning that a system of
linear equations may have 0, 1 or infinitely many different solutions. This is related to the number
of variables and equations in the system in the following way. Note these rules are not general as
there are important exceptions that can be precisely characterized, but are typical if the coefficients
and RHS values in the equations are random or unrelated.
• Infinitely many solutions is the typical case when there are fewer equations than variables.
• A unique solution is typically caused by having the same number of equations and variables.
Note that this was the case in all of the previous examples in this section.
• If there are more equations than variables, the system is overspecified and the resulting
problem is usually infeasible. This can be demonstrated as follows.
