---------------
Problem 11.
Solve the production problem described in Problem 9, but with the following restrictions added.
• Use at least 20000 h of working time (raw material B).
• Fill the production quota: produce at least 200 units (raw material D), which is actually also
the maximum for that raw material.
• Produce at most 10 units of P3.

51

5.2. INTRODUCING LIMITS

PRODUCTION PROBLEM

As the problem is just an „extension” of the original one, its implementation can be done by just
extending the data section with the aforementioned limits. Note that each parameter is indexed
with the set of all raw materials and all products. Those that do not appear in the data section will
be simply be defaulted to 0 for lower and 10100 for upper limits, effectively causing the limits to be
redundant. In that case, they do not modify the search space of the model, because those limits
are true anyways for any otherwise feasible solution.
param Min_Usage :=
B 21000
D 200
;
param Min_Production :=
P2 100
;
param Max_Production :=
P3 10
;
The solution of the problem is now slightly different with the newly defined bounds.
Total Revenue: 32970
Production of P1: 90
Production of P2: 100
Production of P3: 10
Usage of A: 23000, remaining: -7.27596e-12
Usage of B: 21000, remaining: 10000
Usage of C: 433000, remaining: 17000
Usage of D: 200, remaining: 0
This means that 90 units of P1, 100 units of P2 and 10 units of P3 are produced. We may check
that all the limitations are met. It is interesting to note about this solution that all the variables
are integers, although they are not forced to be. This means that if the problem would change to
only consider integer solutions (for example if the product is an object, of which an integer number
shall be produced), then this solution would also be valid. Moreover, it would also be the optimal
solution, too, because restricting variables to only attain integer values just makes the search space
of the model even tighter. So if a solution is optimal even in the original model, meaning that there
are no better solutions, then there should not be better solutions in the more restrictive integer
counterpart either.
Now, our implementation for limits are done. But we can still improve the model implementation
by making it a bit more readable and less redundant. First, there is one nice feature in GNU
MathProg: if there is a linear expression that can be bounded by both an upper and a lower value
and both of these limits are constants, then these can be done in a single constraint instead of
two containing the same expression twice. With this feature, we can reduce the number of s.t.
statements from four to two in our model section as follows. All other parts of the model, the data,
and the solution remain the same.
s.t. Material_Balance {r in Raw_Materials}: Min_Usage[r] <=
sum {p in Products} Consumption_Rate[r,p] * production[p]
<= Storage[r];

52

5.2. INTRODUCING LIMITS

PRODUCTION PROBLEM

s.t. Production_Limits {p in Products}:
Min_Production[p] <= production[p] <= Max_Production[p];
There is another thing we can improve, which is actually a modeling technique rather than a
language feature: we can introduce auxiliary variables for linear expressions. The variables,
constraints and the objective will look like the following.
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;
s.t. Usage_Calc {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Revenue[p] * production[p];
maximize Total_Revenue: total_revenue;
Observe the newly introduced usage. We intend to denote the total consumption of a raw
material by this variable. Therefore, we add the Usage_Calc constraint that ensures this. We now
have that variable throughout the model to denote this value. We also do this for the total revenue,
which is denoted by variable total_revenue, calculated in the Total_Revenue_Calc constraint, and
then we use it in the objective function. Actually the objective function is itself the total_revenue
variable.
Now observe that all the expressions we have to limit are actually variables, and all the limits
are constants. This means that the constraints for the limits can be converted to bounds of these
variables, namely production and usage. This way, we effectively got rid of all the previously
defined constraints and converted them into bounds, but we needed two more constraints to calculate
the values of usage and total_revenue.
We might think that the key importance of introducing the new variable lies on the possibility
of using bounds instead of s.t. statements which makes our implementation shorter. This is only
an example for being useful. The key point is that if some expression is used more than once in our
model, we can simply introduce a new variable for it, define a new constraint so that the variable
equals that expression, and then use the variable instead of that expression everywhere.
Think about a bit: does this operation of adding auxiliary variables change the search space?
Well, formally, yes. The search space is of different dimension. There are more variables, so in
a solution to the new problem, we have to decide more values. However, also note that feasible
solutions of the new model will be in a one-to-one correspondence with the original ones. For a
solution feasible to the original problem, we can introduce the variable with the corresponding value
of the expression and get a feasible solution for the extended problem, and vice versa, each feasible
solution with the extended problem must have its auxiliary variable equal to the expression it is
defined for, and hence it can be substituted in the model and we get back to a feasible solution to
the original model.
In short, the search space formally changes, but the (feasible) solutions for the problem logically
remain the same.
An important question arises: how does the introduction of auxiliary variables change the course
of the algorithms, and solver performance? The general answer is that we do not know. There are
more variables, so computational performance might be slightly worse, but this is often negligible,
because the main difficulty of solving a model in practice comes from the complexity of the search
space, which is logically unchanged. Of course, if there are magnitudes more auxiliary variables than
ordinary variables and constraints themselves, it might cause technical problems. Also note that,
53

5.2. INTRODUCING LIMITS

PRODUCTION PROBLEM

in theory, the solver has the right to substitute into auxiliary variables, effectively reverting back to
the original problem formulation, but we generally cannot be sure that it does so. The solver does
not see which of our variables are intended to be „auxiliary”. If there is an equation constraint in
the model, the solver might use that equation to express one of the variables appearing in it, and
do a substitution into that variable, despite we had not even thought of it as auxiliary at all.
In short, the course of the solution algorithm may be different, the computational performance
of the solver might change, but this is usually negligible.
Note also that we have already done some introduction of new values in the post-processing
work, so that we did not have to write the total consumption expression twice. That was with the
introduction of a new parameter, not a variable, and only worked after the solve statement, because
it involved variable values that are only available when the model is already solved. However, now
with an auxiliary variable introduced for the total consumption, we can use it both before and
after the solve statement. Therefore we write this expression down in code only once, and that
redundancy finally totally diminished.
The ultimate model code for the limits is the following. Note that the data section, and the
solution remained the same as before. Also note that we did not have to introduce new parameters
after the solve statement as the auxiliary variables do the work.
set Products;
set Raw_Materials;
param Storage {r in Raw_Materials}, >=0, default 1e100;
param Consumption_Rate {r in Raw_Materials, p in Products}, >=0, default 0;
param Revenue {p in Products}, >=0, default 0;
param Min_Usage {r in Raw_Materials}, >=0, <=Storage[r], default 0;
param Min_Production {p in Products}, >=0, default 0;
param Max_Production {p in Products}, >=Min_Production[p], default 1e100;
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;
s.t. Usage_Calc {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Revenue[p] * production[p];
maximize Total_Revenue: total_revenue;
solve;
printf "Total Revenue: %g\n", total_revenue;
for {p in Products}
{
printf "Production of %s: %g\n", p, production[p];
}
for {r in Raw_Materials}
{

54

5.3. MAXIMIZING MINIMUM PRODUCTION

}

PRODUCTION PROBLEM

printf "Usage of %s: %g, remaining: %g\n",
r, usage[r], Storage[r] - usage[r];

end;

5.3

Maximizing minimum production

In the previous parts, we have seen a complete implementation for the production problem where
total raw material consumption and production can be limited by constants for all raw materials
and products. Now modify the goal of the optimization, to maximize the minimum production.
The exact definition is the following.
