

## Problem 40.

Given $N$ workers and $N$ tasks. For each worker and each task, we know how well that particular worker can execute that particular task, which is described by a cost value for that pair.

Assign each worker exactly one task so that the **total cost is maximized**.

As usual, the general problem is demonstrated through an example.

-----

## 7.3. ASSIGNMENT PROBLEM

MILP MODELS

## Problem 41.

Solve Problem 40, the assignment problem, using the following data. There are $N = 7$ workers, named W1 to W7, the tasks are named T1 to T7, and the following matrix describes the costs that are incurred whenever a particular task is assigned to a particular worker.

| | T1 | T2 | T3 | T4 | T5 | T6 | T7 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **W1** | 9 | 6 | 10 | 10 | 8 | 7 | 11 |
| **W2** | 7 | 12 | 6 | 14 | 10 | 5 | 5 |
| **W3** | 8 | 9 | 7 | 11 | 10 | 15 | 6 |
| **W4** | 4 | 10 | 2 | 10 | 6 | 4 | 7 |
| **W5** | 10 | 11 | 7 | 12 | 14 | 9 | 10 |
| **W6** | 5 | 9 | 8 | 9 | 13 | 3 | 8 |
| **W7** | 7 | 12 | 7 | 7 | 11 | 10 | 9 |

Defining the input sets and parameters and implementing the data section can be done in different ways. One possibility is to only read $N$, the number of workers and tasks, and use a fixed naming convention for them, for example, numbers from 1 to $N$. But now, we want to allow the naming of workers and tasks to come from the data section, and therefore two sets named `Workers` and `Tasks` are provided. The only requirement is that these sets must have the same size; otherwise, the assignment is impossible. This is established by a `check` statement.

Next, we introduce the `Assignments` set for all possible assignments between workers and tasks. This helps in the formulation later. The `Cost` parameter is then defined for all possible assignments.

```
set Workers;
set Tasks;
check card(Workers)==card(Tasks);
set Assignments := Workers cross Tasks;
param Cost {(w,t) in Assignments};
```

Data for the example Problem 41 can be implemented as follows.

```
data;
set Workers := W1 W2 W3 W4 W5 W6 W7;
set Tasks := T1 T2 T3 T4 T5 T6 T7;
param Cost:
T1 T2 T3 T4 T5 T6 T7 :=
W1 9 6 10 10 8 7 11
W2 7 12 6 14 10 5 5
W3 8 9 7 11 10 15 6
W4 4 10 2 10 6 4 7
W5 10 11 7 12 14 9 10
W6 5 9 8 9 13 3 8
W7 7 12 7 7 11 10 9
;
end;
```

-----

## 7.3. ASSIGNMENT PROBLEM

MILP MODELS

There is only one kind of decision to be made in the model: for each assignment, decide whether we assign that particular task to the worker or not. This is a binary variable; we name it `assign`.

```
var assign {(w,t) in Assignments}, binary;
```

There are two rules we must obey when choosing assignments: each worker must have exactly one task, and each task must have exactly one worker assigned. These are implemented as follows.

```
s.t. One_Task_Per_Worker {w in Workers}:
sum {t in Tasks} assign[w,t] = 1;
s.t. One_Worker_Per_Task {t in Tasks}:
sum {w in Workers} assign[w,t] = 1;
```

The objective is the total cost, which is obtained by adding each assignment variable multiplied by the associated cost.

```
minimize Total_Cost:
sum {(w,t) in Assignments} assign[w,t] * Cost[w,t];
```

Finally, after the `solve` statement, we print the optimal total cost, and for each worker, the task assigned. The model section is ready.

```
set Workers;
set Tasks;
check card(Workers)==card(Tasks);
set Assignments := Workers cross Tasks;
param Cost {(w,t) in Assignments};
var assign {(w,t) in Assignments}, binary;
s.t. One_Task_Per_Worker {w in Workers}:
sum {t in Tasks} assign[w,t] = 1;
s.t. One_Worker_Per_Task {t in Tasks}:
sum {w in Workers} assign[w,t] = 1;
minimize Total_Cost:
sum {(w,t) in Assignments} assign[w,t] * Cost[w,t];
solve;
printf "Optimal Cost: %g\n", Total_Cost;
for {w in Workers}
{
printf "%s->", w;
for {t in Tasks: assign[w,t]}
{
printf "%s (%g)\n", t, Cost[w,t];
}
}
end;
```

Note that the task assigned to the worker is printed by a `for` loop iterating over all tasks. As each worker has exactly one task assigned, this loop is guaranteed to print exactly one task, as desired.

The solution to the example problem is the following. The cost of each assignment is shown in parentheses.

```
Optimal Cost: 42
W1->T2 (6)
W2->T1 (7)
W3->T7 (6)
W4->T5 (6)
W5->T3 (7)
W6->T6 (3)
W7->T4 (7)
```

Therefore, the smallest possible sum of assignments is 42. As usual, it is not guaranteed that the solution shown is the only optimal one.

There are plenty of things we must note about the assignment problem.

  * As we can see, the model formulation is relatively simple. The number of different feasible solutions for $N$ workers is exactly $N!$ (factorial), because the assignment of tasks to workers can be regarded as a permutation of the tasks (or the workers). For $N=7$, it is 5,040, which is not too much to check even by brute force. However, the factorial function quickly rises, in fact, quicker than exponentially. For 20 tasks, the number of solutions is $20! > 10^{18}$. Such a number of steps is not considered feasible for average computers using naive brute-force methods.
  * With mathematical programming, we can solve assignment problems much larger in size. However, this is one of the few integer programming problems for which a polynomial-time algorithmic solution exists. The **Hungarian method** [22] is specifically designed for the assignment problem and is substantially faster than using a mathematical programming tool.
  * The assignment problem also has a rare property: its Linear Programming (LP) relaxation yields the optimal result for the Mixed-Integer Linear Programming (MILP) model as well. Therefore, the integrality gap is guaranteed to be zero. This means that we do not even need binary variables; simple continuous variables with a lower bound of 0 and an upper bound of 1 suffice. The reasons behind this property are out of scope for this tutorial. Nevertheless, this is useful knowledge because the assignment problem can be solved by LP, for which the practical limits in size are usually much larger than for MILP models.
  * The assignment problem is also closely related to the transportation problem. In fact, it can be interpreted as a transportation problem with $N$ sources and $N$ demands, each having an availability and requirement of 1, and the cost matrix for the transportation problem is the same as for the assignment problem. The only difference is that the 1 unit of material cannot be split over multiple connections. But this is not even beneficial: as we previously remarked, the LP relaxation of the problem is sufficient to provide the optimal solution.
  * In general, the assignment problem can be part of more complex **optimization problems** where finding a bijection between two sets is part of the decisions. A **bijection**, also called a one-to-one correspondence, between two sets of the same size is when exactly one element from the other set is assigned to each element.
  * Another interesting property is that we can add the same number to any row or any column of the cost matrix without altering the optimal solution. The only thing that changes is the optimal objective value, which is changed exactly by the number added to or subtracted from the row or column.
  * This assignment problem shown here involves minimization, but maximization could also be a valid objective. These problems are equivalent. If costs are simply negated, we get the opposite problem, and the solution procedure remains the same.

Now, we will show one interesting extension of the problem. What happens when some decisions about assignments have already been made?


