---------------
Problem 40.
Given N workers and N tasks. For each worker and each task, we know how well that particular
worker can execute that particular task, which is described by a cost value for that pair.
Assign each worker exactly one task so that the total cost is maximized.
As usual, the general problem is demonstrated through an example.

139

7.3. ASSIGNMENT PROBLEM

MILP MODELS

 
Problem 41.
Solve Problem 40, the assignment problem, with the following data. There are N = 7 the workers,
named W1 to W7, the tasks are named T1 to T7, and the following matrix describes the costs that
incurred whenever a particular task is assigned a particular worker.

W1
W2
W3
W4
W5
W6
W7

T1
9
7
8
4
10
5
7

T2
6
12
9
10
11
9
12

T3
10
6
7
2
7
8
7

T4
10
14
11
10
12
9
7

T5
8
10
10
6
14
13
11

T6
7
5
15
4
9
3
10

T7
11
5
6
7
10
8
9

Defining the input sets and parameters and implementing the data section can be done in different
ways. One possibility is to only read N , the number of workers and tasks, and use a fixed naming
convention for them, for example, numbers from 1 to N . But now, we want to allow the naming
of workers and tasks from the data section, and therefore two sets named Workers and Tasks are
provided. The only requirement is that these sets must have the same size, otherwise the assignment
is impossible. This is established by a check statement.
Next, we introduce the Assignments set for all possible assignments between workers and tasks.
This helps in the formulation later. The Cost parameter is then defined for all possible assignments.
set Workers;
set Tasks;
check card(Workers)==card(Tasks);
set Assignments := Workers cross Tasks;
param Cost {(w,t) in Assignments};
Data for the example Problem 41 can be implemented as follows.
data;
set Workers := W1 W2 W3 W4 W5 W6 W7;
set Tasks := T1 T2 T3 T4 T5 T6 T7;
param Cost:
T1 T2
W1
9
6
W2
7 12
W3
8
9
W4
4 10
W5 10 11
W6
5
9
W7
7 12
;

T3
10
6
7
2
7
8
7

T4
10
14
11
10
12
9
7

T5
8
10
10
6
14
13
11

T6
7
5
15
4
9
3
10

T7 :=
11
5
6
7
10
8
9

140

7.3. ASSIGNMENT PROBLEM

MILP MODELS

end;
There is only one kind of decision to be made in the model: for each assignment, decide whether
we assign that particular job to the worker or not. This is a binary variable, we name it assign.
var assign {(w,t) in Assignments}, binary;
There are two rules we must obey when choosing assignments: each worker must have exactly
one task, and each task must have exactly one worker assigned. These are implemented as follows.
s.t. One_Task_Per_Worker {w in Workers}:
sum {t in Tasks} assign[w,t] = 1;
s.t. One_Worker_Per_Task {t in Tasks}:
sum {w in Workers} assign[w,t] = 1;
The objective is the total cost, which is obtained by adding each assignment variable multiplied
by the associated cost.
minimize Total_Cost:
sum {(w,t) in Assignments} assign[w,t] * Cost[w,t];
Finally, after the solve statement, we print the optimal total cost, and for each worker, the task
assigned. The model section is ready.
set Workers;
set Tasks;
check card(Workers)==card(Tasks);
set Assignments := Workers cross Tasks;
param Cost {(w,t) in Assignments};
var assign {(w,t) in Assignments}, binary;
s.t. One_Task_Per_Worker {w in Workers}:
sum {t in Tasks} assign[w,t] = 1;
s.t. One_Worker_Per_Task {t in Tasks}:
sum {w in Workers} assign[w,t] = 1;
minimize Total_Cost:
sum {(w,t) in Assignments} assign[w,t] * Cost[w,t];
solve;
printf "Optimal Cost: %g\n", Total_Cost;
for {w in Workers}
{
printf "%s->", w;
for {t in Tasks: assign[w,t]}
{

141

7.3. ASSIGNMENT PROBLEM

}

}

MILP MODELS

printf "%s (%g)\n", t, Cost[w,t];

end;
Note that the task assigned to the worker is printed by a for loop iterating over all tasks. As
each worker has exactly one task assigned, this loop is guaranteed to print exactly one task as
desired.
The solution of the example problem is the following. The cost of each assignment is shown in
parentheses.
Optimal Cost: 42
W1->T2 (6)
W2->T1 (7)
W3->T7 (6)
W4->T5 (6)
W5->T3 (7)
W6->T6 (3)
W7->T4 (7)
Therefore, the smallest possible sum of assignments is 42. As usual, it is not guaranteed that
the shown solution is the only optimal one.
There are plenty of things we must note about the assignment problem.
• As we can see, the model formulation is relatively simple. The number of different feasible
solutions for N workers is exactly N ! (factorial), because the assignment of tasks to workers
can be regarded as a permutation of the tasks (or the workers). For N = 7, it is 5040, not too
much to check even by brute-force. But the factorial function quickly rises, in fact, quicker
than exponentially. For 20 tasks, the number of solutions is 20! > 1018 , such number of steps
is not considered feasible for average computers, for naive brute-force methods.
• With mathematical programming, we can solve assignment problems much larger in size.
However, this is one of the few integer programming problems for which a polynomial time
algorithmic solution exists. The Hungarian method [22] is specifically designed to the assignment problem, and is substantially faster than using a mathematical programming tool.
• The assignment problem also has a rare property: its LP relaxation yields the optimal result
for the MILP model as well. Therefore, the integrality gap is guaranteed to be zero. This
means that we do not even need binary variables, simple continuous variables with 0 lower
and 1 upper bounds suffice. The reasons behind this property is out of scope of this Tutorial.
Nevertheless, this is a useful knowledge because the assignment problem can be solved by LP,
for which the practical limits in size are usually much larger than for MILP models.
• The assignment problem is also closely related to the transportation problem. In fact, it can
be interpreted as a transportation problem with N sources and N demands, each having an
availability and requirement of 1, and the cost matrix for the transportation problem is the
same as for the assignment problem. The only difference is that the 1 unit of material cannot
be split over multiple connections. But this is not even beneficial: as we previously remarked,
the LP relaxation of the problem is sufficient to provide the optimal solution.

142

7.3. ASSIGNMENT PROBLEM

MILP MODELS

• In general, the assignment problem can be part of more complex optimization problems where
finding a bijection between two sets is part of the decisions. A bijection, also called oneto-one correspondence relation between two sets of the same size is when exactly one element
from the other set is assigned to each element.
• Another interesting property is that we can add the same number to any row, or any column
of the cost matrix, without altering the optimal solution. The only thing which changes is the
optimal objective value, which is changed exactly by the number added/subtracted from the
row or column.
• This assignment problem shown here involves minimization, but maximization could also be
a valid objective. These problems are equivalent. If costs are simply negated, we get the
opposite problem, and the solution procedure remains the same.
Now, we will show one interesting extension of the problem. What happens when some decisions
about assignments are already made?
