

## Problem 38.

Determine the **maximum number of non-overlapping crosses** that can be placed in an $N \times M$ grid.

One might argue that this general problem is very specialized within the class of **tiling problems**. Indeed, many tiling problems cannot be effectively solved using mathematical programming tools. Here, the "general problem" refers to creating a general model section that can be applied to any problem instance.

The data required for this problem is minimal: only the dimensions of the rectangular area need to be specified. Let's look at some examples.

**Problem 39.**

Solve **Problem 38**, the rectangle tiling problem with crosses, for the following rectangle sizes.

**Figure 8:** Rectangular area imperfectly covered by some five-square cross tiles.

  * $6 \times 4$
  * $10 \times 10$
  * $30 \times 30$

This problem requires perhaps the shortest data sections we've seen so far. The following is for the smallest instance:

```glp
param Width := 6;
param Height := 4;
```

We use the parameter names **`Width`** and **`Height`** for the dimensions of the rectangular region to be tiled. These must be positive integers. **`Height`** represents $N$, the number of rows, and **`Width`** represents $M$, the number of columns in the area. Rows are numbered from 1 to $N$, and columns are numbered from 1 to $M$. The set of all squares, or **cells**, in the rectangular grid is the Cartesian product of the sets of rows and columns, resulting in a size of $N \cdot M$. These are defined as shown below.

```glp
param Height, integer, >=1;
param Width, integer, >=1;
set Rows := 1 .. Height;
set Cols := 1 .. Width;
set Cells := Rows cross Cols;
```

At this point, the minimum data requirements are defined in the model, but a concise implementation will require a few more definitions. Let's first determine what kind of decisions we need to make to describe a tiling.

First, we need to, "decide for all possible positions of a cross tile whether to put a tile there or not." This can be done using a **binary variable** introduced for each possible position:

```glp
var place {(r,c) in Tiles}, binary;
```

Here, the set **`Tiles`** refers to a set that hasn't been characterized yet, but it will list all possible placements of cross tiles. Decisions for this `place` variable will fully determine all the necessary properties of the tiling, but an **auxiliary variable** will also be useful.

```glp
var covered {(r,c) in Cells}, binary;
```

Here, `covered` is defined for each cell and determines whether that cell is covered by a placed tile. This helps us formulate constraints ensuring that each cell can only be covered **at most once** to prevent overlapping tiles.

As is customary, a value of **1 means yes** and **0 means no** for all of these binary variables. For instance, a `place` variable is 1 if the tile is placed at that specific position, and a `covered` variable is 1 if that specific cell is covered by some tile.

Before moving on, we must somehow characterize the set **`Tiles`** that describes all possible tile positions. Fortunately, the five-cell cross is **symmetric**: rotating or reflecting it does not result in a different orientation. This means the only difference between tile positions is their location (shifting). In short, we can refer to this simply as the **position**. Therefore, a binary variable is introduced for each possible position of the tile, and the set `Tiles` simply contains these positions.

If we wanted to tile with **asymmetric shapes** where multiple orientations are possible, we would need to define different binary decision variables for each unique orientation and position. In that scenario, the `Tiles` set would require a third index dimension to denote orientation, in addition to the two dimensions for position. But since the cross only has a single orientation, that index dimension is omitted from our model, and `Tiles` is just a two-dimensional set listing positions.

Finally, let's decide how two-dimensional coordinates will define the positioning of tiles. For this purpose, we define the **anchor point** of the cross tile as the **central cell** of the tile. The set `Tiles` will list all possible anchor points of correctly positioned tiles. This is valid because different tile positions have different anchor points.

The selection of the anchor point relative to the tile can be arbitrary, but it must be consistent throughout the model. It could even be a cell outside the tileâ€”for example, the corner cell of the $3 \times 3$ square containing the cross tile.

The last remaining task is to determine the anchor points. We must consider all correctly positioned cross tiles in the rectangular grid. Clearly, because the anchor point is a cell *inside* the tile, the anchor point of a correctly positioned tile must also be within the rectangular grid. However, **not all cells** of the rectangular grid can be anchor points. For example, no cells along the edge of the rectangle are valid choices, as a cross centered there cannot fully cover itself without extending outside the region. Moreover, the corner cells of a rectangular grid cannot even be covered by *any* correctly positioned cross tiles.

Based on an anchor $(r,c)$, we can define all the cells of the cross tile if placed at that anchor. This is done by the **`CellsOf`** set. Note that this set statement is itself indexed over all cells (i.e., all possible anchors), meaning that $N \times M$ different sets of 5 cells each are defined.

```glp
set CellsOf {(r,c) in Cells} :=
{(r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)};
```

The set **`Tiles`** of correct tile positions (anchor points) are those for which these 5 cells defined in `CellsOf` are all within the rectangular area.

```glp
set Tiles, within Cells :=
setof {(r,c) in Cells: CellsOf[r,c] within Cells} (r,c);
```

Of course, we could have answered the question about correct anchor points right away: they are exactly the cells that are **not on the edges**. However, this approach is chosen for two reasons:

  * Defining all cells of the placed tile and keeping only those positions that are entirely within the region to be tiled is a very **general approach**. It would work not only on arbitrary tiles but on arbitrary regions on a finite grid as well.
  * The sets `CellsOf` provide us with a **shorter model formulation**, as we will see.

The definitions for `CellsOf` and `Tiles` must be placed before the definition of the variable `place`.

We need two things to be established by constraints. The first is the calculation of the auxiliary variable `covered` for each cell. The second is that each cell can only be covered at most once. Surprisingly, both can be done with a single constraint statement, as follows:

```glp
s.t. No_Overlap {(r,c) in Cells}: covered[r,c] =
sum {(x,y) in Tiles: (r,c) in CellsOf[x,y]} place[x,y];
```

In plain terms, for each cell, we add the `place` variables of all the tiles that cover that cell. Since `place` is an integer variable, the sum exactly equals the number of tiles covering that specific cell. This number can only be zero or one; two or more is forbidden. The latter is implicitly ensured because the sum equals the single binary variable `covered[r,c]`, and since it is a binary variable, its value cannot exceed one.

Note that, in fact, the variable `covered` doesn't even need to be explicitly formulated as **binary**. The constraint ensures that its value is an integer because it's obtained as a sum of integer variables. The only required property of the variable `covered` is its **upper bound, 1**.

This insight can be useful when analyzing the complexity of the problem. Generally, the more binary variables a model has, the more difficult it is to solve. However, since `covered` doesn't necessarily have to be binary, it isn't expected to significantly increase complexity. The true integer nature and difficulty of the problem are based on the `place` variable, which denotes tile placements. Nevertheless, marking `covered` as binary might alter the solution algorithm's process.

The objective is the total number of tiles placed.

```glp
maximize Number_of_Crosses:
sum {(r,c) in Tiles} place[r,c];
```

After the `solve` statement, a useful way to print the solution is to visualize the tiling itself using character graphics.

```glp
for {r in Rows}
{
for {c in Cols}
{
printf "%s",
if (!covered[r,c]) then "."
else if ((r,c) in Tiles) then (if (place[r,c]) then "#" else "+")
else "+";
}
printf "\n";
}
```

Since the output is textual, we must print each row on a single line, and within a row, we print each cell denoted by the column. A single character is printed for each cell so that the entire rectangular area looks correctly aligned when viewed in a fixed-width font:

  * If a cell is **not covered**, a **dot (`.`)** is placed there.
  * If a cell is the anchor point of a **placed tile**, it is denoted by a **hash mark (`#`)**.
  * Otherwise, if the cell is covered by a cross but is **not its center**, it is denoted by a **plus sign (`+`)**.

Note the use of nested `if` operators to achieve the desired result. One might argue that an unnecessary `if` is present because both cases eventually result in a `+` sign. The key point is that we first check whether $(r,c)$ is a proper anchor point or not. Only if it is an anchor point do we then check the value of the `place[r,c]` variable. We do this because if `place[r,c]` is referenced for a non-anchor point $(r,c)$, an **"out of domain" error** would occur, as the `place` variable is only defined for anchor points (members of the set `Tiles`). Note that if an `else` value is omitted in MathProg, it is assumed to be zero.

The model section for **Problem 38** is complete.

```glp
param Height, integer, >=1;
param Width, integer, >=1;
set Rows := 1 .. Height;
set Cols := 1 .. Width;
set Cells := Rows cross Cols;
set CellsOf {(r,c) in Cells} :=
{(r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)};
set Tiles, within Cells :=
setof {(r,c) in Cells: CellsOf[r,c] within Cells} (r,c);
var covered {(r,c) in Cells}, binary;
var place {(r,c) in Tiles}, binary;
s.t. No_Overlap {(r,c) in Cells}: covered[r,c] =
sum {(x,y) in Tiles: (r,c) in CellsOf[x,y]} place[x,y];
maximize Number_of_Crosses:
sum {(r,c) in Tiles} place[r,c];
solve;
printf "Max. Cross Tiles (%dx%d): %g\n",
Height, Width, Number_of_Crosses;
for {r in Rows}
{
for {c in Cols}
{
printf "%s",
if (!covered[r,c]) then "."
else if ((r,c) in Tiles) then (if (place[r,c]) then "#" else "+")
else "+";
}
printf "\n";
}
end;
```

Solving the model for the smallest instance, a $4 \times 6$ area, shows that no more than **two** cross tiles can fit in such a small area. One possible construction, reported by the model output, is shown below:

```
Max. Cross Tiles (4x6): 2
....+.
.+.+#+
+#+.+.
.+....
```

The medium instance of a $10 \times 10$ area is still solved very quickly. A maximum of **13** cross tiles fit in the area, and the reported solution is:

```
Max. Cross Tiles (10x10): 13
.+...+..+.
+#+.+#++#+
.++..+.++.
.+#+.++#+.
..+++#+++.
.++#++++#+
+#++.+#++.
.++..++.+.
.+#++#++#+
..+..+..+.
```

The large instance of $30 \times 30$ cells was included to demonstrate what happens when the model becomes genuinely large and thus cannot be solved quickly. In such cases, the solver could take an unacceptably long time to complete. Therefore, a **time limit of 60 seconds** is provided. In the command line, this can be done by adding the `--tmlim 60` argument to `glpsol`:

```bash
glpsol -m tiling.mod -d example.dat --tmlim 60
```

If the time limit option is omitted, there is no time limit. Note that the limit set this way is not a strict bound on the running time available for the solver; `glpsol` tends to slightly exceed this limit, especially if preparatory steps are lengthy.

Running `glpsol` with a one-minute time limit produced the following output:

```
GLPK Integer Optimizer, v4.65
901 rows, 1684 columns, 5604 non-zeros
1684 integer variables, all of which are binary
Preprocessing...
896 rows, 1680 columns, 4816 non-zeros
1680 integer variables, all of which are binary
Scaling...
A: min|aij| = 1.000e+00 max|aij| = 1.000e+00 ratio = 1.000e+00
Problem data seem to be well scaled
Constructing initial basis...
Size of triangular part is 896
Solving LP relaxation...
GLPK Simplex Optimizer, v4.65
896 rows, 1680 columns, 4816 non-zeros
*
0: obj = -0.000000000e+00 inf = 0.000e+00 (784)
Perturbing LP to avoid stalling [253]...
Removing LP perturbation [1896]...
* 1896: obj = 1.631480829e+02 inf = 0.000e+00 (0) 12
OPTIMAL LP SOLUTION FOUND
```

Note that the original model contained a massive **1684 binary variables**. Preprocessing only removed four of them (likely the corner cells, as they can never be covered, but this is an unverified claim).

After that, the **LP relaxation** of the MILP model is solved. The rows concerning "perturbation" indicate that the solver took countermeasures to avoid **stalling**, which is a possible infinite loop in the Simplex algorithm. The presence of this message suggests that the solved LP itself is difficult, very large, or has unusual properties. The last line shows that **163.15** was the optimal solution of the LP relaxation. This is valuable information because we now know that the optimal solution of the actual MILP model **cannot be greater than 163**. The solution algorithm uses the result of the LP relaxation to set an initial bound.

```
Integer optimization begins...
Long-step dual simplex will be used
+ 1896: mip = not found yet <= +inf (1; 0)
+ 4865: mip = not found yet <= 1.630000000e+02 (44; 0)
+ 9025: mip = not found yet <= 1.630000000e+02 (102; 0)
+ 11252: >>>>> 1.380000000e+02 <= 1.630000000e+02 18.1% (176; 0)
+ 14948: mip = 1.380000000e+02 <= 1.620000000e+02 17.4% (200; 35)
+ 18811: mip = 1.380000000e+02 <= 1.620000000e+02 17.4% (266; 35)
+ 22402: mip = 1.380000000e+02 <= 1.620000000e+02 17.4% (330; 36)
+ 25362: mip = 1.380000000e+02 <= 1.620000000e+02 17.4% (384; 36)
+ 28609: mip = 1.380000000e+02 <= 1.620000000e+02 17.4% (457; 36)
+ 29844: >>>>> 1.400000000e+02 <= 1.620000000e+02 15.7% (484; 36)
+ 33482: mip = 1.400000000e+02 <= 1.620000000e+02 15.7% (492; 108)
+ 36688: mip = 1.400000000e+02 <= 1.620000000e+02 15.7% (557; 108)
+ 40050: mip = 1.400000000e+02 <= 1.620000000e+02 15.7% (639; 109)
+ 43326: mip = 1.400000000e+02 <= 1.620000000e+02 15.7% (687; 109)
Time used: 60.0 secs. Memory used: 6.4 Mb.
+ 43866: mip = 1.400000000e+02 <= 1.620000000e+02 15.7% (698; 109)
TIME LIMIT EXCEEDED; SEARCH TERMINATED
Time used: 60.3 secs
Memory used: 6.7 Mb (7071653 bytes)
```

The integer optimization begins afterward, which is generally executed using a **Branch and Bound** procedure. Branching is used to check different values of integer variables one by one, and bounding is used to eliminate branches before checking them.

Output rows are printed regularly, either periodically or after an important event, such as finding a better solution.

  * The numbers on the left, ending at 43866, denote the number of "steps" taken by the solution algorithm.
  * The column to the right of it is the currently known **best integer solution** (or "MIP," Mixed-Integer Program). This solution can only improve (increase in a maximization problem) during the search.
      * Initially, the solver had not found any integer solutions.
      * The first solution found involved **138 tiles**.
      * In 60 seconds, this was improved to **140 tiles**, at which point the optimization stopped due to the time limit.
  * The column on the far right denotes the current **best bound**. This is an upper limit on the objective of any feasible solution. This value can only decrease during the search. In the example, it is initially 163 (based on the LP relaxation) and is slightly improved to 162.

This means that even though the solution procedure didn't finish, there cannot be more than **162 tiles**.

At any time, the optimal solution lies somewhere between the best solution and the best bound. The solver constantly tries to improve both values to close the difference between them. If they are equal, the optimal solution has been found. Sometimes the current best solution is called a **lower bound** because it is a lower bound for the final optimal solution. (Note that if the objective is minimized, the same concepts are used, but all relationships are reversed.)

The relative difference between the best solution and the best bound is called the **integrality gap**, usually expressed as a percentage. The integrality gap is a measure of our certainty about the optimal solution. The solver aims to minimize the gap, eventually reaching zero.

Concluding the results of the large case, we have a feasible solution of **140 tiles**, but the true optimal solution could be as large as **162**. The gap after one minute is **$15.7\%$**. It is possible that 140 is indeed the optimal solution, but the solver has not definitively proven it. Note that these results may vary slightly depending on the machine or the version of `glpsol` used.

What options do we have for a large model that `glpsol` failed to solve optimally? The options depend on the exact situation, but it must be acknowledged that some problems are simply inherently very difficult and cannot be solved quickly.

  * **Spend More Time Solving:** Unfortunately, improvement usually slows down after a certain point. Finishing the problem may take an unacceptably long time.
  * **Formulate a Better Model:** We can try a wide range of techniques, including choosing different decision variables and applying **tightening constraints** (like cutting planes) that help the solver by eliminating parts of the search space, typically improving the model's relaxation. Sometimes, a better formulation can improve efficiency by orders of magnitude.
  * **Choose a Different Solver or Machine:** There are more powerful LP/MILP solvers available than `glpsol`. Examples of free software include CBC and lpsolve, but even stronger commercial solvers exist. `glpsol` supports exporting the model into a commonly supported format like CPLEX-LP, which most MILP solvers can read. There can be surprising performance differences between solvers.
  * **Adjust Solver Options:** Even `glpsol` has options that alter the solution algorithms and can be helpful, including enabling heuristics and non-default solution methods.

We will now demonstrate the last option: running `glpsol` again, but with the following two heuristic configuration options enabled:

  * **Feasibility Pumping** (`--fpump` option): This is a heuristic that aims to find good integer solutions early in the optimization procedure. This can help the solver later by eliminating branches with objective values that are too low.
  * **Cuts** (`--cuts` option): This allows all available cuts known to `glpsol` to be used in the model. **Cuts** are constraints automatically added to the model to improve the solution algorithm by trimming the search space. The cuts enabled by this option are the Gomory, Mixed-Integer Rounding, Clique, and Mixed Cover cuts; each of these can be individually enabled or disabled.

<!-- end list -->

```bash
glpsol -m tiling.mod -d example.dat --fpump --cuts
```

These heuristics often help solve the problem, sometimes dramatically. However, there are cases where they don't help, and the overhead might even slow down the solution process.

The output produced by `glpsol` when solving the $30 \times 30$ instance with the `--fpump` and `--cuts` options is as follows:

```
Integer optimization begins...
Long-step dual simplex will be used
Gomory's cuts enabled
MIR cuts enabled
Cover cuts enabled
Number of 0-1 knapsack inequalities = 784
Clique cuts enabled
Constructing conflict graph...
Conflict graph has 896 + 1004 = 1900 vertices
+ 1896: mip = not found yet <= +inf (1; 0)
Applying FPUMP heuristic...
Pass 1
Solution found by heuristic: 153
Pass 1
Pass 2
Pass 3
Pass 4
Pass 5
Cuts on level 0: gmi = 12; clq = 1;
+ 2759: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (15; 0)
+ 5134: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (44; 0)
+ 7111: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (73; 1)
+ 8009: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (89; 1)
+ 9294: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (106; 1)
+ 10509: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (124; 1)
+ 12685: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (141; 2)
+ 14071: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (160; 2)
+ 15544: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (181; 2)
+ 16909: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (195; 3)
+ 17875: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (211; 3)
Time used: 60.2 secs. Memory used: 10.8 Mb.
+ 18551: mip = 1.530000000e+02 <= 1.620000000e+02 5.9% (225; 3)
TIME LIMIT EXCEEDED; SEARCH TERMINATED
Time used: 60.5 secs
Memory used: 13.1 Mb (13730993 bytes)
```

We can see evidence of the preprocessing and intermediate work associated with some of the cuts. However, the most significant improvement came from the **feasibility pumping**, which found a feasible solution of **153 tiles**. This is substantially better than the 140 found previously. The integrality gap is also much smaller, at only **$5.9\%$** instead of $15.7\%$.

Note that if we are uncertain about the complexity of our model, we can always omit time limits and simply terminate `glpsol` manually, as the current best solution is periodically reported in the output anyway. In this case, however, the best found solution itself is **not reported** because any subsequent printing work after the `solve` statement is skipped. In contrast, if `glpsol` stops on its own before finding the optimal solution (due to a time limit, for example), then the variables are all set according to the current best solution, and that specific solution will be printed. For example, this is the reported solution with **153 tiles** placed:

```
Max. Cross Tiles (30x30): 153
..+....+.....+...+....+....+..
.+#+.++#+.+.+#+++#+.++#+.++#+.
..+++#++++#++++#++++#++++#+++.
.++#++++#+++#+.+++#++++#++++#+
+#++++#+++..+.++#++++#++++#++.
.+++#++++#+.++#++++#++++#+++..
.+#++++#++++#++++#++++#++++#+.
..+.+#++++#++++#++++#++++#+++.
..+..+++#++++#++++#++++#++++#+
.+#+++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#+++..
+#+.+++#++++#++++#++++#++++#+.
.++.+#++++#++++#++++#++++#+++.
.+#+.+++#++++#++++#++++#++++#+
..++.+#++++#++++#++++#++++#++.
.++#+.+++#++++#++++#++++#+++..
+#++.++#++++#++++#++++#++++#+.
.+.++#++++#++++#++++#++++#+++.
.++#++++#++++#++++#++++#++++#+
+#++++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#+++..
.+#++++#++++#++++#++++#++++#+.
..+++#++++#++++#++++#++++#+++.
.++#++++#++++#++++#++++#++++#+
+#++++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#++.+.
.+#++++#++++#++.+#++++#+++.+#+
..+++#++++#+++..++.+#++++#+++.
..+#++.+#++.+#++#+..+.+#+++#+.
...+....+....+..+......+...+..
```

We can observe that the inside of the $30 \times 30$ square is almost perfectly filled with cross tiles. The gap between the best-found solution (153) and the potential best (162) remains open for now.

-----

### 7.3 Assignment Problem ðŸ“Ž

Another well-known optimization problem, the **assignment problem** [21], is presented in this section.

-----

 
