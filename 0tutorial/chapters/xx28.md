---------------
Problem 38.
Determine the maximum number of non-overlapping crosses in an N × M grid.
One might argue that the general problem itself is very special in the class of tiling problems.
Indeed, many tiling problems are not solvable effectively by mathematical programming tools. Here,
on the term general problem, we mean a general model section which is applicable to any problem
instance.
The data for the problem is very short: only the dimensions of the rectangular area must be
specified. Let us see some examples.
 
Problem 39.
Solve Problem 38, the rectangle tiling problem with crosses for the following rectangle sizes.

130

7.2. TILING THE GRID

MILP MODELS

Figure 8: Rectangular area imperfectly covered by some five-square cross tiles.
• 6×4
• 10 × 10
• 30 × 30
Probably the shortest data sections so far are required for this problem. The following is for the
smallest instance.
param Width := 6;
param Height := 4;
We use parameter names Width and Height to use for the dimensions of the rectangular region
to be tiled. These must be positive integers. Parameter Height represents N , which is the number
of rows, and Width represents M , which is the number of columns in the area. Rows are denoted by
numbers from 1 to N , while columns are denoted by numbers from 1 to M . The set of all squares,
called cells in the rectangular grid is the Cartesian product of the sets of rows and columns, having
a size of N · M . These are defined as shown below.
param Height, integer, >=1;
param Width, integer, >=1;
set Rows := 1 .. Height;
set Cols := 1 .. Width;
set Cells := Rows cross Cols;
At this point, the minimal requirement of data is defined in the model, but a concise implementation will require some more. Let us see first what kind of decisions we can make to describe a
tiling.
First, we want to do something like „deciding for all possible positions of a cross tile whether to
put a tile there or not”. This can be done with a binary variable introduced for each such position
as follows.
var place {(r,c) in Tiles}, binary;
Here, the set Tiles refer to some set not yet characterized, but listing all possible positioning
of cross tiles. Decisions for this place variable well determine all required properties of the tiling,
but an auxiliary variable will also be useful.
131

7.2. TILING THE GRID

MILP MODELS

var covered {(r,c) in Cells}, binary;
Here, covered is defined for each cell, and decides whether the cell is covered by a placed tile or
not. This helps us formulating constraints that each cell can only be covered at most once to avoid
overlapping tiles.
As usual, the value of 1 means yes, and 0 means no for all of these binary variables. For instance,
a place variable is 1 if the tile is placed on the particular position, and a covered variable is 1 if
the particular cell is covered by some tile.
Before going forward, we must somehow characterize the set Tiles describing all possible tile
positions. Luckily, the five-cell cross is symmetric: rotating or reflecting it does not yield a different
orientation. That means the only difference between tile positions is shifting. In short, we might
call it position. Therefore a binary variable is introduced for each possible position of the tile, and
the set Tiles just contains these positions.
Note that if we do want to tile with asymmetric shapes where multiple orientations are possible,
we must define different binary decision variables for each different orientation and position. In
that case, the Tiles set would need a third index dimension to denote orientation, apart from
the first two dimensions denoting position. But since the cross only has a single orientation, that
index dimension is simply omitted from our model, and Tiles is just a two-dimensional set listing
positions.
Finally, let us decide how two-dimensional coordinates may define positioning of tiles. For this
purpose, we define an anchor point of the cross tile as the central cell of the tile. The set Tiles
will enlist all possible anchor points of correctly positioned tiles. This is valid, because different
positions of tiles have different anchor points.
The selection of the anchor point relative to the tile can be arbitrary, it just needs to be consistent
throughout the model. It is also possible to be outside the tile, for example, it could also be the
corner cell of the 3 × 3 square containing the cross tile.
The last thing which remains is to determine the anchor points. All correctly positioned cross
tiles in the rectangular grid must be considered. Clearly, because the anchor point is a cell inside the
tile, the anchor point of a correctly positioned tile must be in the rectangular grid as well. However,
not all cells of the rectangular grid can be anchor points. For example, no cells at the edge of the
rectangle are valid choices, as it cannot cover area outside the region. Moreover, the corner cells of
a rectangular grid cannot even be covered by any correctly positioned cross tiles.
Based on an anchor (r,c), we can define all cells of the cross tile if placed onto that anchor.
This is done by the CellsOf set. Note that this set statement is itself indexed over all cells (that
is, possible anchors), which mean that N × M different sets of 5 cells each are defined.
set CellsOf {(r,c) in Cells} :=
{(r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)};
The set Tiles of correct tile positions (anchor points) are those for which these 5 cells defined
in CellsOf are all within the rectangular area.
set Tiles, within Cells :=
setof {(r,c) in Cells: CellsOf[r,c] within Cells} (r,c);
Of course, we could have answered the question about correct anchor points right at the beginning: these are exactly the cells not on the edges. However, this approach is chosen for two
reasons.
• Defining all cells of the placed tile, and keeping only those positions that are entirely in the
region to be tiled is a very general approach. It would work not only on arbitrary tiles, but
on arbitrary regions as well, on a finite grid.
132

7.2. TILING THE GRID

MILP MODELS

• The sets CellsOf provide us a shorter model formulation, as we will see.
The definitions CellsOf and Tiles must be placed before the definition of variable place.
We need two things to be established by constraints. The first is the calculation of the auxiliary
variable covered for each cell. The second is that each cell can only be covered at most once.
Surprisingly, both can be done in a single constraint statement as follows.
s.t. No_Overlap {(r,c) in Cells}: covered[r,c] =
sum {(x,y) in Tiles: (r,c) in CellsOf[x,y]} place[x,y];
In words, for each cell we add the place variables of all tiles that cover that cell. As place is
an integer variable, the sum exactly yields the number of tiles covering that particular cell. This
can either be zero, or one, but two or more is forbidden. The latter is implicitly assured because
the sum equals the single binary variable covered[r,c] and it cannot be more than one, as it is a
binary variable.
Note that in fact, variable covered does not even need to be formulated as binary. The constraint
ensures that its value is integer, because it is obtained as a sum of integer variables. The only required
property of variable covered is its upper bound, 1.
This knowledge might be useful if the complexity of the problem is analyzed. Generally, the more
binary variables are there, the more difficult the model is. However, as covered is not necessarily
binary, it is not expected to increase complexity that much. The true integer nature and difficulty
of the problem is based on the place variable, denoting tile placements. Nevertheless, marking
covered binary might alter the course of the solution algorithm.
The objective is the number of tiles placed in total.
maximize Number_of_Crosses:
sum {(r,c) in Tiles} place[r,c];
After the solve statement, a good way to print the solution is to visualize the tiling itself with
some character graphic.
for {r in Rows}
{
for {c in Cols}
{
printf "%s",
if (!covered[r,c]) then "."
else if ((r,c) in Tiles) then (if (place[r,c]) then "#" else "+")
else "+";
}
printf "\n";
}
The output is textual, so we must print each row in one line, and inside a row, we print each
cell denoted by the column. A single character is printed for each cell so that the whole rectangular
area looks correctly adjusted, for fixed-width fonts.
• If a cell is not covered, a dot (.) is put there.
• If a cell is an anchor point of a placed tile, it is denoted by a hash mark (#).
• Otherwise, if the cell is covered by a cross but not its center, then it is denoted by a plus sign
(+).
133

7.2. TILING THE GRID

MILP MODELS

Note that nested if operators are used to obtain the desired result. One might argue that there
is an unnecessary if, because of the two cases both ending in a + sign. The point is that we first
check whether (r,c) is a proper anchor point or not, and only if it is, then we check the value of the
place[r,c] variable. We do this because if place[r,c] is referred for a non-anchor point (r,c),
then out of domain error occurs, as the variable place is only defined for anchor points. Note that
if an else value is omitted, it is assumed to be zero.
The model section for Problem 38 is ready.
param Height, integer, >=1;
param Width, integer, >=1;
set Rows := 1 .. Height;
set Cols := 1 .. Width;
set Cells := Rows cross Cols;
set CellsOf {(r,c) in Cells} :=
{(r,c),(r+1,c),(r-1,c),(r,c+1),(r,c-1)};
set Tiles, within Cells :=
setof {(r,c) in Cells: CellsOf[r,c] within Cells} (r,c);
var covered {(r,c) in Cells}, binary;
var place {(r,c) in Tiles}, binary;
s.t. No_Overlap {(r,c) in Cells}: covered[r,c] =
sum {(x,y) in Tiles: (r,c) in CellsOf[x,y]} place[x,y];
maximize Number_of_Crosses:
sum {(r,c) in Tiles} place[r,c];
solve;
printf "Max. Cross Tiles (%dx%d): %g\n",
Height, Width, Number_of_Crosses;
for {r in Rows}
{
for {c in Cols}
{
printf "%s",
if (!covered[r,c]) then "."
else if ((r,c) in Tiles) then (if (place[r,c]) then "#" else "+")
else "+";
}
printf "\n";
}
end;
Solving the model for the smallest instance of a 6 × 4 area shows that no more than two cross
tiles can fit in such a small area. One possible construction is shown below, reported by the model
134

7.2. TILING THE GRID

MILP MODELS

output.
Max. Cross Tiles (4x6): 2
....+.
.+.+#+
+#+.+.
.+....
The medium instance of a 10 × 10 area is still solved very fast. At most 13 cross tiles fit in the
area, the solution reported is the following.
Max. Cross Tiles (10x10): 13
.+...+..+.
+#+.+#++#+
.++..+.++.
.+#+.++#+.
..+++#+++.
.++#++++#+
+#++.+#++.
.++..++.+.
.+#++#++#+
..+..+..+.
The large instance of 30 × 30 cells was included to show what happens when the model is really
big, and thus cannot be solved fast. In such cases, the solver would take an eternity to complete.
Therefore, a time limit of 60 seconds is provided. In command line, this can be done by adding the
--tmlim 60 as arguments to glpsol.
glpsol -m tiling.mod -d example.dat --tmlim 60
If the time limit option is omitted, there is no time limit. Note that the limit given this way is
not a strong bound of running time actually available for the solver: glpsol tends to exceed this
limit slightly, especially if preparing steps themselves are tedious.
Running glpsol with a one-minute time limit produced the following output.
GLPK Integer Optimizer, v4.65
901 rows, 1684 columns, 5604 non-zeros
1684 integer variables, all of which are binary
Preprocessing...
896 rows, 1680 columns, 4816 non-zeros
1680 integer variables, all of which are binary
Scaling...
A: min|aij| = 1.000e+00 max|aij| = 1.000e+00 ratio =
Problem data seem to be well scaled
Constructing initial basis...
Size of triangular part is 896
Solving LP relaxation...
GLPK Simplex Optimizer, v4.65
896 rows, 1680 columns, 4816 non-zeros
*
0: obj = -0.000000000e+00 inf =
0.000e+00 (784)
Perturbing LP to avoid stalling [253]...

135

1.000e+00

7.2. TILING THE GRID

MILP MODELS

Removing LP perturbation [1896]...
* 1896: obj =
1.631480829e+02 inf =
OPTIMAL LP SOLUTION FOUND

0.000e+00 (0) 12

Note that the original model contained a vast 1684 binary variables, the preprocessing only
removed four of them (probably the corner cells because those cannot by any means be covered, but
we cannot verify this claim).
After that, the LP-relaxation of the MILP model is solved. The rows regarding perturbation
tell us that the solver made countermeasures to avoid stalling, which is a possible infinite loop in
the Simplex algorithm. The presence of this message indicates that the LP solved is itself difficult,
very big or have special properties. The last line shows us that 163.15 was the optimal solution of
the LP relaxation. This information is valuable, because we know that the optimal solution of the
actual MILP model cannot be more than 163. The solution algorithm also uses the result of the LP
relaxation.
Integer optimization begins...
Long-step dual simplex will be used
+ 1896: mip =
not found yet <=
+inf
+ 4865: mip =
not found yet <=
1.630000000e+02
+ 9025: mip =
not found yet <=
1.630000000e+02
+ 11252: >>>>>
1.380000000e+02 <=
1.630000000e+02
+ 14948: mip =
1.380000000e+02 <=
1.620000000e+02
+ 18811: mip =
1.380000000e+02 <=
1.620000000e+02
+ 22402: mip =
1.380000000e+02 <=
1.620000000e+02
+ 25362: mip =
1.380000000e+02 <=
1.620000000e+02
+ 28609: mip =
1.380000000e+02 <=
1.620000000e+02
+ 29844: >>>>>
1.400000000e+02 <=
1.620000000e+02
+ 33482: mip =
1.400000000e+02 <=
1.620000000e+02
+ 36688: mip =
1.400000000e+02 <=
1.620000000e+02
+ 40050: mip =
1.400000000e+02 <=
1.620000000e+02
+ 43326: mip =
1.400000000e+02 <=
1.620000000e+02
Time used: 60.0 secs. Memory used: 6.4 Mb.
+ 43866: mip =
1.400000000e+02 <=
1.620000000e+02
TIME LIMIT EXCEEDED; SEARCH TERMINATED
Time used:
60.3 secs
Memory used: 6.7 Mb (7071653 bytes)

(1; 0)
(44; 0)
(102; 0)
18.1% (176; 0)
17.4% (200; 35)
17.4% (266; 35)
17.4% (330; 36)
17.4% (384; 36)
17.4% (457; 36)
15.7% (484; 36)
15.7% (492; 108)
15.7% (557; 108)
15.7% (639; 109)
15.7% (687; 109)
15.7% (698; 109)

The integer optimization begins afterwards, which, in general, is usually a Branch and Bound
procedure. Branching is used to check different values of integer variables one by one, and bounding
is used to rule out branches before checking. We do not go into details here.
Rows of output are regularly printed, either periodically or after some important event, for
example when a better solution is found.
The numbers on the left, ending in 43866, denote the number „steps” made by the solution
algorithm.
The column right of it is the actually known best solution for the problem. If a solution branch is
known to be unable to produce a better result (for example, if the relaxation of that branch is even
worse), then that branch can be skipped without sacrificing solutions. This speeds up the procedure
a lot. The best solution cannot decrease during the search. We can observe the following.
• Initially, the solver had not found any solutions.
• The first solution found involved 138 tiles.
136

7.2. TILING THE GRID

MILP MODELS

• In 60 seconds this was improved to 140 tiles, then optimization stopped due to the time limit.
The column to the right denotes the current best bound. This is an upper limit on the objective
of any feasible solutions. This cannot increase during the search, but can decrease, which means
improvement. In the example, it is first 163 based on the LP relaxation, then slightly improved to
162. This means that although the solution procedure did not finish, there cannot be more than
162 tiles.
At any time, the optimal solution of the problem lies somewhere between the best solution and
the best bound. The solution procedure therefore tries to constantly improve both of these values
to eliminate the difference between them. If they are equal, then the optimal solution is found.
Sometimes the current best solution is called a lower bound, because it is a lower bound for the
final optimal solution. Note that if the objective is not maximized but minimized, the same notions
are used, but all relations are the opposite.
The relative difference between the best solution and the best bound is called the integrality
gap, which is usually given in percent. The integrality gap is used as a measure of our knowledge
about the optimal solution. The solver tries to minimize the gap, eventually reaching zero.
Concluding the results of the large case, we have a solution for 140 tiles, but the actual optimal
solution can be as large as 162, the gap after one minute is 15.7%. It is possible that 140 is indeed
the optimal solution, but it is not proven by the solver for sure. Note that these results may be
slightly different for each run, especially if different machines or glpsol versions are used.
What can we do about a large model, which glpsol failed to solve? There are different options
based on the exact situation. Note that each option is limited: some problems are just naturally
very difficult and simply cannot be solved fast.
• Spend more time solving. Unfortunately, improvement usually tends to slow down after some
point. Finishing may take an unacceptably long time.
• Formulate a better model solving the same problem. There is a wide range of practices we
can try, including choosing different decision variables, and applying tightening constraints
which help the solver by cutting out parts of the search space, usually improving the model
relaxation. Sometimes, a better formulation can improve efficiency in magnitudes.
• Choosing a different solver or machine. Note that there are more effective LP/MILP solvers
than glpsol. Example free software are CBC and lpsolve, but even stronger commercial
solvers exist. Note that glpsol supports exporting of the model into a commonly supported
format like CPLEX-LP, which is supported by most MILP solvers. There can be surprising
performance differences between solvers.
• Even glpsol has some options which alter the solution algorithms and can be helpful, including
the usage of heuristics and non-default solution algorithms.
We will now demonstrate the last option: running glpsol again, but now with the following two
heuristic configuration options enabled:
• Feasibility pumping. (--fpump option) This is a heuristic which aims to obtain good
solutions early on in the optimization procedure. This can help the solver later by ruling out
branches with too low objective values.
• Cuts. (--cuts option) This allows all the available cuts glpsol knows to be used in the model.
Cuts are constraints automatically added to the model to improve the solution algorithm by
trimming the search space. These are used for solving MILP models. The cuts enabled by
the option are the Gomory, Mixed-Integer Rounding, Clique and Mixed Cover cuts, note that
each of these can be enabled or disabled individually.

137

7.2. TILING THE GRID

MILP MODELS

glpsol -m tiling.mod -d example.dat --fpump --cuts
The mentioned heuristics often help in solving the problem, sometimes dramatically. But again,
there are cases where they do not help, furthermore, the overhead slows down the solution procedure.
The output produced by glpsol by solving the 30 × 30 instance, now with the --fpump and
--cuts options is the following.
Integer optimization begins...
Long-step dual simplex will be used
Gomory's cuts enabled
MIR cuts enabled
Cover cuts enabled
Number of 0-1 knapsack inequalities = 784
Clique cuts enabled
Constructing conflict graph...
Conflict graph has 896 + 1004 = 1900 vertices
+ 1896: mip =
not found yet <=
+inf
Applying FPUMP heuristic...
Pass 1
Solution found by heuristic: 153
Pass 1
Pass 2
Pass 3
Pass 4
Pass 5
Cuts on level 0: gmi = 12; clq = 1;
+ 2759: mip =
1.530000000e+02 <=
1.620000000e+02
+ 5134: mip =
1.530000000e+02 <=
1.620000000e+02
+ 7111: mip =
1.530000000e+02 <=
1.620000000e+02
+ 8009: mip =
1.530000000e+02 <=
1.620000000e+02
+ 9294: mip =
1.530000000e+02 <=
1.620000000e+02
+ 10509: mip =
1.530000000e+02 <=
1.620000000e+02
+ 12685: mip =
1.530000000e+02 <=
1.620000000e+02
+ 14071: mip =
1.530000000e+02 <=
1.620000000e+02
+ 15544: mip =
1.530000000e+02 <=
1.620000000e+02
+ 16909: mip =
1.530000000e+02 <=
1.620000000e+02
+ 17875: mip =
1.530000000e+02 <=
1.620000000e+02
Time used: 60.2 secs. Memory used: 10.8 Mb.
+ 18551: mip =
1.530000000e+02 <=
1.620000000e+02
TIME LIMIT EXCEEDED; SEARCH TERMINATED
Time used:
60.5 secs
Memory used: 13.1 Mb (13730993 bytes)

(1; 0)

5.9% (15; 0)
5.9% (44; 0)
5.9% (73; 1)
5.9% (89; 1)
5.9% (106; 1)
5.9% (124; 1)
5.9% (141; 2)
5.9% (160; 2)
5.9% (181; 2)
5.9% (195; 3)
5.9% (211; 3)
5.9% (225; 3)

Note that we can see traces of preprocessing and mid-time work associated with some of the cuts.
However, the absolute improvement was due to the feasibility pumping, which obtained a feasible
solution of 153 tiles. This is substantially better than the 140 before. The gap is much smaller, just
5.9% instead of 15.7%.
Note that if we are unsure about the complexity of our model, we can always omit time limits,
and simply kill glpsol on demand, as the current best solution is periodically reported in the output
anyways. But in this case, the best found solution itself is not reported, as any subsequent printing
work after the solve statement is skipped. In contrast, if glpsol stops on itself before finding
138

7.3. ASSIGNMENT PROBLEM

MILP MODELS

the optimal solution, due to time limit for example, then the variables are all set according to the
current best solution instead, and that particular solution will be printed out. For example, this is
the reported solution with 153 tiles placed.
Max. Cross Tiles (30x30): 153
..+....+.....+...+....+....+..
.+#+.++#+.+.+#+++#+.++#+.++#+.
..+++#++++#++++#++++#++++#+++.
.++#++++#+++#+.+++#++++#++++#+
+#++++#+++..+.++#++++#++++#++.
.+++#++++#+.++#++++#++++#+++..
.+#++++#++++#++++#++++#++++#+.
..+.+#++++#++++#++++#++++#+++.
..+..+++#++++#++++#++++#++++#+
.+#+++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#+++..
+#+.+++#++++#++++#++++#++++#+.
.++.+#++++#++++#++++#++++#+++.
.+#+.+++#++++#++++#++++#++++#+
..++.+#++++#++++#++++#++++#++.
.++#+.+++#++++#++++#++++#+++..
+#++.++#++++#++++#++++#++++#+.
.+.++#++++#++++#++++#++++#+++.
.++#++++#++++#++++#++++#++++#+
+#++++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#+++..
.+#++++#++++#++++#++++#++++#+.
..+++#++++#++++#++++#++++#+++.
.++#++++#++++#++++#++++#++++#+
+#++++#++++#++++#++++#++++#++.
.+++#++++#++++#++++#++++#++.+.
.+#++++#++++#++.+#++++#+++.+#+
..+++#++++#+++..++.+#++++#+++.
..+#++.+#++.+#++#+..+.+#+++#+.
...+....+....+..+......+...+..
We can observe that the inside of the 30 × 30 square is almost perfectly filled with cross tiles.
The gap between the best found 153 and the possibly best 162 is left open for now.

7.3

Assignment problem

Another well-known optimization problem is presented in this section, which is the assignment
problem [21].
