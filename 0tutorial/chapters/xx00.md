

## Chapter 1

## Introduction

This Tutorial is intended to provide an **overview** of mathematical programming and Operations Research in general, using the development of Linear Programming (LP) and Mixed-Integer Linear Programming (MILP) models with the GNU MathProg (GMPL) modeling language.

Optimization involves finding the **best** solution in real-world situations. While this is often achievable using common sense or simple logic, many cases require advanced approaches. Typically, a mathematical model of the problem is created, and solution methods are designed by leveraging the best available mathematical theory, computer science, and existing technology.

The primary difficulty often lies in the **vast number of potential solutions** to a problem, making it impossible to evaluate each one, even with the fastest computers available. In many situations, instead of seeking a perfect solution, "rules of thumb," also known as **heuristic methods**, are employed. These methods simplify the underlying problem model, reduce the set of possible solutions to investigate, or both. This approach sacrifices optimality but makes finding a reasonably good solution computationally feasible. Nevertheless, even in these cases, finding such a solution usually requires some form of optimization, for example, to select the best option from a few candidates.

When faced with an optimization problem, a "conventional" approach to solving it is to design, implement, and apply a specific algorithm, which usually requires a programming language. The concept of an algorithm is very broad, and its implementation depends on the chosen programming language. However, it typically involves describing the data structures used and the sequence of steps to be executed. This is what most common programming languages, such as C/C++, Java, Python, and others, facilitate. The commonality among these languages is that the programmer addresses not only the "What?" (the goal of the algorithm) but also the "How?" (the exact steps to be performed with the data). For instance, Dijkstra’s algorithm can find the shortest path in a graph, Kruskal’s algorithm can find the cheapest spanning tree of a graph, or the Ford-Fulkerson algorithm can find the optimal flow in a flow network.

Mathematical programming methods offer an alternative. Instead of describing the steps to be taken, **only the mathematical model** of the real-world problem is formulated. This model consists of statements like equations, inequalities, logical expressions, and others that correspond to the rules governing the real-world problem and its solution. The real-world problem is then solved by finding solutions to the system of these equations, inequalities, or other statements. However, the programmer is only responsible for formulating the mathematical model, not for the algorithm used to solve it. The latter is actually handled by **solver software**, which is designed to solve a particular class of mathematical programming models.

This Tutorial focuses on a subset of mathematical programming methods, specifically Linear Programming (LP) and Mixed-Integer Linear Programming (MILP) models, which can be formulated using the GNU MathProg (GMPL) modeling language [1]. **Tackling** real-world optimization problems by formulating a mathematical programming model and solving it with solver software is a valuable skill set that differs substantially from "conventional" programming. Nevertheless, an algorithm designed for a specific optimization problem may be significantly faster than a general mathematical programming model: many well-studied optimization problems have state-of-the-art algorithmic solutions. However, for some problems—even those with decent algorithms—designing a mathematical programming model can be surprisingly quick and easy. Mathematical programming models are also more flexible if the real-world problem itself changes.

The algorithms that solvers utilize to actually solve our formulated mathematical programming model are an interesting topic in their own right, but they are not the focus here. In short, the methods for formulating these models are more important than the methods for solving these mathematical models to optimality.

The GNU MathProg modeling language was selected because, along with its solver `glpsol` in the GNU Linear Programming Kit [2], these tools are relatively easy to understand and are available under the GNU General Public License. Many other free and commercial tools exist for both formulating and solving not only MILP but more general mathematical programming models. Many of these tools are much faster than `glpsol`.

Several other learning resources are available on this subject. The basic installation of GLPK also includes a number of example models, including complex ones. GLPK also has a Wikibooks project that covers usage in great detail [3]. We would like to recommend Hegyháti’s Linear Programming tutorial [4]. Furthermore, many useful books and lecture materials can be found on the Hungarian Tankönyvtár homepage [5].

This Tutorial presents the basics of the language and some key problems that can be easily solved by mathematical programming tools, offering insight into the power of optimization using mathematical, and particularly MILP, models. Some algorithmic solution methods for specific problems are also presented.

The remainder of the Tutorial is organized as follows:

* Chapter 2 provides an introduction to the main goals, tools, and concepts of optimization.
* Chapter 3 introduces the basic usage of GNU MathProg and the `glpsol` solver. A minimal, "Hello, World!" model file is shown.
* In Chapter 4, linear equation systems are solved using GNU MathProg, with gradually improved model implementations. This part aims to demonstrate language features required to develop concise and general LP/MILP models, most importantly indexing and the separation of model and data sections.
* Chapter 5 introduces the production problem, a simple optimization problem. Incremental model development is the focus, demonstrated through changes and extensions to the problem definition. Some additional language features and integer variables are used.
* Chapter 6 presents another simple optimization problem, the transportation problem. Modeling techniques for some cost functions, which can be part of more complex problems, are introduced.
* Chapter 7 discusses some more challenging problems requiring MILP model formulations. Advanced modeling and coding techniques, along with possible graphical outputs, are presented.
* Chapter 8 provides a brief insight into LP/MILP solving algorithms, explaining how software tools may work in the background.

This Tutorial contains attachments. All GNU MathProg codes, including model and data files, and their outputs mentioned in the text, can be found, grouped by chapters and sections. (A more detailed description is available in the attachment itself.)

For learning purposes, it is recommended to manually examine and solve the models with their corresponding data file(s) to investigate the results. Note that most of the codes and the more important output file segments are included, either fully or partially, within the text of the Tutorial itself, using a specific format.

GNU MathProg code for model files is formatted like this.

> GNU MathProg code of data sections that may go to
> separate data files are formatted like this.

> Output generated by the solver is formatted like this.

> Commands to be run are formatted like this.

If you have questions or find any errors in this Tutorial, please feel free to contact us at eles@dcs.uni-pannon.hu. We hope you will find this material useful.

