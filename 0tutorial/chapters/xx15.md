

## Problem 17.

Given a set of **raw materials** and a set of **products**. There is also a set of **recipes** defined.

Each recipe describes the ratio in which it **consumes raw materials** and **produces products**; these ratios are arbitrary nonnegative numbers. Each recipe may be utilized in an arbitrary amount, which is named its **volume**.

  * There is a **unit cost** defined for each raw material, and a **unit revenue** for each product.
  * There can be **minimal and maximal total consumption** amounts defined for each raw material, and **minimal and maximal total production** amounts defined for each product.
  * For practical purposes, the total cost of consumed raw materials is limited: it **cannot exceed a given value**, which represents the initial funds available for raw material purchase.

Find the optimal production, where recipes are utilized in arbitrary volumes, such that all the limits on consumption and production are satisfied, and the **total profit is maximal**. The total profit is the difference between the total revenue from products and the total costs of raw materials consumed.

-----

### Model Implementation

Let's start by implementing this problem without a specific example. We will find that its implementation is very similar to the original production problem. The first step is to "read" all the available data for future use. For this reason, there are three sets in the model: the set of raw materials, the set of products, and the set of recipes.

```
set Raws;
set Products;
set Recipes;
```

Note that the problem definition doesn't exclude the case where the **same material is both a raw material and a product** in the recipes. This is actually natural in real-world situations: some material is produced by one recipe and consumed by another. However, questions regarding **timing** would arise if we took this case into account. For instance, if a material is consumed as a raw material in a second recipe, it must first be produced by the first recipe. This would require the production according to the first recipe to happen before the execution of the second. Alternatively, the production could describe an equilibrium where amounts must be maintained, so timing is irrelevant. Given the complexity of these possibilities, we will not go into the details. For simplicity, we assume that **raw materials and products are distinct**.

To ensure that raw materials are indeed distinct from products, a `check` statement is introduced. We explicitly state that the **intersection** of the set of raw materials and the set of products must contain exactly zero elements. If this condition is not met, model construction fails immediately, as it should.

```
check card(Raws inter Products) == 0;
```

For each recipe, there are ratios for both the raw materials and the products. Because these are two different sets, defining them would typically require two different parameters: one for the ratios of raw materials in each recipe and one for the ratios of products in each recipe. This would hold true for other parameters as well.

Instead, we introduce the concept of **materials** in our model. We simply call raw materials and products together as materials. In GNU MathProg, it is legal to introduce a set that is calculated on the spot based on other sets.

```
set Materials := Products union Raws;
```

Since we assumed that no material is both a product and a raw material, we can further assume that each raw material is represented in the union once, as is each product, and these are all distinct. Now, with the new set, we can define the necessary parameters in a compact way.

```
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
```

The parameters **`Min_Usage`** and **`Max_Usage`** denote the lower and upper bound for each material in the model. These two parameters are indexed over the `Materials` set. For raw materials, `Min_Usage` and `Max_Usage` mean limits for **total consumption**. For products, these parameters mean limits for **total production**. Because each raw material and each product is represented in the `Materials` set exactly once, this definition unambiguously describes all the limits for both raw materials and products. Note that the default limits are **0** for the lower bound and a very large number, **$10^{100}$**, for the upper limit. So, technically, there is no limit by default.

The **`Value`** parameter works similarly; it represents **raw material costs** in the case of raw materials and **revenues** in the case of products. Both are nonnegative and default to zero.

The **`Recipe_Ratio`** parameter is for describing recipes. The only data needed for the recipes are the exact amounts of inputs consumed and outputs produced. With the common `Materials` set, this can be done with a single parameter. `Recipe_Ratio` is defined for all recipes and all materials. If the material is a raw material, it describes the **consumption amount**; if it is a product, it describes the **production amount**. We call this parameter "ratio" because it corresponds to the amounts consumed and produced when utilizing the recipe with a **volume of 1**. In general, because both inputs and outputs are proportional, the ratio must be multiplied by the volume to obtain the amounts consumed or produced.

Finally, there is a single numeric parameter, **`Initial_Funds`**. This serves as an **upper limit for raw material costs**. In practice, it's generally not possible to invest unlimited amounts into raw materials; there is usually a cap on this. Note that without such a restriction and any upper limits for consumption or production, it may be possible to gain unlimited profit by consuming an unlimited amount of raw materials to produce at least one product in unlimited amounts. By default, `Initial_Funds` is set to the extreme value of **$10^{100}$** again so that it does not change the model.

Now that all the parameters and sets are defined, let's see what the freedom in our model is. What we have to decide is the **volume for each recipe utilized**. This is slightly different than before, because decisions do not correspond to one particular product or raw material, but to a given recipe. If recipe amounts are defined, the solution is exactly determined, and all other information can be calculated, including raw material usages, production amounts, costs, revenues, the profit, and corresponding limitations.

```
var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
```

In our implementation, **`volume`** is the variable that denotes the volume each recipe shall be utilized in. This is a nonnegative value but can be zero and even fractional, as usual. As we mentioned, this single variable would be sufficient for model formulation, but we introduce a few **auxiliary variables** as well to write a compact and readable model.

The variable **`usage`** is the total "usage" of each material. It is indexed over the `Materials` set and works similarly to the parameters: it has a slightly different meaning for raw materials and products, but for simplicity, it can be denoted by the same single variable. For raw materials $r$, `usage[r]` is the **total consumption**, while for products $p$, `usage[p]` is the **total production** amount. Note that we can use `Min_Usage[m]` and `Max_Usage[m]` as bounds for this variable, which implements the limitations in our problem.

There is also a variable named **`total_costs`** which denotes the total costs of consumed raw materials, a variable **`total_revenue`** for the total revenue from products, and finally, a variable **`profit`** for the difference, which is our objective function. We set `Initial_Funds` as an upper bound for `total_costs`, which implements the maximum usage limitation.

Constraints are implemented next.

```
s.t. Material_Balance {m in Materials}: usage[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Total_Costs_Calc: total_costs = sum {r in Raws} Value[r] * usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage[p];
s.t. Profit_Calc: profit = total_revenue - total_costs;
```

Although this model is intended to be a generalization for both the production problem and the diet problem, supporting most of the features mentioned so far, there is only one key constraint: the **material balance** established by recipe utilization. The constraint states that the usage of each material, regardless of whether it is a raw material or a product, is calculated by adding, for each recipe, its volume multiplied by the ratio the material is represented in the recipe. This is exactly the same for both the original production problem and the diet problem.

We also define three additional constraints to calculate the values of the auxiliary variables `total_costs`, `total_revenue`, and `profit`. Note that even though parameters and variables (here `Value` and `usage`) are indexed over the `Materials` set, it is valid in GNU MathProg to index those parameters and variables over a **smaller set**. Using the original `Raws` and `Products` sets, we can sum up only for raw materials and only for products. Be careful: we can only index over the original domain, or its subset; otherwise, we will get an out-of-domain error (and the model is also guaranteed to be logically wrong).

The objective is straightforward: the profit itself.

```
maximize Profit: profit;
```

After solving the problem, we can print out the auxiliary variables, as well as the utilization volumes for each recipe and the total consumption and production amounts for each material. The full model section is ready as follows.

```
set Raws;
set Products;
set Recipes;
check card(Raws inter Products) == 0;
set Materials := Products union Raws;
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
s.t. Material_Balance {m in Materials}: usage[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Total_Costs_Calc: total_costs = sum {r in Raws} Value[r] * usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage[p];
s.t. Profit_Calc: profit = total_revenue - total_costs;
maximize Profit: profit;
solve;
printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}
for {r in Raws}
{
printf "Consumption of raw %s: %g\n", r, usage[r];
}
for {p in Products}
{
printf "Production of product %s: %g\n", p, usage[p];
}
end;
```

Although the model for arbitrary recipes is similar in nature to the former models, we implemented it all at once. The question arises: how can a large, complex model be implemented in GNU MathProg from scratch? Or, generally, in any mathematical programming language?

### Guide to Complex Model Implementation

There is no universal guide for modeling, but there are good **rules of thumb** to follow. The recommendation is the following, specifically for GNU MathProg:

1.  **Feasibility Assessment:** First, decide whether the problem can be effectively solved by **LP (or MILP)** models. Many problems simply cannot be, or only with very complicated workarounds, or there is a much more suitable algorithm or other method for solving it. This is the hardest part: you basically have to determine the **decision variables** and how the appropriate **search space** can be defined by adding constraints and other variables. If you are sure you can implement an LP (or MILP) model for the problem, then you can continue with the implementation of the model file.
2.  **Data Collection and Parameter Definition:** Collect all data that are available and needed. Define **sets and parameters** which will be provided by the data sections. Data files can be implemented at this point if example problem instances are available. If some data is missing or must be calculated afterward, you will always have the opportunity to introduce other sets and parameters and calculate other data in the model file.
3.  **Define Decision Variables:** Define the decision variables. Keep in mind that the values of all the variables should **exactly determine** what is happening in the real world. In particular, you must be able to calculate the objective and decide for each restriction whether it is violated or not, based on the variables.
4.  **Implement Constraints and Bounds:** Implement all possible rules as **constraints or bounds**. Keep in mind that there are two mistakes you can make: a problem may be **under-constrained** or **over-constrained**, or both.
      * In **under-constrained** problems, solutions remain in the search space that are infeasible in the problem but feasible in the model. These additional solutions may be found by the solver and reported as fake optimal solutions. Then, additional constraints must be defined to exclude those solutions, or existing constraints redefined to be more restrictive.
      * In **over-constrained** problems, interesting solutions are excluded from the search space, and therefore not found by the solver. Then, some constraints or bounds are too restrictive; you have to reformulate or remove them. Remember that you can always introduce new auxiliary variables in the model.
5.  **Define the Objective:** Define the objective function.
6.  **Reporting:** After the `solve` statement, report the relevant details of the solution found, in the desired format.

Complex models may have several dozen constraints, so how can you be sure you haven't forgotten any rules? One idea is to focus on **parameters or variables**. In many cases, parameters are used only once in the model. Even if not, you can list all the roles the parameter or variable must appear in the model: as a bound, a constraint, or an objective term, etc. Then it is easy to spot one that has been forgotten.

### Applications of the Arbitrary Recipe Model

Now that we have our model for arbitrary recipes ready, we will demonstrate how this works for all the problems mentioned so far in this chapter (with the exception of the maximum-of-minimum production amounts case).

#### 1\. Production Problem with Costs (Problem 14)

First, **Problem 14**, which introduced raw material costs, is solved. Since this is a pure production problem in the original way, a recipe is introduced to produce each of the products. All the limits are implemented by the `Min_Usage` parameter, while raw material costs and product revenues are implemented by the `Value` parameter. The data section is the following.

```
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;
param Min_Usage :=
B 21000
D 200
P2 100
;
param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A
B
C
D
P1
P2
P3 :=
MakeP1 200
25 3200
1
1
0
0
MakeP2
50 180 1000
1
0
1
0
MakeP3
0
75 4500
1
0
0
1
;
end;
```

If we solve it, we get exactly the same result as for the original model with raw costs. The optimal profit is **$1,577.45**, with production of 25.48 units of P1, 164.52 units of P2, and 10 units of P3. The output is the following.

```
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Consumption of raw A: 13322.6
Consumption of raw B: 31000
Consumption of raw C: 291065
Consumption of raw D: 200
Production of product P1: 25.4839
Production of product P2: 164.516
Production of product P3: 10
```

#### 2\. Diet Problem (Problem 16)

The second application is the **diet problem**. We solve exactly the same problem instance as in **Problem 16**. In this example, the food types are the **raw materials** and the nutrients are the **products** we want to obtain. Contrary to the original production problem, where there were several inputs and one output per recipe, here there is only one input (a food type) per recipe, which produces several nutrients with given ratios.

```
data;
set Raws := F1 F2 F3 F4 F5;
set Products := N1 N2 N3 N4;
set Recipes := EatF1 EatF2 EatF3 EatF4 EatF5;
param Min_Usage :=
N1 2000
N2 180
N3 30
N4 0.04
;
param Value :=
F1 450
F2 220
F3 675
F4 120
F5 500
;
param Recipe_Ratio:
F1 F2 F3 F4 F5 N1
N2
N3
N4 :=
EatF1
1
0
0
0
0
30 5.2 0.2 0.0001
EatF2
0
1
0
0
0
20
.
0.7 0.0001
EatF3
0
0
1
0
0
25
2
0.1 0.0001
EatF4
0
0
0
1
0
13 3.6
. 0.0002
EatF5
0
0
0
0
1
19 0.1
. 0.0009
;
end;
```

The solution is again exactly the same as for the original diet problem, which is an optimal cost of **$29,707.2**, with food consumption amounts of 42.86 of F2, 49.20 of F4, and 28.75 of F5. Note that in this case, the objective reported by the solver is **-$29,707.2**, because the profit is determined solely by the food costs (revenue is zero, so profit = $0 - \text{Total Costs}$).

```
Total Costs: 29707.2
Total Revenue: 0
Profit: -29707.2
Volume of recipe EatF1: 0
Volume of recipe EatF2: 42.8571
Volume of recipe EatF3: 0
Volume of recipe EatF4: 49.2014
Volume of recipe EatF5: 28.7489
Consumption of raw F1: 0
Consumption of raw F2: 42.8571
Consumption of raw F3: 0
Consumption of raw F4: 49.2014
Consumption of raw F5: 28.7489
Production of product N1: 2042.99
Production of product N2: 180
Production of product N3: 30
Production of product N4: 0.04
```

Recall that we mentioned two ways a diet problem can be represented as a production problem. Now the second of them was implemented, where food types are the raw materials and nutrients are the products. But how could we implement the representation of the first case, where food types are the products and nutrients are the raw materials?

Surprisingly, this **arbitrary recipe model** is able to do that as well, simply by **exchanging the roles of the products and raw materials**. If we understand this, we can see that there is a very high degree of **symmetry** in the production problem with arbitrary recipes. There are minimum and maximum usages for both the raw materials and the products. The cost of a raw material is the counterpart of the revenue of a product. If we look at the recipes, we can see that there is no "source-target" relation between raw materials and products; these two roles are **interchangeable**. The only slight difference between raw materials and products that breaks the symmetry is the **`Initial_Funds`** feature, which gives an upper limit for the total of raw material costs. The symmetry would be perfect if `Initial_Funds` was set to infinity, or if another feature, like maximal revenue, was also introduced.

Finally, let's look at a new example problem to further demonstrate the capabilities of the arbitrary recipe model. The starting point for the problem instance is **Problem 14**, where raw material costs were introduced, but we will make a few modifications.

 