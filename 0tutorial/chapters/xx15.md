---------------
Problem 17.
Given a set of raw materials and a set of products. There is also a set of recipes defined.
Each recipe describes the ratio in which it consumes raw materials, and produces products, these are
arbitrary nonnegative numbers. Each recipe may be utilized in an arbitrary amount, which is named
its volume.
There is a unit cost defined for each raw material, and a unit revenue for each product.
There can be minimal and maximal total consumption amounts defined for each raw material,
and minimal and maximal total production amounts defined for each product.
For practical purposes, the amounts of consumed raw materials are limited: their total costs
cannot exceed a given value, which is the initial funds available for raw material purchase.
Find the optimal production, where recipes are utilized in arbitrary volumes so that all the limits
on consumption and production are satisfied, and the total profit is maximal. The total profit is
the difference of the total revenue from products and the total costs of raw materials consumed.
Now let us try to implement this problem first without a particular example problem. We will
find it is very similar in implementation to the original production problem. The first thing to do
is to „read” all the available data for further use. For this reason, there are three sets in the model:
the set of raw materials, the set of products, and the set of recipes.
set Raws;
set Products;
set Recipes;
Note that the problem definition does not exclude the case where the same material is both a
raw material and a product at the same time in the recipes. It is actually natural in real-world
situations: some material is produced by a recipe, and consumed by another. However, questions
would arise if we wanted to take this case into account. For example, how to consider timing? If a
material is consumed as a raw material in a second recipe, then it must first be produced by another
in the first recipe. So production according to the first recipe must happen before the execution
of the second. Or, it is possible that the production describes an equilibrium where amounts must
be maintained, therefore timing is not important at all. There are many possibilities, problem
definitions and implementation would be complex, so we do not go into the details. For the sake of
simplicity, we assume that raw materials and products are distinct.
To ensure that raw materials are indeed distinct from products a check statement is introduced.
Literally, we express that the intersection of the set of raw materials and the set of products shall
contain exactly zero elements. If this does not hold, then model construction fails immediately, as
it should.
check card(Raws inter Products) == 0;
For each recipe, there are ratios, for both the raw materials and the products. Because these
are two different sets, it would require two different parameters: one for ratios of raw materials in
each recipe, and one for ratios of products in each recipe. This holds for other parameters as well.
Instead, we introduce the concept of materials in our model. We simply call raw materials and
products together as materials. In GNU MathProg, it is legal to introduce a set which is calculated
on spot based on other sets.
set Materials := Products union Raws;

66

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

Note that since we assumed that there is no material that is both a product and a raw material,
we can further assume that each raw material is represented in the union once, as well as each
product, and these are all distinct. Now, with the new set, we can define the necessary parameters
in a compact way.
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;
param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
Parameters Min_Usage and Max_Usage denote the lower and upper bound for each material in
the model. These two parameters are indexed over the Materials set. For raw materials, the
Min_Usage and Max_Usage mean limits for total consumption. For products, these parameters
mean limits for total production. Because each raw material and each product is represented in
the Materials set exactly once, this definition unambiguously describes all the limits for both raw
materials and products. Note that the default limits are 0 for lower and a very large number, 10100
for upper limits. So technically there is no limit by default.
The Value parameter works similarly, it represents raw material costs in case of raw materials,
and revenues in case of products. Both are nonnegative and defaulted to zero.
The Recipe_Ratio parameter is for describing recipes. The only needed data for the recipes
are the exact amount of inputs consumed and outputs produced. With the common Materials
set, this can be done with a single parameter. Recipe_Ratio is defined for all recipes and all
materials. If the material is a raw material, it describes consumption amount, if it is a product, it
describes production amount. We call this parameter „ratio” because it corresponds to the amounts
consumed and produced when utilizing the recipe with a volume of 1. In general, because both
inputs and outputs are proportional, the ratio must be multiplied by the volume to obtain the
amounts consumed or produced.
Finally, there is a single numeric parameter Initial_Funds. This serves as an upper limit for
raw material consumption. In practice, it is generally not possible to invest into any amounts of
raw materials, there is usually a cap on this. Note that without such a restriction and any upper
limits for consumption or production, it may be possible to gain unlimited profit by consuming
an unlimited amount of raw materials to produce at least one product in unlimited amounts. By
default, Initial_Funds is set to the extreme value and 10100 again so that it does not change the
model.
Now all the parameters and sets are defined, let us see what the freedom in our model is. What
we have to decide is the volume for each recipe utilized. This is slightly different than before, because
decisions do not correspond to one particular product or raw material, but for a given recipe. If
recipe amounts are defined, then the solution is exactly determined and all other information can
be calculated, including raw material usages, production amounts, costs, revenues, the profit, and
corresponding limitations.
var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
In our implementation volume is the variable which denotes for each recipe, which volume it
shall be utilized in. This is a nonnegative value but can be zero and even fractional, as usual. As

67

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

we mentioned, this only variable would be sufficient for model formulation, but we want to write a
compact and readable model instead, so we introduce a few auxiliary variables as well.
The variable usage is the total „usage” of each material. It is indexed over the Materials set,
and works similarly to the parameters, it has a slightly different meaning for raw materials and
products, but for sake of simplicity it can be denoted by the same single variable. For raw materials
r, usage[r] is the total consumption, while for products p, usage[p] is the total production
amount. Note that we can give Min_Usage[m] and Max_Usage[m] as bounds for this variable, which
implements the limitations in our problem.
There is also a variable named total_costs which denotes the total costs of consumed raw
materials, a variable total_revenue for the total revenue from products, and finally, a variable
profit for the difference, which is actually our objective function. We set Initial_Funds as an
upper bound for total_costs, which implements the maximum usage limitation.
Constraints are implemented next.
s.t. Material_Balance {m in Materials}: usage[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Total_Costs_Calc: total_costs = sum {r in Raws} Value[r] * usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage[p];
s.t. Profit_Calc: profit = total_revenue - total_costs;
Although this model is intended to be a generalization for both the production problem and the
diet problem, with supporting most of the features mentioned so far, there is only one key constraint:
the material balance established by recipe utilization. The constraint says that the usage of each
material, regardless of being a raw material or a product, is calculated by adding for each recipe its
volume, multiplied by the ratio the material is represented in the recipe. This is exactly the same
for both the original production problem and the diet problem.
We also define three additional constraints to calculate the values of the auxiliary variables
total_costs, total_revenue and profit. Note that even though parameters and variables (here
Value and usage) are indexed over the Materials set, it is valid in GNU MathProg to index those
parameters and variables over a smaller set. Using the original Raws and Products sets, we can sum
up only for raw materials and only for products. Be careful, we can only index over the original
domain, or its subset, otherwise we get an out of domain error (and the model is also guaranteed
to be logically wrong).
The objective is straightforward, the profit itself.
maximize Profit: profit;
After solving the problem, we can print out the auxiliary variables, as well as the utilization
volumes for each recipe and total consumption and production amounts for each material. The full
model section is ready as follows.
set Raws;
set Products;
set Recipes;
check card(Raws inter Products) == 0;
set Materials := Products union Raws;
param Min_Usage {m in Materials}, >=0, default 0;
param Max_Usage {m in Materials}, >=Min_Usage[m], default 1e100;

68

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

param Value {m in Materials}, >=0, default 0;
param Recipe_Ratio {c in Recipes, m in Materials}, >=0, default 0;
param Initial_Funds, >=0, default 1e100;
var volume {c in Recipes}, >=0;
var usage {m in Materials}, >=Min_Usage[m], <=Max_Usage[m];
var total_costs, <=Initial_Funds;
var total_revenue;
var profit;
s.t. Material_Balance {m in Materials}: usage[m] =
sum {c in Recipes} Recipe_Ratio[c,m] * volume[c];
s.t. Total_Costs_Calc: total_costs = sum {r in Raws} Value[r] * usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Value[p] * usage[p];
s.t. Profit_Calc: profit = total_revenue - total_costs;
maximize Profit: profit;
solve;
printf "Total Costs: %g\n", total_costs;
printf "Total Revenue: %g\n", total_revenue;
printf "Profit: %g\n", profit;
for {c in Recipes}
{
printf "Volume of recipe %s: %g\n", c, volume[c];
}
for {r in Raws}
{
printf "Consumption of raw %s: %g\n", r, usage[r];
}
for {p in Products}
{
printf "Production of product %s: %g\n", p, usage[p];
}
end;
Although the model for arbitrary recipes is similar in nature to the former models, we still
implemented it at once. The question arises: how can a large, complex model be implemented in
GNU MathProg from scratch? Or, generally, in any mathematical programming language?
There is no general guide for modeling, but there are good rules of thumb to follow. The
recommendation is the following, specifically for GNU MathProg.
1. First, we must decide whether the problem under consideration can be effectively solved by
LP (or MILP) models. There are many problems that are simply cannot, or only with very
complicated workarounds, or there is a much more suitable algorithm or other method for
solving it. This is the hardest part, we basically have to think what the decision variables will
be, and how the appropriate search space can be defined by the addition of constraints and
69

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

other variables. If we are sure we can implement an LP (or MILP) model for the problem,
then we can go on with the implementation of the model file.
2. Collect all data that are available and needed. Define sets and parameters which will be
provided by the data sections. Data files can be implemented at this point if there are example
problem instances available. If some data is missing or must be calculated afterwards, we will
always have the opportunity to introduce other sets and parameters, and calculate other data
in the model file.
3. Define the decision variables. Keep in mind that the values of all the variables should exactly
determine what is happening in the real-world. In particular, we must be able to calculate the
objective and decide for each restriction whether it is violated or not, based on the variables.
4. Implement all possible rules as constraints or bounds. Keep in mind that there are two
mistakes we can make: a problem may be under-constrained or over-constrained, or both.
In under-constrained problems, there are solutions left in the search space that are infeasible
in the problem but feasible in the model. These additional solutions may be found by the
solver and reported as fake optimal solutions. Then, additional constraints must be defined
to exclude those solutions, or already existing constraints redefined to be more restrictive.
In over-constrained problems, interesting solutions are excluded from the search space, and
therefore not found by the solver. Then, some constraints or bounds are too restrictive, we
have to reformulate or remove them. Remember that we can always introduce new auxiliary
variables in the model.
5. Define the objective.
6. After the solve statement, report the relevant details of the solution found, in the desired
format.
Complex models may have several dozens of constraints, so how can we be sure we have not
forgotten any rules? One idea for that is to focus on parameters or variables. In many cases,
parameters are used only once in the model. Even if not, we can enlist all the roles the parameter
or variable must appear in the model: as a bound, a constraint, or objective term, etc. Then it is
easy to spot one which is forgotten.
Now that we have our model for arbitrary recipes ready, we will demonstrate how this works for
all the problems mentioned so far in this chapter (with the exception of the maximum of minimum
production amounts case).
First, Problem 14, which introduced raw material costs, is solved. Since this is a pure production
problem in the original way, a recipe is introduced to produce each of the products. All the limits
are implemented by the Min_Usage parameter, while raw material costs and product revenues are
implemented by the Value parameter. The data section is the following.
data;
set Raws := A B C D;
set Products := P1 P2 P3;
set Recipes := MakeP1 MakeP2 MakeP3;
param Min_Usage :=
B 21000
D 200
P2 100
;

70

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

param Max_Usage :=
A 23000
B 31000
C 450000
D 200
P3 10
;
param Value :=
A 1
B 0.07
C 0.013
D 8
P1 252
P2 89
P3 139
;
param Recipe_Ratio:
A
B
C
MakeP1 200
25 3200
MakeP2
50 180 1000
MakeP3
0
75 4500
;

D
1
1
1

P1
1
0
0

P2
0
1
0

P3 :=
0
0
1

end;
If we solve it, then we get exactly the same result as for the original model with raw costs. The
optimal profit is 1577.45, with production of 25.48 units of P1, 164.52 units of P2 and 10 units of
P3. The output is the following.
Total Costs: 20876.4
Total Revenue: 22453.9
Profit: 1577.45
Volume of recipe MakeP1: 25.4839
Volume of recipe MakeP2: 164.516
Volume of recipe MakeP3: 10
Consumption of raw A: 13322.6
Consumption of raw B: 31000
Consumption of raw C: 291065
Consumption of raw D: 200
Production of product P1: 25.4839
Production of product P2: 164.516
Production of product P3: 10
The second application is the diet problem. We solve exactly the same problem instance as in
Problem 16. In this example, the food types are the raw materials and the nutrients are the products
we want to obtain. Contrary to the original production problem, where there were several inputs
and one output per recipe, here there is only one input, a food type per recipe, which produces
several nutrients with given ratios.
71

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

data;
set Raws := F1 F2 F3 F4 F5;
set Products := N1 N2 N3 N4;
set Recipes := EatF1 EatF2 EatF3 EatF4 EatF5;
param Min_Usage :=
N1 2000
N2 180
N3 30
N4 0.04
;
param Value :=
F1 450
F2 220
F3 675
F4 120
F5 500
;
param Recipe_Ratio:
F1 F2 F3
EatF1
1
0
0
EatF2
0
1
0
EatF3
0
0
1
EatF4
0
0
0
EatF5
0
0
0
;

F4
0
0
0
1
0

F5
0
0
0
0
1

N1
30
20
25
13
19

N2
5.2
.
2
3.6
0.1

N3
0.2
0.7
0.1
.
.

N4 :=
0.0001
0.0001
0.0001
0.0002
0.0009

end;
The solution is again exactly the same as for the original diet problem, which is an optimal cost
of 29707.2, with food consumption amounts of 24.86 of F2, 49.20 of F4, and 28.75 of F5. Note that
in this case, the objective reported by the solver is −29707.2, because the profit is determined solely
by the food costs.
Total Costs: 29707.2
Total Revenue: 0
Profit: -29707.2
Volume of recipe EatF1: 0
Volume of recipe EatF2: 42.8571
Volume of recipe EatF3: 0
Volume of recipe EatF4: 49.2014
Volume of recipe EatF5: 28.7489
Consumption of raw F1: 0
Consumption of raw F2: 42.8571
Consumption of raw F3: 0
Consumption of raw F4: 49.2014
Consumption of raw F5: 28.7489

72

5.6. ARBITRARY RECIPES

PRODUCTION PROBLEM

Production of product N1: 2042.99
Production of product N2: 180
Production of product N3: 30
Production of product N4: 0.04
Recall that we mentioned two ways a diet problem can be represented as a production problem.
Now the second of them was implemented, which is the case when food types are the raw materials,
and nutrients are the products. But how could we implement the representation of the first case,
when food types are the products and nutrients are the raw materials?
Surprisingly, this arbitrary recipe model is able to do that as well, just the role of the products and
raw materials must be exchanged. If we understand that, we can see that there is a very high degree
of symmetry in the production problem of arbitrary recipes. There are minimum and maximum
usages, for both the raw materials and the products. The cost of a raw material is the counterpart
of the revenue of a product. If we look at the recipes, we can see that there is no „source-target”
relation between raw materials and products. These two roles are interchangeable. The only slight
difference between raw materials and products that breaks the symmetry is the Initial_Funds
feature which gives an upper limit for the total of raw material costs. The symmetry would be
perfect if Initial_Funds was set to infinity, or if another feature like maximal revenue was also
introduced.
Finally, let us see a new example problem to further demonstrate the capabilities of the arbitrary
recipe model. The starting point for the problem instance is Problem 14 where raw material costs
were introduced, but we do a few modifications.
