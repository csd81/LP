---------------
Problem 43.
145

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

Figure 10: A connected and a disconnected graph.

Figure 11: A spanning tree of a graph connects all nodes but does not contain cycles.
Solve the shortest path problem [24] on an arbitrary simple weighted graph, specified as follows.
Given two nodes, find a path connecting these two nodes so that the total weight of edges on the path
is minimal.
 
Problem 44.
Solve the minimum weight spanning tree [25] problem on an arbitrary simple weighted graph:
find the spanning tree of the graph with the minimal total edge weight.
In the shortest path problem, edge weights represent distances between two nodes. This is
common in practice, for example in navigation. In the minimum weight spanning tree problem,
weights may represent connection establishment costs. This problem may arise in real-world situations where a minimal-cost connected network is to be established between a set of nodes, because
the minimal connected spanning subgraphs are always spanning trees – we omit the proof
here. But this idea is a key observation: we are looking for the minimum weight connected graph
on the set of nodes, and this eventually coincides with the minimum weight spanning tree problem.
Before going on, we must note that these problems have very efficient algorithms solving them,
running in polynomial time.
• The shortest path problem is solved by Dijkstra’s algorithm [26].
• The minimum weight spanning tree problem is solved, for example, by Kruskal’s algorithm
[27], or Prim’s algorithm.
Other approaches are also available. Our aim here is to show how MILP models can be utilized for
graphs. Although a specific algorithm can be superior in efficiency, but a mathematical programming
model can be much easier to formulate, and to adapt to more complex problems if the problem
definition changes.
Figure 12 shows an example of a simple weighted graph, which is used for demonstration.

146

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

Figure 12: A simple weighted graph with 9 nodes and 16 weighted edges.
 
Problem 45.
On the graph depicted in Figure 12, find the shortest path between nodes A and I, and find the
minimum weight spanning tree.
First, we analyze the problems in terms of feasibility. If a graph is disconnected, then there
are nodes which cannot be by moving along edges, and there is no connecting path. Disconnected
graphs have no spanning trees either. On the other hand, if a graph is connected, there should be
paths form any node to any other, and also a spanning tree. We omit proofs of these claims here.
The graph in Figure 12 is connected and clearly have paths and spanning trees, so feasibility is
guaranteed.
The main idea about modeling graphs with mathematical programming tools is that edges are
defined by pairs of nodes. Therefore, edges can be indexed by two-dimensional indices where both
dimensions refer to the set of nodes.
We first implement a data section describing the graph under question. The set of Nodes has
two important elements, the two nodes between which the shortest path is to be found. We name
these as Start and Finish nodes. Note that the two roles are interchangeable. Finally, a Weight
parameter describes edge weights. Note that only those pairs of nodes are mentioned for which an
edge is defined in the graph, and only in one order. For example A B 5 is in the list, but B A 5 is
not. More on that later.
data;
set Nodes := A B C D E F G H I;
param Start := A;
param Finish := I;

147

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

param Weight :=
A B 5
B C 7
A D 3
B E 4
C F 6
D E 6
E F 4
D G 6
E H 2
F I 8
G H 5
H I 9
B D 1
C E 8
E G 7
F H 2
;
end;
Parameters Start and Finish have special characteristics. They do not take numeric values as
parameters usually do, but values from the set Nodes. For this reason, we mark these parameters
as symbolic. For safety reasons, we also add in Nodes to the definitions so that the data section
can only provide names from the Nodes set previously defined. Also, we assert that the two nodes
are different, by a check statement.
set Nodes;
param Start, symbolic, in Nodes;
param Finish, symbolic, in Nodes;
check Start!=Finish;
The notion of edges in simple graph only allows a single, undirected edge between two nodes.
That means, edge AB and BA are the same. However, in mathematical programming, it is more
convenient to refer to edges as (A, B) ordered pairs, because it is easy to index: both A and B can
be any node. There are two approaches to resolve this confusion.
• We could allow only one direction of edges. For example, we can make a convention that for
each X < Y , XY is considered as an edge, but Y X is not. Here X < Y refers to some kind
of ordering, like lexicographical. Note that lexicographical comparison of symbolic values
(strings) is supported in GNU MathProg.
• We could allow all ordered pairs, and therefore work with directed arcs instead of undirected
edges. Later we can identify two arcs as the same edge if needed, by constraints.
We choose the latter option for two reasons. First, only allowing specific node orders for edges
would mess up with the data to be provided, as we cannot exchange the two nodes in the description
of an edge. Second, and more importantly, edge direction will be used in the model implementation
anyways.
A parameter Infty is introduced to serve as a very high edge cost. In both the shortest path
and the minimum weight spanning tree problem, if an edge has such a cost, it is not beneficial for
the solver to select. This effectively eliminates those edges from the search.
148

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

For this reason, we set Infty as the default value for the Weight parameter. This makes edges
not mentioned in the data section automatically excluded from the search by their very large cost.
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
Finally, a parameter W is introduced for the weight of an edge used in the model, which will be
used in the model formulation. The min operator ensures the following, for all edges XY :
• If neither of XY or Y X have data provided, the weight W is Infty, therefore the edge is
practically excluded.
• If only one of XY or Y X have date provided, then W will be equal to that given weight.
Therefore we only have to mention each edge once in the data section, in arbitrary order of
the two nodes it connects.
• If both XY and Y X have data provided, then the minimum of these weights is used for both.
Note that this is not an intended functionality, we should not provide both weights in the
data. This could also be asserted by a check statement.
The idea for the shortest path problem is the following. We put one imaginary droplet of
material into the Start node, and it will flow through the arcs of the graph to finally reach the
Finish node. We expect the droplet to draw the path we look for. This is the point where the usage
of arcs is more convenient than the usage of edges, because the direction of flow is very important.
A binary variable flow is introduced for each possible arc (a,b), denoting whether the droplet
flows through that arc from a to b or not. This variable shall be binary, as the droplet cannot split.
var flow {a in Nodes, b in Nodes}, binary;
No more variables are needed, not even auxiliary ones. The question is what property of the
arcs must satisfy in order to actually form a path between the starting and finishing node?
It is a basic idea to check the material balance at each node of a graph with flows. In short,
material balance ensures the connection between the total amount of material coming in and going
out. This concept was implicitly used for the center nodes in the transportation problem, where all
materials coming into a center node must have left it towards the demand nodes (see Section 6.7).
We also refer to some constraints as material balance constraints if they express a relation between
different material amounts, as in Chapter 5.
Now let us see how the material balance works for a single droplet. The quantity under investigation is the times the droplet enters the node, minus the times it leaves, we will call this the
balance at the node.
• From the starting node, the droplet must go out. We may may allow it getting back there,
but then it shall go out again each time. Therefore the balance at the starting node is −1.
• To the ending node, the droplet must arrive. We may allow it leaving, but then it must come
back again each time. Therefore, the balance at the ending node is 1.
• For any other nodes, the droplet shall arrive several times, but leave so many times as well.
Therefore the balance in any other node is 0.
With a single s.t. statement, we establish these balances with the following code.

149

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

subject to Path_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then -1 else if (x==Finish) then 1 else 0;
Now let us understand why this single constraint ensures that the model works, and no more are
needed. If a set of arcs is selected by these balance rules, these arcs will form some directed graph
inside the original one. Let us start the droplet and travel around a trail along the selected arcs.
A trail is a sequence of nodes, where adjacent nodes in the sequence are connected by an arc (or
edge, in simple graphs).
We start from the starting node, let it be called A0 . Because of the balance, we can get to at
least one other node, A1 . Because of the balance there, either we arrived at the finish node, or there
must be another node A2 the droplet can go out. And so on. The balance constraints ensure that
each time we arrive at any node, we are either at the finishing node, or we can select a new arc not
already travelled to go out. The trail is using up the arcs, therefore it cannot be infinite, it must end
at some point. And by the balances, the only possible node the trail can end is the finishing point.
Therefore, the flow variables provide a feasible trail between the Start and Finish nodes.
The objective is the total weight of the selected arcs.
minimize Total_Weight:
sum {a in Nodes, b in Nodes} flow[a,b] * W[a,b];
Note that there are two discrepancies between a path to be found and the set of arcs selected in
the model.
• The balance constraint only ensures an existing trail, but more arcs are allowed to be selected.
• The trail is not necessarily a path, as trails may visit the same node multiple times.
However, as we have seen many times before, optimization will eventually rule out these differences and will find an actual path. First, it is not beneficial to select additional edges because of
their positive weight. Second, trails can be trimmed to paths, by cutting out cycles between visiting
the same node multiple times. In practice, it sounds like: „If I can travel from A to B by visiting
some places more than once, then I can surely travel without doing so.”
We print out the used arcs after the solve statement, and our model is now ready.
set Nodes;
param Start, symbolic, in Nodes;
param Finish, symbolic, in Nodes;
check Start!=Finish;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
var flow {a in Nodes, b in Nodes}, binary;
subject to Path_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then -1 else if (x==Finish) then 1 else 0;
minimize Total_Weight:
sum {a in Nodes, b in Nodes} flow[a,b] * W[a,b];

150

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

solve;
printf "Distance %s-%s: %g\n", Start, Finish, Total_Weight;
for {a in Nodes, b in Nodes: flow[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
end;
Now, let us find the shortest path from A to I in the given graph. We get the following result.
Distance A-I: 19
A->D (3)
B->E (4)
D->B (1)
E->H (2)
H->I (9)
This means the shortest path is 19, and the path itself is ADBEHI. The arcs show the direction
of the path from A to I well, but unfortunately the arcs are not in order. Printing them in order is
possible in GNU MathProg, but would require extensive workarounds spoiling the simplicity of this
model formulation.

Figure 13: Shortest path of length 19 found from node A to node I.
The path can be seen in Figure 13. We can observe that the shortest path is not the path with
the minimal number of edges, and is not always going into the „cheapest” direction.
We make two additional notes on the shortest path problem.
151

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

• We could impose stricter constraints, to only allow at most one incoming and outgoing arc
at each node. This would eliminate trails visiting nodes multiple times, but would not eliminate unnecessary arcs to be included: note that a cycle between unrelated nodes meets the
requirements of even the strict balance constraints.
• The shortest path problem in this form has the same nice property as the assignment problem
(see Section 7.3): the LP relaxation of the problem yields the optimal solution. So the model
could be an LP instead. This is not surprising: if the droplet is split, then all of its pieces
shall still go simultaneously on the shortest path to travel the minimal distance in total.
Now let us solve the minimum weight spanning tree problem on the same graph. This time, we
start with the strategy.
Recall the note that the minimal connected spanning subgraph is always a tree. Therefore the
optimization has nothing to do with cycles and tree definitions. The objective shall be the total
weight of selected edges, and the constraints shall only ensure that the graph is connected.
Then, optimization will find the minimum weight connected spanning subgraph, which eventually
will be a tree.
Now the real question is how we can assure by constraints that some edges form a connected
graph of the nodes? We again use the idea of flows. Let us put a single droplet in each node, and
these droplets may flow through edges of the graph, eventually arriving into a single designated
sink node.
If the graph formed by the selected edges is connected, then droplets can reach all nodes from
any. If the graph is disconnected, then only part of the nodes is reachable and the flow is infeasible.
Now let us start implement the model based on this idea. The data section can be almost the
same, the only difference is that we do not define a Start and Finish node, only a single Sink. The
selection of the Sink node is arbitrary, and we could use the model section itself to automatically
choose one, but providing it in the data section is easier. The role of the Sink node is to serve as
the common endpoint of all droplets. We select A as the Sink node.
param Sink := A;
Edge weights are determined exactly the same way as for the shortest path problem. Therefore
the rest of the data section remains unchanged.
set Nodes;
param Start, symbolic, in Nodes;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
We use two kinds of decision variables this time. Variable use is defined for each arc, and
denotes whether the droplets may flow through that direction (= 1) or not (= 0). Variable flow is
continuous, and denotes how much material (eventually, how many droplets) flow through that arc.
Note that flow can be negative, more on that later.
var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};
Without proof, we note that edges of a spanning tree can be uniquely directed towards any one
of its nodes. The variable use will denote if the edge is selected, and it points towards the Sink
node.
152

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

Although both variables are defined for arcs, there is no point for droplets to flow in both
directions through an edge. The reason is that their endpoint is the same. Therefore the optimization
will select at most one of the directions for each edge. A flow of k droplets in one direction can be
regarded as a flow of −k droplets in the opposite direction. The following constraint ensures that if
there is flow between two nodes, then one is some positive k > 0, which is the actual direction, and
the other direction is its exact opposite, −k < 0. Alternatively, both flows can be zero as well.
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
A positive flow of droplets is only allowed in the arcs selected by the use variable. This is
established by a big-M constraint. Note that the coefficient is the number of nodes minus one. This
is the maximum number of droplets in motion, as the droplet put directly on the Sink node does
not need to move. Observe that two constraints are generated for a single edge, which represents
the two directions, but the constraint for the negative flow is redundant.
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
Finally, establish the material balance of the droplets, which is the following at each node.
• If the node is the Sink, then it shall receive the number of nodes minus one droplets.
• For any other node, it must send one droplet. Note that droplets may enter and exit the same
node, but these do not contribute to the balance of any node.
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Sink) then (1-card(Nodes)) else 1;
It can be proven that the arc and flow selection satisfying the balance constraints provide a
connected graph. The logic is similar to the case of the shortest paths: we can start trails at each
node and move through positive flows until reaching the Sink. The sink is the only node where
trails can end. Therefore, all nodes must be connected to the Sink, and consequently to each other
as well.
The objective is the total weight of arcs where the flow is positive. This minimizes the arcs to
be selected, resulting in a spanning tree, all its edges directed towards the Sink.
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
We print the selected arcs again after the solve statement, and our model section is ready.
set Nodes;
param Sink, symbolic, in Nodes;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};

153

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Sink) then (1-card(Nodes)) else 1;
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
solve;
printf "Cheapest spanning tree: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
end;
Solving the example with Sink node A gives the following results, also visible in Figure 14.
Cheapest spanning tree: 31
A<-D (3)
B<-E (4)
D<-B (1)
E<-H (2)
F<-C (6)
F<-I (8)
H<-F (2)
H<-G (5)
We can observe that all directed paths unambiguously lead to the designated Sink node A. If
another Sink was selected, then the solution graph could be the same (or another one with exactly
the same objective), but the direction of the arcs would be different.
Note that droplets may be split as flows are not integers, but it is not beneficial and therefore
not happening in the optimal solution. This is a similarity to the shortest path problem. However,
in this case the MILP model cannot be relaxed into an LP, because the selection of the arcs is a
mandatory integer part. It does not matter whether only a single or all droplets travel through an
edge, its full weight must be calculated. Therefore variable use needs to remain binary.
One final note about these MILP formulations: how are loops treated? For the sake of easier
indexing, for all nodes a in Nodes and b in Nodes, the arc (a,b) was included in both models.
But this does not only allow two directions for the same edge, but also loops. These are edges in the
form (a,a), silently present throughout all of the formulation: parameters, variables, constraints
and the objective. We can verify that loops are either not beneficial to be used, or using them does
not make a difference, in all instances they are present.

154

7.5. TRAVELLING SALESMAN PROBLEM

MILP MODELS

Figure 14: Minimum weight spanning tree (weight is 31), directed towards Sink node A.

7.5

Travelling salesman problem

A well-known and notoriously difficult optimization problem and its GNU MathProg model implementation is presented here. This is the travelling salesman problem, or TSP in short [28].
