

## Problem 43.

Solve the **shortest path problem** [24] on an arbitrary simple weighted graph, specified as follows: Given two nodes, find a path connecting these two nodes so that the **total weight of edges on the path is minimal**.

-----

## Problem 44.

Solve the **minimum weight spanning tree (MST)** [25] problem on an arbitrary simple weighted graph: find the spanning tree of the graph with the **minimal total edge weight**.

-----

### Understanding the Problems

In the **shortest path problem**, edge weights typically represent **distances** between two nodes. This is common in practice, for example, in navigation.

In the **minimum weight spanning tree problem**, weights may represent **connection establishment costs**. This problem often arises in real-world situations where a **minimal-cost connected network** must be established between a set of nodes. This is because the minimal connected spanning subgraphs are always spanning trees—we omit the proof here. But this idea is a key observation: we are looking for the minimum weight connected graph on the set of nodes, and this eventually coincides with the minimum weight spanning tree problem.

Before going on, we must note that these problems have **very efficient algorithms** that solve them in polynomial time:

  * The shortest path problem is solved by **Dijkstra’s algorithm** [26].
  * The minimum weight spanning tree problem is solved, for example, by **Kruskal’s algorithm** [27] or **Prim’s algorithm**.

Other approaches are also available. Our aim here is to show how **MILP models can be utilized for graphs**. Although a specific algorithm can be superior in efficiency, a mathematical programming model can be much easier to formulate and to adapt to more complex problems if the problem definition changes.

**Figure 12** shows an example of a simple weighted graph, which is used for demonstration.

-----

## Problem 45.

On the graph depicted in **Figure 12**, find the shortest path between nodes **A and I**, and find the minimum weight spanning tree.

### Feasibility Analysis

First, we analyze the problems in terms of feasibility. If a graph is **disconnected**, then there are nodes that cannot be reached by moving along edges, and there is **no connecting path**. Disconnected graphs have **no spanning trees** either. On the other hand, if a graph is **connected**, there should be paths from any node to any other, and also a spanning tree. We omit proofs of these claims here.

The graph in **Figure 12** is connected and clearly has paths and spanning trees, so feasibility is guaranteed.

### Data Implementation for the Graph

The main idea about modeling graphs with mathematical programming tools is that edges are defined by pairs of nodes. Therefore, edges can be indexed by two-dimensional indices where both dimensions refer to the set of nodes.

We first implement a data section describing the graph in question. The set of **`Nodes`** has two important elements: the two nodes between which the shortest path is to be found. We name these as **`Start`** and **`Finish`** nodes. Note that the two roles are interchangeable. Finally, a **`Weight`** parameter describes edge weights.

```
data;
set Nodes := A B C D E F G H I;
param Start := A;
param Finish := I;

param Weight :=
A B 5
B C 7
A D 3
B E 4
C F 6
D E 6
E F 4
D G 6
E H 2
F I 8
G H 5
H I 9
B D 1
C E 8
E G 7
F H 2
;
end;
```

The parameters **`Start`** and **`Finish`** have special characteristics. They do not take numeric values as parameters usually do, but values from the set **`Nodes`**. For this reason, we mark these parameters as **symbolic**. For safety reasons, we also add $\text{in Nodes}$ to the definitions so that the data section can only provide names from the `Nodes` set previously defined. Also, we assert that the two nodes are different, by a `check` statement.

```
set Nodes;
param Start, symbolic, in Nodes;
param Finish, symbolic, in Nodes;
check Start!=Finish;
```

The notion of edges in a simple graph only allows a single, **undirected edge** between two nodes. That means edge AB and BA are the same. However, in mathematical programming, it is more convenient to refer to edges as **$(A, B)$ ordered pairs**, because it is easy to index: both $A$ and $B$ can be any node. There are two approaches to resolve this confusion:

1.  **Allow only one direction of edges:** For example, we can make a convention that for each $X < Y$, $XY$ is considered an edge, but $YX$ is not. (Here $X < Y$ refers to some kind of ordering, like lexicographical.)
2.  **Allow all ordered pairs (directed arcs):** We work with directed arcs instead of undirected edges. Later we can identify two arcs as the same edge if needed, using constraints.

We choose the latter option for two reasons. First, only allowing specific node orders for edges would complicate the data to be provided, as we cannot exchange the two nodes in the description of an edge. Second, and more importantly, **edge direction will be used in the model implementation anyway**.

A parameter **`Infty`** is introduced to serve as a very high edge cost. In both the shortest path and the minimum weight spanning tree problem, if an edge has such a cost, it is not beneficial for the solver to select. This effectively eliminates those edges from the search.

For this reason, we set $\text{Infty}$ as the default value for the **`Weight`** parameter. This makes edges not mentioned in the data section automatically excluded from the search by their very large cost.

```
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
```

Finally, a parameter **`W`** is introduced for the weight of an edge used in the model, which will be used in the model formulation. The $\text{min}$ operator ensures the following for all edges $XY$:

  * If neither $XY$ nor $YX$ have data provided, the weight $W$ is $\text{Infty}$; therefore, the edge is practically excluded.
  * If only one of $XY$ or $YX$ has data provided, then $W$ will be equal to that given weight. Therefore, we only have to mention each edge once in the data section, in an arbitrary order of the two nodes it connects.
  * If both $XY$ and $YX$ have data provided, then the minimum of these weights is used for both. (Note that this is not an intended functionality; we should not provide both weights in the data. This could also be asserted by a check statement.)

### Solving the Shortest Path Problem

The main idea for the shortest path problem is to imagine a single **"droplet" of material** placed into the **`Start`** node. It will flow through the arcs of the graph to finally reach the **`Finish`** node. We expect the droplet to draw the path we are looking for. This is where the usage of arcs is more convenient than the usage of edges, because the **direction of flow is very important**.

A binary variable **`flow`** is introduced for each possible arc $(a, b)$, denoting whether the droplet flows through that arc from $a$ to $b$ or not. This variable must be binary, as the droplet cannot split.

```
var flow {a in Nodes, b in Nodes}, binary;
```

No more variables are needed, not even auxiliary ones. The question is what property the arcs must satisfy to actually form a path between the starting and finishing node?

It is a basic idea to check the **material balance** at each node of a graph with flows. In short, material balance ensures the connection between the total amount of material coming in and going out.

Now let us see how the material balance works for a single droplet. The quantity under investigation is the times the droplet **enters** the node, minus the times it **leaves**; we will call this the **balance** at the node:

  * From the starting node ($\text{Start}$), the droplet must go out. Therefore, the balance at the starting node is $\mathbf{-1}$.
  * To the ending node ($\text{Finish}$), the droplet must arrive. Therefore, the balance at the ending node is $\mathbf{1}$.
  * For any other nodes, the droplet must arrive and leave the same number of times. Therefore, the balance in any other node is $\mathbf{0}$.

With a single `s.t.` statement, we establish these balances with the following code:

```
subject to Path_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then -1 else if (x==Finish) then 1 else 0;
```

This single constraint ensures that the model works. If a set of arcs is selected by these balance rules, these arcs will form some directed graph inside the original one. The balance constraints ensure that a **feasible trail** (a sequence of nodes connected by arcs, where nodes can be revisited) exists between the Start and Finish nodes.

The objective is the total weight of the selected arcs:

```
minimize Total_Weight:
sum {a in Nodes, b in Nodes} flow[a,b] * W[a,b];
```

Note that there are two discrepancies between the path to be found and the set of arcs selected in the model:

  * The balance constraint only ensures an existing trail, but more arcs are allowed to be selected.
  * The trail is not necessarily a path, as trails may visit the same node multiple times (cycles).

However, as we have seen many times before, **optimization will eventually rule out these differences and will find an actual path**. First, it is not beneficial to select additional edges because of their positive weight. Second, trails can be trimmed to paths by cutting out cycles.

We print out the used arcs after the solve statement, and our model is now ready.

```
set Nodes;
param Start, symbolic, in Nodes;
param Finish, symbolic, in Nodes;
check Start!=Finish;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
var flow {a in Nodes, b in Nodes}, binary;
subject to Path_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Start) then -1 else if (x==Finish) then 1 else 0;
minimize Total_Weight:
sum {a in Nodes, b in Nodes} flow[a,b] * W[a,b];
solve;
printf "Distance %s-%s: %g\n", Start, Finish, Total_Weight;
for {a in Nodes, b in Nodes: flow[a,b]}
{
printf "%s->%s (%g)\n", a, b, W[a,b];
}
end;
```

Now, let us find the shortest path from **A to I** in the given graph. We get the following result.

```
Distance A-I: 19
A->D (3)
B->E (4)
D->B (1)
E->H (2)
H->I (9)
```

This means the shortest path is **19**, and the path itself is **A-D-B-E-H-I**. The arcs show the direction of the path from A to I well, but unfortunately, the arcs are not in order.

The path can be seen in **Figure 13**.  We can observe that the shortest path is not the path with the minimal number of edges, and does not always go in the "cheapest" direction.

Two additional notes on the shortest path problem:

  * We could impose stricter constraints to only allow at most one incoming and outgoing arc at each node. This would eliminate trails visiting nodes multiple times, but would not eliminate unnecessary arcs (like cycles between unrelated nodes).
  * The shortest path problem in this form has the same nice property as the assignment problem: the **LP relaxation of the problem yields the optimal solution**. So the model could be a pure LP instead of an MILP. This is not surprising: if the droplet is split, all of its pieces shall still go simultaneously on the shortest path to travel the minimal distance in total.

-----

### Solving the Minimum Weight Spanning Tree (MST) Problem

Now let us solve the minimum weight spanning tree problem on the same graph. We start with the strategy:

Recall the note that the minimal connected spanning subgraph is always a tree. Therefore, the optimization has nothing to do with cycles and tree definitions. The objective should be the **total weight of selected edges**, and the constraints shall only ensure that the graph is **connected**. Optimization will then find the minimum weight connected spanning subgraph, which eventually will be a tree.

The real question is how we can ensure by constraints that some edges form a connected graph of the nodes. We again use the idea of flows. Let us put a single droplet in **each node**, and these droplets may flow through the edges of the graph, eventually arriving into a single designated **sink node**.

  * If the graph formed by the selected edges is connected, then droplets can reach all nodes from any.
  * If the graph is disconnected, then only part of the nodes is reachable, and the flow is infeasible.

Now let us start implementing the model based on this idea. The data section can be almost the same; the only difference is that we do not define a Start and Finish node, only a single **`Sink`**. The selection of the Sink node is arbitrary; we choose **A** as the Sink node.

```
param Sink := A;
```

Edge weights are determined exactly the same way as for the shortest path problem.

```
set Nodes;
param Sink, symbolic, in Nodes;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
```

We use **two kinds of decision variables** this time.

  * Variable **`use`** is defined for each arc and denotes whether the edge is selected, and points towards the Sink node (**binary**).
  * Variable **`flow`** is **continuous** and denotes how much material (eventually, how many droplets) flow through that arc.

<!-- end list -->

```
var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};
```

Without proof, we note that edges of a spanning tree can be uniquely directed towards any one of its nodes. The variable `use` will denote if the edge is selected, and it points towards the Sink node.

The following constraint ensures that for a single edge, flow in one direction is the negative of the flow in the opposite direction.

```
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
```

A **positive flow** of droplets is only allowed in the arcs selected by the `use` variable. This is established by a big-M constraint. Note that the coefficient is the **number of nodes minus one** ($\text{card(Nodes)} - 1$). This is the maximum number of droplets in motion, as the droplet put directly on the Sink node does not need to move.

```
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
```

Finally, establish the material balance of the droplets, which is the following at each node:

  * If the node is the $\text{Sink}$, then it shall **receive** the number of nodes minus one droplets. The balance is $\mathbf{1 - \text{card(Nodes)}}$.
  * For any other node, it must **send one** droplet. The balance is $\mathbf{1}$.

<!-- end list -->

```
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Sink) then (1-card(Nodes)) else 1;
```

It can be proven that the arc and flow selection satisfying the balance constraints provide a **connected graph**. The logic is similar to the case of the shortest paths: we can start trails at each node and move through positive flows until reaching the Sink. The sink is the only node where trails can end. Therefore, all nodes must be connected to the Sink, and consequently to each other as well.

The objective is the total weight of arcs where the flow is positive. This minimizes the arcs to be selected, resulting in a spanning tree, with all its edges directed towards the Sink.

```
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
```

The full model is presented below.

```
set Nodes;
param Sink, symbolic, in Nodes;
param Infty, default 99999;
param Weight {a in Nodes, b in Nodes}, >0, default Infty;
param W {a in Nodes, b in Nodes} := min(Weight[a,b],Weight[b,a]);
var use {a in Nodes, b in Nodes}, binary;
var flow {a in Nodes, b in Nodes};
subject to Flow_Direction {a in Nodes, b in Nodes}:
flow[a,b] + flow[b,a] = 0;
subject to Flow_On_Used {a in Nodes, b in Nodes}:
flow[a,b] <= use[a,b] * (card(Nodes) - 1);
subject to Material_Balance {x in Nodes}:
sum {a in Nodes} flow[a,x] - sum {b in Nodes} flow[x,b] =
if (x==Sink) then (1-card(Nodes)) else 1;
minimize Total_Weight:
sum {a in Nodes, b in Nodes} use[a,b] * W[a,b];
solve;
printf "Cheapest spanning tree: %g\n", Total_Weight;
for {a in Nodes, b in Nodes: use[a,b]}
{
printf "%s<-%s (%g)\n", a, b, W[a,b];
}
end;
```

Solving the example with Sink node **A** gives the following results, also visible in **Figure 14**.

```
Cheapest spanning tree: 31
A<-D (3)
B<-E (4)
D<-B (1)
E<-H (2)
F<-C (6)
F<-I (8)
H<-F (2)
H<-G (5)
```

The minimum weight spanning tree has a total weight of **31**.  We can observe that all directed paths unambiguously lead to the designated Sink node A. If another Sink was selected, then the solution graph could be the same (or another one with exactly the same objective), but the direction of the arcs would be different.

Note that droplets may be split as flows are not integers, but it is not beneficial and therefore not happening in the optimal solution. This is a similarity to the shortest path problem. However, in this case, the MILP model **cannot be relaxed into an LP**, because the selection of the arcs (`use`) is a mandatory integer part. It does not matter whether only a single or all droplets travel through an edge; its full weight must be calculated. Therefore, variable `use` needs to remain binary.

One final note about these MILP formulations: **loops** (edges of the form $(a, a)$) are silently present throughout all of the formulation. We can verify that loops are either not beneficial to be used, or using them does not make a difference, in all instances they are present.

-----

## 7.5 Traveling Salesman Problem

A well-known and notoriously difficult optimization problem and its GNU MathProg model implementation is presented here. This is the **Traveling Salesman Problem (TSP)** [28].

