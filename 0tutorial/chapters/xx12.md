


## Problem 12.

The problem requires us to **maximize the minimum production** amount among all products, while keeping the problem data the same. The minimum production refers to the product for which the least amount is manufactured.

Regardless of whether we start with the simple model or the one with added limitations, this problem only requires us to modify the **objective function**. This means the **feasible solutions** and the search space remain exactly the same as before.

This also makes the **revenue parameter** irrelevant, because we are no longer interested in the total monetary value of the products, but only the production amounts (specifically, the minimum of those amounts).

We have already solved a similar problem in the case of the system of linear equations (see Problem 7 from Section 4.8), where the objective was to minimize the maximum error across all equations. Here, we need to maximize the minimum production. The required **modeling technique** is indeed similar.

The idea is to introduce a new **variable** to represent the minimum of all production amounts. Specifically, this variable will denote a **lower bound** for all the individual production amounts. This lower bound also serves as a lower bound for the minimum of those amounts. If this variable is **maximized**, the optimization process will eventually increase its value as much as possible until it reaches the true minimum of the production amounts.

Using this modeling trick, we can ensure that the final optimal solution found will correspond to the maximal possible value of the minimum production amount. This is a general method that works for any set of linear expressions where either the minimum must be maximized or the maximum must be minimized.

In the implementation, the parameters and post-processing work remain the same, as do the already-existing variables, bounds, and constraints from the extended model (including `Min_Production`, `Max_Production`, and the auxiliary variables for usage and revenue calculation):

```
var production {p in Products}, >=Min_Production[p], <=Max_Production[p];
var usage {r in Raw_Materials}, >=Min_Usage[r], <=Storage[r];
var total_revenue;
s.t. Usage_Calc {r in Raw_Materials}:
sum {p in Products} Consumption_Rate[r,p] * production[p] = usage[r];
s.t. Total_Revenue_Calc: total_revenue =
sum {p in Products} Revenue[p] * production[p];
```

The change is that, instead of the original objective of maximizing total revenue, we set the minimum production as the new objective. This requires introducing a new variable, `min_production`, to denote a lower bound for all production amounts, and a constraint to ensure that the variable is, in fact, a lower bound. Then, this new variable is maximized as the objective function.

```
var min_production;
s.t. Minimum_Production_Calc {p in Products}:
min_production <= production[p];
maximize Minimum_Production: min_production;
```

The post-processing code can be the same as before, so we print the same data as we did for the total revenue objective. We only add a `printf` statement to emphasize the minimum production amount, which is our current objective.

```
printf "Minimum Production: %g\n", min_production;
```

Note that in our code, `min_production` is the name of the **variable**, and `Minimum_Production` is the name of the **objective function**. In GNU MathProg, we could use both as values. However, be cautious when referring to the objective by its name, because constant terms in the objective are omitted. The reason for this is that constant terms do not affect the selection of the optimal solution, only the value of the objective. Therefore, it is recommended to refer to the objective function value using the variable `min_production` instead.

We can now run our model to solve two problems.

### Example 1: Ignoring Production/Usage Limits

In the first example, all the limits (`Min_Usage`, `Min_Production`, `Max_Production`) are ignored, except for the `Storage` capacity. Note that, in the data section, we can begin rows with a hash mark (`#`). This turns the row into a **comment**, effectively excluding it from processing. The data section looks like the following:

```
data;
set Products := P1 P2 P3;
set Raw_Materials := A B C D;
param Storage :=
A 23000
B 31000
C 450000
D 200
;
param Consumption_Rate:
P1
P2
P3 :=
A
200
50
0
B
25
180
75
C 3200 1000 4500
D
1
1
1
;
param Revenue :=
P1 252
P2 89
P3 139
;
param Min_Usage :=
# B 21000
# D 200
;
param Min_Production :=
# P2 100
;
param Max_Production :=
# P3 10
;
end;
```

Note that revenue data are not strictly necessary in this model, but it is not an error to assign them values, as long as the parameter is represented in the model section.

The solution to the problem results in a minimum production amount of **51.72**.

```
Total Revenue: 24827.6
Minimum Production: 51.7241
Production of P1: 51.7241
Production of P2: 51.7241
Production of P3: 51.7241
Usage of A: 12931, remaining: 10069
Usage of B: 14482.8, remaining: 16517.2
Usage of C: 450000, remaining: 0
Usage of D: 155.172, remaining: 44.8276
```

It turns out that production is **balanced** to the edge to achieve this solution. All resources are distributed evenly, and all three products are produced in an **equal amount**. If we consider the objective, this is not surprising. Why would we produce any product amount above the minimum if it offers no advantage to the objective function, but represents a disadvantage in terms of raw materials consumed?

It looks like raw material **C is the bottleneck** in this problem. We call a factor a **bottleneck** if changing that factor has a visible impact on the final solution while other factors remain the same—for example, the most scarce resource, as in this case. If there were slightly less or more of raw materials A, B, and D, the solution would be the same because all of C is completely used up and distributed evenly among the products. This kind of knowledge can be fundamental in real-world optimization problems because it informs decision-makers that some factors are unnecessary to improve. On the other hand, slightly more or less of C would likely result in slightly more or less production (likely, because there could be other limitations in the model that we do not see). For this reason, raw material **C is the bottleneck** in this particular production problem.

### Example 2: With Constraints (Excluding $P3 \le 10$)

In the second example, **Problem 11** is used but without the constraint on $P3$. This means all the limitations are now included in the model, except for the restriction that $P3$ is maximized at 10 units. Note that if this constraint were enabled, there would be no question that the optimal solution would be 10 units, as the former solution we already know produces exactly 10 units of $P3$, and there cannot be more.

In short, we only get a meaningful new problem if we **omit** the constraint maximizing $P3$ at 10 units.

```
Total Revenue: 27142.1
Minimum Production: 43.8596
Production of P1: 43.8596
Production of P2: 112.281
Production of P3: 43.8596
Usage of A: 14386, remaining: 8614.04
Usage of B: 24596.5, remaining: 6403.51
Usage of C: 450000, remaining: 0
Usage of D: 200, remaining: 0
```

The solution is slightly different in this case. Now, only **P1 and P3 are produced in equal amounts**, both at the minimum production amount of **43.86**. Also, not only C but **D is also totally used up**. Note that a much larger amount of P2 is needed because all 200 units of D must be used up in this problem. This answers a former question: why is it advantageous to produce products above the minimum limit? Because it might help satisfy the minimum production and/or minimum consumption constraints.

Note that the objective in this case is slightly **worse** than that of the first example problem, where the objective was 51.72. This is a natural consequence of differences in the data. In the second example, the data were the same, except that there were **additional constraints** on consumption and production. If a problem is more constrained, we can only get an optimal solution with the **same, or a worse, objective value**.

Generally, if only the objective is changed in a model, the set of **feasible solutions remains the same**, because the objective only guides the selection of the most suitable solution, not which solutions are feasible. In this case, the new objective function involved a new variable, `min_production`, which served as a lower bound and was maximized.

Note that, in theory, the variable `min_production` does not need any lower bound and can even be allowed to be zero or negative. The solution would still be feasible. However, such solutions are not reported because they are not optimal. Therefore, only those feasible solutions are interesting for which `min_production` is not only a valid lower bound on production amounts but is actually **strict**—that is, it equals the minimum production amount.

Among these interesting solutions, `min_production` works just like an **auxiliary variable**. Each optimal solution where `min_production` is a strict bound corresponds to a feasible solution of the original problem where revenues were maximized, and vice versa.

-----

### 5.4 Raw Material Costs and Profit

We have seen an example where only the objective was changed. Now let's look at another example, which is a more natural extension to the problem. From now on, raw materials are no longer considered **"free"**: they must be produced, purchased, stored, etc. In general, they have **costs**. Just as there is a revenue for each product per unit produced, there is now a **cost for each raw material per unit consumed**.


---