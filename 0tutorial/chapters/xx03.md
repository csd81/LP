
-----

# Chapter 3: GNU MathProg

This chapter introduces GNU MathProg and demonstrates how to use it to implement and solve mathematical programming models in the LP or MILP class. We will present a short example problem, complete with implementation, solution, and results, to highlight some of the language's most frequently used features.

-----

## 3.1 Prerequisites for Programming

GNU MathProg, also known as the **GNU Mathematical Programming Language** (GMPL), is a modeling language used for designing and solving LP and MILP problems. The **GNU Linear Programming Kit (GLPK)** provides free software that parses implemented models and solves them to report the optimal solution. GLPK is available under the General Public License version 3.0 or later [6].

There are other software tools available for solving MILP models; some are free, such as CBC or lpsolve. These tools can be much faster than GLPK. Commercial software can be even better, and some options are available through academic licenses. However, we chose GNU MathProg and the **`glpsol`** solver from GLPK because they are relatively easy to use and include both the language and the model-solving tools in one package.

GLPK installation depends on your operating system. On Linux, you can visit the official GLPK website to find installation packages, source code, and sample GNU MathProg problems. On some distributions, you can install it with a single command:

```bash
sudo apt-get install glpk-utils
```

If the installation is successful, the program **`glpsol`** should be available in your command line. Throughout this manual, we will use this tool in the command line to parse and solve models.

You can also get the command-line solver on Windows. However, a more convenient option is a desktop application called **GUSEK** [9], which is a simple Integrated Development Environment (IDE) featuring a text editor specifically for the GNU MathProg language. The `glpsol` solver is available there with all its functionalities. With GUSEK, you don't need the command line, although managing multiple files requires some attention.

A public reference manual for the GNU MathProg modeling language, including usage instructions for the `glpsol` software, is available (see reference [1]).

-----

## 3.2 "Hello World\!" Program

Once installed, we can test the program with a very simple LP problem. This will be our first GNU MathProg program, effectively a "Hello World\!" example.

```ampl
var x >= 0;
var y >= 0;
var z >= 0;
s.t. Con1: x + y <= 3;
s.t. Con2: x + z <= 5;
s.t. Con3: y + z <= 7;
maximize Sum: x + y + z;
solve;
printf "Optimal (max) sum is: %g.\n", Sum;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
end;
```

GNU MathProg is designed to be readable, and its mathematical meaning is easy to understand. The language consists of commands ending with a semicolon (;), which are called **statements**. This file contains six distinct statements: `var`, `s.t.`, `maximize`, `solve`, `printf`, and `end`. As we will see, the meanings of most are self-explanatory.

```ampl
var x >= 0;
var y >= 0;
var z >= 0;
```

First, this is an LP problem where all three variables—$x$, $y$, and $z$—can take real values. They also have **bounds** defined: each must be non-negative. Note that this is the most common bound used for variables.

```ampl
s.t. Con1: x + y <= 3;
s.t. Con2: x + z <= 5;
s.t. Con3: y + z <= 7;
```

The problem has three **constraints**, separate from the bounds, which are treated differently in the language. The constraints are named `Con1`, `Con2`, and `Con3`, respectively. The names are preceded by **"s.t."**, which is an abbreviation for "subject to," though it has several aliases and can even be omitted entirely. These constraints state that the sum of any two of the three variables cannot be greater than the given constants (3, 5, and 7, respectively).

```ampl
maximize Sum: x + y + z;
```

The goal of the optimization is to **maximize** the objective titled "Sum," which is simply the sum of the three variables. A model file can contain at most one `maximize` or `minimize` statement.

At this point, the LP problem is fully defined. While this is a relatively easy linear problem, its optimal solution might not be immediately obvious.

Note that you can omit the objective function entirely from a GNU MathProg model formulation. In that case, the only task is to find any **feasible solution** for the problem.

```ampl
solve;
printf "Optimal (max) sum is: %g.\n", Sum;
printf "x = %g\n", x;
printf "y = %g\n", y;
printf "z = %g\n", z;
end;
```

The file includes a **`solve`** statement. This marks the point where the solver software should finish reading all the data, then construct and solve the model. After the `solve` statement, you can include other statements to report valuable information about the solution. In this case, the objective value and our three variables are printed using the values obtained by the optimization procedure. The **`printf`** statement works similarly to the `printf()` function in the C programming language but supports fewer format specifiers. We prefer the `%g` format because it prints both integers and fractional values in a compact form. In some cases, a fixed-precision number, like `%.3f`, is more appropriate.

The **`end`** statement marks the end of the model description, although it is optional.

You can use any text editor you like, but some offer syntax highlighting. GUSEK on Windows has a text editor specifically designed for modeling. On Linux, you can use `gedit`. While `gedit` does not have built-in syntax highlighting for GNU MathProg by default, you can download it from the internet.

Let's name this file `helloworld.mod`. on some systems, the file extension `.mod` might be recognized as a video format by the file browser. This might cause a "double-click" to try opening the file as a video instead of a text file. For this reason, we recommend setting the file's opening method to your preferred text editor, such as `gedit`. Alternatively, you can simply use a different file extension, like `.m` or just `.txt`; it doesn't matter to `glpsol`, although it may matter if you use an IDE like GUSEK.

The `helloworld.mod` file is a **model file** because it contains the business logic of the problem we want to solve. It is sufficient on its own for defining a problem. Later on, we will split our problem formulations into a single model file and one or more **data files**. The model file encapsulates the problem's logic, while the data file(s) provide the actual data used to solve the problem. This separation is useful because if the real-world data changes, we don't need to modify the model itself. In other words, a user who wants to solve a model for a specific problem doesn't need to understand the model code; they only need to correctly implement a data file, which is much easier and less error-prone.

Use `glpsol` to solve the model file with the following command:

```bash
glpsol -m helloworld.mod
```

You should see output similar to the following:

```bash
GLPSOL: GLPK LP/MIP Solver, v4.65
Parameter(s) specified in the command line:
-m helloworld.mod

Reading model section from helloworld.mod...
20 lines were read
Generating Con1...
Generating Con2...
Generating Con3...
Generating Sum...
Model has been successfully generated
GLPK Simplex Optimizer, v4.65
4 rows, 3 columns, 9 non-zeros
Preprocessing...
3 rows, 3 columns, 6 non-zeros
Scaling...
A: min|aij| = 1.000e+00 max|aij| = 1.000e+00 ratio =
Problem data seem to be well scaled
Constructing initial basis...
Size of triangular part is 3
* 0: obj = -0.000000000e+00 inf =   0.000e+00 (3)
* 3: obj =   7.500000000e+00 inf =   0.000e+00 (0)
OPTIMAL LP SOLUTION FOUND
Time used:   0.0 secs
Memory used: 0.1 Mb (102283 bytes)
Optimal (max) sum is: 7.5.
x = 0.5
y = 2.5
z = 4.5
Model has been successfully processed
```

Since this is a small problem, the result is almost instantaneous. Let's look at what information we can read from the output.

```bash
GLPSOL: GLPK LP/MIP Solver, v4.65
Parameter(s) specified in the command line:
-m helloworld.mod
Reading model section from helloworld.mod...
18 lines were read
Generating Con1...
Generating Con2...
Generating Con3...
Generating Sum...
Model has been successfully generated
```

The first section of the output appears during the **model generation procedure**. If the model has bad syntax, it will be noted here. Note that only the first error is displayed. Notice that the constraints and the objective are the model elements that must be "generated."

```bash
GLPK Simplex Optimizer, v4.65
4 rows, 3 columns, 9 non-zeros
Preprocessing...
3 rows, 3 columns, 6 non-zeros
Scaling...
A: min|aij| = 1.000e+00 max|aij| = 1.000e+00 ratio =
Problem data seem to be well scaled
Constructing initial basis...
Size of triangular part is 3
* 0: obj = -0.000000000e+00 inf =   0.000e+00 (3)
* 3: obj =   7.500000000e+00 inf =   0.000e+00 (0)
OPTIMAL LP SOLUTION FOUND
Time used:   0.0 secs
Memory used: 0.1 Mb (102283 bytes)
```

The solution procedure for an LP problem—from the constraints to the final, optimal solution—is an interesting subject in Operations Research. However, we won't focus on the underlying solution algorithms here. Still, basic knowledge about them will help us with debugging later. First, all LP problems are represented in a **matrix of coefficients**, where the rows correspond to constraints (and the objective), the columns correspond to variables, and the matrix entries are the coefficients of a given variable in a given constraint. Some preprocessing steps are performed on this matrix, and then the main algorithm is launched.

Two rows in this output show a "current" result. The first shows an objective of 0; the second shows the objective $7.5$, which is actually the final optimal solution. The row "OPTIMAL LP SOLUTION FOUND" indicates that the solver successfully solved the problem and now knows the optimal solution and the corresponding variable values. If there are multiple optimal solutions, one is chosen.

For more complex problems, finding the solution can take significant time, and the current best solutions are updated regularly. The procedure may end before reaching the optimal solution, in which case the best feasible solution found so far is reported. This happens, for example, when you set a time limit for `glpsol` and that limit is exceeded during the process.

```bash
Optimal (max) sum is: 7.5.
x = 0.5
y = 2.5
z = 4.5
Model has been successfully processed
```

Finally, we see the result of the `printf` statements we added at the end. The optimal solution is $x = \frac{1}{2} = 0.5$, $y = \frac{5}{2} = 2.5$, $z = \frac{9}{2} = 4.5$, and the objective function value is $x + y + z = \frac{15}{2} = 7.5$. This result means we cannot choose values for the variables to obtain a larger sum unless at least one of the constraints (or bounds) is violated. Note that `printf` statements are also valid before the `solve` statement—that is, during the model construction procedure. However, variables and the objective are not available before the `solve` statement because they haven't been calculated yet. The final "Model has been successfully processed" message indicates that the solver call was successful.

We should also note that the `glpsol` command-line tool has many other options. For example, you can automatically print a solution file using the `-o` option. You can save the program's output with the `--log` option. Additionally, you can export the constructed model to formats that other MILP solvers can use. For instance, the `--wlp` option exports to CPLEX-LP matrix format, which is supported by many other solver software. Perhaps you don't want to use `glpsol` to solve the model; you only need it to translate the model to another format. In that case, the `--check` option ensures that the model is only parsed, not solved. It is also possible to manipulate the solution procedure in many ways.

Now that we have successfully formulated, solved, and analyzed the output for our first LP problem in GNU MathProg, let's make a slight change to the model file. Add the **integer restriction** to all three variables, as shown below. Save the modified file as `helloworld-int.mod`.

```ampl
var x >= 0, integer;
var y >= 0, integer;
var z >= 0, integer;
```

This is no longer an LP model; it is now a **Mixed-Integer Linear Programming (MILP)** model because some (in this case, all) of the variables must take integer values. Solving the model with `glpsol` is the same:

```bash
glpsol -m helloworld-int.mod
```

The solver identifies the model as MILP, and there are some changes in the generated output.

```bash
Solving LP relaxation...
GLPK Simplex Optimizer, v4.65
3 rows, 3 columns, 6 non-zeros
* 0: obj = -0.000000000e+00 inf =   0.000e+00 (3)
* 4: obj =   7.500000000e+00 inf =   0.000e+00 (0)
OPTIMAL LP SOLUTION FOUND
Integer optimization begins...
Long-step dual simplex will be used
+     4: mip =   not found yet <=     +inf        (1; 0)
+     6: >>>>>   7.000000000e+00 <=   7.000000000e+00   0.0% (2; 0)
+     6: mip =   7.000000000e+00 <=   7.000000000e+00   0.0% (0; 3)
tree is empty
INTEGER OPTIMAL SOLUTION FOUND
Time used:   0.0 secs
Memory used: 0.1 Mb (124952 bytes)
Optimal (max) sum is: 7.
x = 1
y = 2
z = 4
Model has been successfully processed
```

Notice that a so-called **LP relaxation** is solved first. The output for this appears identical to the output for our initial LP problem. This is actually the nature of the solution algorithm: the problem is first solved as if all integer restrictions were removed—treating it as an LP problem. Then, the actual MILP model is solved, and we find that the optimal solution is only $7.0$ instead of the LP's optimal solution of $7.5$.

This isn't surprising. The only difference between the two models is that the integer problem is more restrictive regarding the variables. This means any solution to the MILP is also a solution to the LP. However, the reverse is not true, as the optimal solution of the LP ($x = 0.5$, $y = 2.5$, $z = 4.5$) was eliminated by the integer restrictions. LP relaxation is an important concept in solving MILP models—for example, it serves as a good initial solution when trying to force all variables to integer values. Also, if the integer variables happen to result in integer values in the LP relaxation, that solution is guaranteed to be optimal for the MILP as well, because the MILP is the more restricted problem.

In this model, the solver needed a little extra work for the MILP and found the solution $x = 1$, $y = 2$, and $z = 4$. Note that while this is an optimal solution, it is not the only one. $x = 0$, $y = 3$, $z = 4$ and $x = 0$, $y = 2$, $z = 5$ are also feasible and optimal solutions with the same objective value of $7.0$.

As you might suspect, the algorithmic procedure behind the MILP can be substantially more complex than that of an LP. However, the only difference in the formulation is the integer restrictions on the variables.

Keep in mind that while solvers can handle a large number of variables and constraints in an LP model, they can usually only handle a **limited number of integer variables** in an MILP model. The exact limit strongly depends on the model itself and can range from dozens to thousands.