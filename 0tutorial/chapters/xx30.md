---------------
Problem 42.
Solve Problem 40, the assignment problem, with the addition of a priori decisions: some possible
assignments are explicitly declared to either be used or not used.
This extension is not specific to the assignment problem. Such considerations may arise for every
real-world optimization problem. The technique we show here is also not specific.
Our primary goal is to support a priori decisions without compromising the already implemented
functionality. That means, old data files not containing any decisions shall still work.
First, we define a new parameter named Fixing to express these a priori decisions, for all
assignments.
param Fixing {(w,t) in Assignments}, in {0,1,2}, default 2;
This parameter has three possible values.
• The value 0 means we exclude the assignment from the possible choices.
• The value 1 means we must use this assignment in the solution.
• The value 2 means that we do not decide beforehand whether we want the assignment or not,
this decision is rather left as freedom for optimization.
As the value 2 is set as the default for the parameter, if the Fixing variable is not mentioned at
all in the data sections, then the model assumes that there are no a priori decisions. This addresses
compatibility with old data files.
Next, we need these decisions to work. For all Fixing values that are either 0 or 1, we explicitly
set the assign variable to the Fixing value. The indexing goes over all possible assignments, but
those possible assignments that are left to be decided are filtered out and therefore not fixed.
s.t. Fixing_Constraints {(w,t) in Assignments: Fixing[w,t]!=2}:
assign[w,t] = Fixing[w,t];
This completes our new model, which not only solves the assignment problem, but supports a
priori decisions to be made, and only optimizes over the restricted set of cases. We now demonstrate
its usage by two alternative trials.
First, we set the assignment W6 to T6 fixed as zero. This is the only possible assignment that
is decided a priori. This case is related to the original example Problem 41, because its optimal
solution involves this assignment. Therefore prohibiting this assignment forces the solver to find
another solution. The data section modifications and the results are shown below.
143

7.3. ASSIGNMENT PROBLEM

MILP MODELS

param Fixing :=
W6 T6 0
;

Optimal Cost: 42
W1->T2 (6)
W2->T6 (5)
W3->T7 (6)
W4->T5 (6)
W5->T3 (7)
W6->T1 (5)
W7->T4 (7)
It turns out that although the W6 to T6 assignment has a cost of 3 which is the second smallest
in the whole cost matrix, there is still an alternative solution with the objective 42 which omits it.
Now for the second trial, set the assignment W4 to T3 as mandatory. This is the cheapest possible
assignment in the whole matrix with a cost of 2, but was not included in either optimal solution
previously reported. This is the only a priori decision in the second trial. The data added and
results are the following.
param Fixing :=
W4 T3 1
;

Optimal Cost: 43
W1->T2 (6)
W2->T7 (5)
W3->T5 (10)
W4->T3 (2)
W5->T1 (10)
W6->T6 (3)
W7->T4 (7)
Surprisingly, including assigning W4 to T3 turns out to be a bad idea, as the optimal solution
with this decision is only 43 now, 42 cannot be obtained anymore.
Further than demonstrating the usage of a priori decisions made for a model, the results show
that simple greedy heuristics like taking the smallest cost first does not work perfectly for the
assignment problem.
Finally, note that the implementation of a priori decisions by manipulating problem data –
particularly for the assignment problem – is also possible.
• If a possible assignment is assigned a very large positive cost, like a positive big-M, then it is
not beneficial for the solver to use. Therefore that assignment is effectively excluded.
• If a possible assignment is assigned a very large negative cost, like a negative big-M, then the
solver is effectively forced to use that assignment.
A priori decisions can easily make the problem infeasible, if those decisions are contradictory.
In case we implement a priori decisions by very large negative and positive big-M costs, then the
144

7.4. GRAPHS AND OPTIMIZATION

MILP MODELS

model will not be infeasible. Instead, it tries to select as few forbidden and as many mandatory
possible assignments as possible. Assignments in the solution despite their positive big-M costs, or
assignments missing despite their negative big-M costs indicate that the assignment is not possible
as described by a priori decisions. Nevertheless, the solver does its best to minimize the objective
anyways.

7.4

Graphs and optimization

Two basic problems from the field of graph theory are mentioned now which can be solved by MILP
models. For readers interested in topics of graph theory, we offer a good introductory book [23],
but the definitions and theorems needed for the two problems are presented in this Tutorial.
A simple graph has nodes and undirected edges, where each edge connects two different
nodes, and any two nodes are connected by at most one edge. This is in contrast with non-simple
graphs where loops and multiple edges are allowed, and with directed graphs, where edges are
substituted by arcs directing from one node to another.
Some further definitions are introduced that are required to understand the upcoming problem
definitions.
• A path in a graph is a sequence of distinct nodes, where the adjacent nodes in the sequence
are connected by an edge. If the first and last member of a path are connected by an edge,
then together with that edge, the path forms a cycle (see Figure 9).
• A graph is connected if any two of its nodes can be connected with a path. Otherwise, it is
disconnected (see Figure 10). Informally, a connected graph is „one big component”, and a
disconnected graph consists of multiple components.
• A tree is a connected graph with no cycles.
• A spanning subgraph of a graph is another graph with the all its nodes, and the same or
fewer edges.
• A spanning tree of a graph is a spanning subgraph which is a tree (see Figure 11). Spanning
trees are obtained by erasing edges of the graph until it contains no more cycles, but is still
connected.

Figure 9: A path and a cycle in the same graph.
Simple graphs are useful for representing the scheme of a network of connections, but sometimes
the graph is extended by additional data. One common extension is edge weight, which is a number
assigned to each edge. This leads to a weighted simple graph. From now on, we assume weights
are positive. The two problems to be solved are the following.
