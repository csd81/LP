
## Advanced Modeling Techniques: Big-M Constraints

### Expressing logical conditions in models

**Prerequisites**

  * Advanced modeling techniques: "Redundant" variables
  * Advanced GMPL techniques: data/logic decoupling

### The Usual Issue

When modeling real-world scenarios, we often face conditions in the form of "if *A* holds, then *B* should happen." Examples include:

  * The domain for the size, capacity, or activity level of an entity is often not just a closed interval or a simple on/off switch. Instead, it can be a set of disjoint intervals. A very common situation is a variable that is either 0 or within a $[min, max]$ interval. This decision cannot be described by a single decision variable, whether discrete or continuous. It is usually modeled by a binary variable $y$ (denoting whether we are at 0 or in the interval) and a continuous variable $x$ (which holds the actual value). In this case, we have the constraint: if $y=0$ then $x$ should be 0; otherwise, $x \in [min, max]$.
  * In scheduling, we often have constraints stating that if two tasks are assigned to the same resource, their processing times must not overlap.
  * When writing a model, we often encounter bilinear terms (i.e., the product of a continuous variable and an integer/binary variable). Such a model is not linear; however, it can be converted to a linear one by assigning a continuous variable to the product. The rule is: if the binary variable is 0, the product should be 0; otherwise, it should equal the original continuous variable.
  * Sometimes a binary decision depends on another. For instance, we decide which site to send a worker to, and at each site, we decide which tasks they will perform. Obviously, one cannot perform a task at a location they did not visit.

The problem is that there is no conditional "language element" in MILP models. Fortunately, there is a modeling trick that can be applied to express these conditions, as discussed below. First, however, let's look at an example where this is needed.

### Repairman Allocation Problem

We provide technical support for companies located in different cities. On each site, there are issues that we must fix today. We work with specialist contractors, whom we will call repairmen from now on. For each day, we must tell these repairmen in advance whether we will be hiring them, and if so, where they should go and which issues they should fix. A repairman's shift can be at most 12 hours, and we must account for a travel overhead of 1 hour on average per location.

For the moment, we will make some assumptions:

  * Each repairman can fix any of the issues.
  * An issue is fixed within the same amount of time, regardless of the repairman.
  * The wages of the repairmen are the same.
  * The traveling time between any two sites is the same.
  * There is no timing involved and no dependency between the issues.

Later on, you can generalize the problem by removing some of these assumptions and altering the model accordingly.

The goal is to minimize the salary we have to pay, which is essentially the hourly wage multiplied by the total travel time and the time spent fixing issues. Let's start building our model.

The input data for the problem is given with these sets and parameters:

```
set Sites;
param traveltime;
set Issues;
param site{Issues} symbolic, within Sites;
param time{Issues} >=0;
set Repairmen;
param maxhours;
param wage;
```

The variables are self-evident:

```
var visits{Repairman,Sites} binary;
var fixes{Repairman,Issues} binary;
```

As for the constraints: first, each and every issue needs to be fixed:

```
s.t. FixAllIssues{i in Issues}:
  sum{r in Repairmen} fixes[r,i] = 1;
```

A repairman cannot work more than the given limit:

```
s.t. MaxWorkLoad{r in Repairmen}:
  sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i]) <= maxhours;
```

The objective is simple: minimizing the total cost, which will be quite similar to the LHS of the last constraint, only summed for all the repairmen:

```
minimize TotalCost:
  wage * sum {r in Repairmen} (sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i]));
```

If we solve this model, we recognize that all `visits[r,s]` variables are 0 in the optimal solution. The reason is that we have not yet expressed the constraint: **A repairman can only fix an issue if he/she visits its site.**

Translating that to our notation: `fixes[r,i]` can only be 1 if `visits[r,site[i]]` is also 1. Perhaps the equivalent statement from the opposite direction is more straightforward: if a repairman does not visit a site, they cannot fix any of the issues there (i.e., if `visits[r,s]==0`, then `fixes[r,i]` must be 0 for all $i$ such that `site[i]==s`). We might be tempted to express this as follows:

```
s.t. NoMagicalTeleportation{r in Repairmen, s in Sites, i in Issues : visits[r,s]==0 && site[i]==s}:
  fixes[r,i]=0;
```

The problem with this constraint is that the filtering is based not only on "static" parameters and sets but on "dynamic" variables as well. This implies that constraints would be added or removed during the optimization procedure depending on the variable values. Since that is not how MILP solvers work, `glpsol` will return an error message.

So we must find another way. Let's start by writing our idea informally:

```
s.t. NoMagicalTeleportation{r in Repairmen, s in Sites, i in Issues: site[i]==s}:
  if visits[r,s]==0 then fixes[r,i]=0;
```

First of all, there is no need for the `s in Sites` part, as there will always be only a single $s$ for each $i$:

```
s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  if visits[r,site[i]]==0 then fixes[r,i]=0;
```

The core idea for our trick is to include the "deciding" binary variable, `visits[r,site[i]]`, into the constraint `fixes[r,i]=0` such that when it is 0, the constraint holds, and when it is 1, the constraint becomes "relaxed" (meaning it does not restrict anything).

Relaxing an equality is somewhat troublesome. Therefore, when possible, we should try to figure out whether we can state the same logic with an inequality. In the worst case, an $lhs = rhs$ equality can be transformed into the conjunction of two inequalities: $lhs \ge rhs$ and $lhs \le rhs$. However, in this case, the following will suffice:

```
s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  if visits[r,site[i]]==0 then fixes[r,i]<=0;
```

Since `fixes[r,i]` can only be 0 or 1, "equal to 0" is equivalent to "less than or equal to 0." Now, drumroll please, `visits[r,site[i]]` can be included in the constraint like this:

```
s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  fixes[r,i]<=0          + visits[r,site[i]];
```

Now, let us examine this constraint:

  * If `visits[r,site[i]]` is 0, then it "disappears" from the right side, and the constraint `fixes[r,i]<=0` remains, as intended.
  * If `visits[r,site[i]]` is 1, then the RHS becomes 1, and the constraint is essentially `fixes[r,i]<=1`. Since `fixes[r,i]` is a binary variable that can be at most 1, this constraint is effectively non-binding.

As we can see, the above constraint does exactly what we needed and implements that conditional behavior. Of course, it could be simplified like this:

```
s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  fixes[r,i]<=visits[r,site[i]];
```

### Refining the model a little bit

Putting everything together, we have:

```
set Sites;
  param traveltime;
set Issues;
  param site{Issues} symbolic, within Sites;
  param time{Issues} >=0;
set Repairmen;
  param maxhours;
  param wage;

var visits{Repairman,Sites} binary;
var fixes{Repairman,Issues} binary;

s.t. FixAllIssues{i in Issues}:
  sum{r in Repairmen} fixes[r,i] = 1;

s.t. MaxWorkLoad{r in Repairmen}:
  sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i]) <= maxhours;

s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  fixes[r,i]<=visits[r,site[i]];

minimize TotalCost:
  wage * sum {r in Repairmen} (sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i]));
```

Now let us assume a more realistic scenario: if we hire someone for the day, we must pay them for at least 8 hours of work, even if a single issue is solved in, for example, 3 hours.

To implement this, it is beneficial to introduce a redundant variable describing how much a person has actually worked. This will also simplify the `MaxWorkLoad` constraint and the objective function:

```
set Sites;
  param traveltime;
set Issues;
  param site{Issues} symbolic, within Sites;
  param time{Issues} >=0;
set Repairmen;
  param maxhours;
  param wage;

var worked{Repairmen} >= 0;  # <--- NEW REDUNDANT VARIABLE
var visits{Repairman,Sites} binary;
var fixes{Repairman,Issues} binary;

s.t. FixAllIssues{i in Issues}:
  sum{r in Repairmen} fixes[r,i] = 1;

s.t. Workload{r in Repairmen}: #<--- new constraint to set the new variable
  worked[r] = sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i])
  
s.t. MaxWorkLoad{r in Repairmen}: # <--- SIMPLIFIED CONSTRAINT
   worked[r] <= maxhours;

s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  fixes[r,i]<=visits[r,site[i]];

minimize TotalCost: # <--- SIMPLIFIED OBJECTIVE
  wage * sum {r in Repairmen} worked[r];
```

Now, we should somehow implement the "at least 8 hours rule." The first idea might be to change the declaration of the new variable like this:

```
var worked{Repairmen} >= 8;
```

However, this would require every repairman to work at least 8 hours, which is doubly problematic:

1.  Not everyone should work 8 hours.
2.  The rule said nothing about *working* at least 8 hours, only about *paying* for at least 8 hours.

From the second point above, it is straightforward that we need a new variable indicating how much is paid to a person:

```
var paid{Repairmen} >=0;
```

Then the objective can easily be changed:

```
minimize TotalCost: 
  sum {r in Repairmen} paid[r];
```

And for the moment, let's connect `paid[r]` with `worked[r]` like this:

```
s.t. Payment{r in Repairman}:
  paid[r]=wage*worked[r];
```

With all these changes, the model functions exactly the same so far.
However, now we have the opportunity to implement the "at least 8 hours" rule. First, let us introduce the new parameter:

```
param minhourspaid;
```

Then we can state in the variable declaration that:

```
var paid{Repairmen} >= wage * minhourspaid;
```

And we need to relax the above constraint like this:

```
s.t. Payment{r in Repairman}:
  paid[r]>=wage*worked[r];  # <--- GREATER-EQUAL INSTEAD OF EQUAL
```

What we achieved is that `paid[r]` is now greater than or equal to `wage * worked[r]` and `wage * minhourspaid`. Basically, it is at least the maximum of the two.

Note that `paid[r]` can now be larger than `wage * worked[r]` even if `worked[r] > minhourspaid`. Effectively, the model allows us to pay a person more than they earned/worked for. However, this is not a problem because we want to minimize costs; thus, such solutions—even though feasible—would not be optimal.

Another problem remains, however. In this setup, everyone must be paid for at least 8 hours, even those who are not hired for the day. In other words, `paid[r]` is always greater than or equal to `wage * worked[r]` (which is fine), but it is also always greater than or equal to `wage * minhourspaid` (which is not). We should remove that initial bound from the variable declaration and use a constraint instead:

```
var paid{Repairmen} >= 0; # <--- CHANGED LOWER BOUND TO 0

...

s.t. MinimumWorkHours{r in Repairman}:
  if r is hired for the day then: paid[r] >= wage * minhourspaid;
```

Now we have a new problem (we just can't seem to run out of them): we have no expression describing whether someone is hired or not. A general rule of thumb: if there is no easy expression for something, it should probably be introduced as a variable, even if it is redundant:

```
var paid{Repairmen} >= 0;
var hired{Repairmen} binary;

...

s.t. MinimumWorkHours{r in Repairman}:
  if hired[r]==1 then: paid[r] >= wage * minhourspaid;
```

Since the RHS is only a constant expression (no variables included), we can easily "resolve" this `if`:

```
var paid{Repairmen} >= 0;
var hired{Repairmen} binary;

...

s.t. MinimumWorkHours{r in Repairman}:
  paid[r] >= wage * minhourspaid * hired[r];
```

It is easy to see that if $r$ is hired, the intended constraint holds; otherwise, it just says that `paid[r] >= 0`, which, again, is not restrictive at all.

We are not ready yet, though, since `hired[r]` has no connection to the other binary variables. Thus, the model allows a repairman to not be hired while still solving issues. We want to express that $r$ can only solve issues or travel to sites if they are hired for the day. Put formally: `visits[r,s]` or `fixes[r,i]` can only be 1 if `hired[r] = 1`. Again, it may be simpler to view this from the other direction: if `hired[r] == 0`, then all `visits[r,s]` and `fixes[r,i]` variables must be 0 as well:

```
s.t. CannotWorkIfNotHired{r in Repairmen}:
  if hired[r]==0 then all visits[r,s],fixes[r,i] must be 0;
```

There is an easy way to ensure a group of binary variables are all 0: their sum should be 0, or (since inequalities are preferred—see above) less than or equal to 0. So:

```
s.t. CannotWorkIfNotHired{r in Repairmen}:
  if hired[r]==0 then sum{s in Sites }visits[r,s] + sum {i in Issues}fixes[r,i] <= 0;
```

Now we only need to resolve that conditional. The RHS should be 0 if `hired[r]` is 0; otherwise, it should be a large number to make the constraint "meaningless" (non-binding). Something like this would work:

```
s.t. CannotWorkIfNotHired{r in Repairmen}:
  sum{s in Sites }visits[r,s] + sum {i in Issues}fixes[r,i] <= ReallyBigNumber * hired[r];
```

We can see that this equation would do exactly what we want it to do; we just have to assign a value to `ReallyBigNumber`, for example:

```
param ReallyBigNumber := 1000;
```

But how do we know that 1000 is enough? What if we have 100,000 sites and 99,999,999,999 issues? Well, our model would probably never be solved on current machines to begin with, but putting that aside: even if $r$ is hired, they could work on at most 1000 issues, regardless of how fast they are. In practice, selecting such a value is usually easy, as we roughly know the range of other parameters and the context in which it will be used. However, for the mathematician at heart, that is not a satisfactory response. We can often be theoretically correct, too. Here, the sum of the sizes of the sets `Sites` and `Issues` is a "good enough" value. That can actually be expressed in GMPL:

```
param ReallyBigNumber := card(Sites)+card(Issues);
```

One final touch: this parameter is often denoted by $M$, a capital/big M, representing a large value. Thus, these kinds of constraints are often referred to as **big-M constraints**.

### The Final Model

```
set Sites;
  param traveltime;
set Issues;
  param site{Issues} symbolic, within Sites;
  param time{Issues} >=0;
set Repairmen;
  param maxhours;
  param wage;

param M:=card(Sites)+card(Issues)

var worked{Repairmen} >= 0;
var paid{Repairmen} >= 0;

var hired{Repairmen} binary;

var visits{Repairman,Sites} binary;
var fixes{Repairman,Issues} binary;

s.t. FixAllIssues{i in Issues}:
  sum{r in Repairmen} fixes[r,i] = 1;

s.t. Workload{r in Repairmen}: 
  worked[r] = sum{s in Sites} (traveltime*visits[r,s]) + sum{i in Issues}(time[i]*fixes[r,i])
  
s.t. MaxWorkLoad{r in Repairmen}:
   worked[r] <= maxhours;
   
s.t. Payment{r in Repairman}:
  paid[r]=wage*worked[r];

s.t. NoMagicalTeleportation{r in Repairmen, i in Issues}:
  fixes[r,i]<=visits[r,site[i]];

s.t. MinimumWorkHours{r in Repairman}:
  if hired[r]==1 then: paid[r] >= wage * minhourspaid;

s.t. CannotWorkIfNotHired{r in Repairmen}:
  sum{s in Sites }visits[r,s] + sum {i in Issues}fixes[r,i] <= M * hired[r];
  
minimize TotalCost: 
  sum {r in Repairmen} paid[r];
```

### Several forms of big-M constraints / logical conditionals

In the example above, we have seen several different ways of implementing logical conditionals in simple linear constraints. Some of the most commonly used ones are summarized here, without aiming for completeness. It is always assumed that $y, y', y^*, y_1, y_2, \dots, y_n$ are binary variables.

**If $y=1$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot (1-y)$$

**If $y=0$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot y$$

**If $y=1$ then $LHS = RHS$:**
$$LHS \ge RHS - M \cdot (1-y)$$
$$LHS \le RHS + M \cdot (1-y)$$

**If $y=0$ then $y'$ must be 0:**
$$y' \le y$$

**If $y=1$ then $y'$ must be 0:**
$$y' \le 1-y$$

**If $y=0$ then $y_1, y_2, \dots, y_n$ must be 0:**
$$y_1 + y_2 + \dots + y_n \le M \cdot y$$

**If $y=0$ then $y_1, y_2, \dots, y_n$ must be 1:**
$$y_1 + y_2 + \dots + y_n \ge n \cdot (1-y)$$

**If $y=1$ and $y'=1$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot (2 - y - y')$$

**If $y=0$ and $y'=0$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot (y + y')$$

**If $y=0$ and $y'=1$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot (y + (1-y'))$$

**If $y=1$ and $y'=0$ and $y^*=1$ then $LHS \ge RHS$:**
$$LHS \ge RHS - M \cdot ((1-y) + y' + (1-y^*))$$

**$y^*$ must be 1 if and only if $y=1$ and $y'=1$:**
$$y^* \ge -1 + y + y'$$
$$y^* \le \frac{y+y'}{2}$$

### Bilinear Terms

A bilinear term is something like $y \cdot x$ where $y$ and $x$ are both variables. If one of the terms is binary and the other is, for example, a non-negative continuous variable, the model can be linearized using big-M constraints as follows. The term itself should be replaced by a new non-negative continuous variable $z$, and the model should be extended with the following constraints:

$$z \le x$$
$$z \le M \cdot y$$
$$z \ge x - M \cdot (1-y)$$

  * **If $y=1$**, then $z$ should just be $x$. In this case, the above equations reduce to this:
    $$z \le x$$
    $$z \le M$$
    $$z \ge x$$
    The second constraint doesn't do anything; the other two set $z$ to $x$.

  * **If $y=0$**, then $z$ should just be 0. In this case, the above equations reduce to this:
    $$z \le x$$
    $$z \le 0$$
    $$z \ge -M (+x)$$
    The second constraint is stronger than the first and sets $z$ to 0. The third doesn't do anything.

### A Note on Efficiency

Big-M constraints can slow down the solution of an MILP problem, as they usually do not contribute well to bounding subproblems. Thus, as a general rule of thumb: only use such constraints when necessary, and if you do, try not to use unnecessarily large values. For example, don't write $y' \le 1000 \cdot y$ instead of just $y' \le y$. It is not guaranteed that big-M constraints will make your model slow—sometimes they don't—but it is generally good practice to avoid them if possible.

### Final Notes

The goal of this lecture was to introduce a modeling technique that allows seemingly un-modelable conditionals to be translated into standard linear constraints. In practice, this technique is used very extensively, as it is often needed.