## Linear Programming: First Steps

Constructing the initial **(Mixed-Integer) Linear Programming ((MI)LP)** models for the motivational examples.

***

### Prerequisites

* Motivational example: festivals
* Motivational example: *fröccs* (a Hungarian wine spritzer)

### Modeling in General

Modeling is a technique used in many fields for various purposes, such as **simulation**, **planning**, and, of course, **optimization**. A model is essentially a **simplified version of something real**, making it easier and cheaper to work with. A model isn't necessarily mathematical; a mock-up, for instance, can be considered a physical model. On this site, however, the term **model** will always refer to a **mathematical model** unless specified otherwise.

Many things can serve as a model. The simplest ones are taught in high school physics classes, such as $v = s/t$, where $v$ denotes the average velocity if distance $s$ is covered within time $t$. This model is a simple equation with three variables. Other models might employ different mathematical structures, such as graphs. In this course, we'll focus on **algebraic models**, as discussed below.

It's important to note that, in most cases, a model is only a **"simplification"** of a real-life phenomenon. Usually, the model disregards some parameters that might influence the system's behavior. In the example above, it was assumed that the object moved along a straight line. When a real-life problem emerges, the modeler has a great responsibility in selecting the parameters to include in the model and the level of detail with which they are represented.

This can be clearly shown by the evolution of GPS navigation tools. The basic problem is simple: we want to get from point A to point B as fast as possible.

1.  The simplest approach is to find the **shortest path** between the locations. This is easy to do if the weighted graph of the road network is available.
2.  A slightly more advanced approach would be to consider the **speed limit** on each part of the road and replace the distances in the graph with the minimal travel time needed. Computationally, this approach requires the same resources, but more input data is necessary.
3.  Most modern navigation systems that run on devices with an internet connection go a step further and use **real-time traffic data** when planning a trip.
4.  We could go even further by including weather data, road conditions, the characteristics of the driver, etc. As we include more and more parameters, the model becomes more and more **accurate**, but also **more difficult to handle**.

In general, the goal is to find a model that:

* Can be solved/simulated/etc. with the available computing resources in a **reasonable amount of time**.
* Can provide results that are **accurate enough** to be relevant to the original real-life problem.
* Requires only data that **can be provided**.

Later on, we won't focus on this initial step of modeling. We'll assume these decisions have already been made, and we just need to construct and solve the appropriate mathematical model.

***

### Model for the *Fröccs* Example

Let's assume we have a proposed solution (not necessarily the optimal one) that specifies how much we sell of different kinds of beverages. Let $x_{KF}$ denote the number of portions of *kisfröccs* sold, $x_{NF}$ the number of portions for *nagyfröccs*, and so on.

Based on these values, we can easily calculate the total amount of wine needed for this solution. For $x_{KF}$ portions of *kisfröccs*, $x_{KF} \cdot 1$ dL of wine is needed. Similarly, $x_{NF} \cdot 2$ dL of wine must be used for $x_{NF}$ portions of *nagyfröccs*. Following this logic, the total amount of wine used, in deciliters, is:

$$1 \cdot x_{KF} + 2 \cdot x_{NF} + 1 \cdot x_{HL} + 3 \cdot x_{HM} + 2 \cdot x_{VHM} + 9 \cdot x_{KrF} + 1 \cdot x_{SF} + 6 \cdot x_{PF}$$

The wine stock is 100 liters $= 1000$ deciliters. Therefore, regardless of the values, the following inequality must hold for a good solution:

$$1 \cdot x_{KF} + 2 \cdot x_{NF} + 1 \cdot x_{HL} + 3 \cdot x_{HM} + 2 \cdot x_{VHM} + 9 \cdot x_{KrF} + 1 \cdot x_{SF} + 6 \cdot x_{PF} \le 1000$$

A very similar constraint can be constructed for the soda as well:

$$1 \cdot x_{KF} + 1 \cdot x_{NF} + 2 \cdot x_{HL} + 2 \cdot x_{HM} + 3 \cdot x_{VHM} + 1 \cdot x_{KrF} + 9 \cdot x_{SF} + 3 \cdot x_{PF} \le 1500$$

If the values for $x_{KF}, x_{NF}, \ldots$ are selected from the $[0, \infty[$ interval such that the two inequalities above are satisfied, the solution is **feasible** and valid. We now have a simple algebraic model for the restrictions. The only missing part is to express our objective.

Similar to the wine and soda usage, the **profit** attained with such a plan is:

$$110 \cdot x_{KF} + 200 \cdot x_{NF} + 120 \cdot x_{HL} + 260 \cdot x_{HM} + 200 \cdot x_{VHM} + 800 \cdot x_{KrF} + 200 \cdot x_{SF} + 550 \cdot x_{PF}$$

And this is the value we want to **maximize**.

Putting everything together, we get the complete model:

$$\begin{align*} x_{KF}, x_{NF}, x_{HL}, x_{HM}, x_{VHM}, x_{KrF}, x_{SF}, x_{PF} &\in [0, \infty[ \\ 1 \cdot x_{KF} + 2 \cdot x_{NF} + 1 \cdot x_{HL} + 3 \cdot x_{HM} + 2 \cdot x_{VHM} + 9 \cdot x_{KrF} + 1 \cdot x_{SF} + 6 \cdot x_{PF} &\le 1000 \\ 1 \cdot x_{KF} + 1 \cdot x_{NF} + 2 \cdot x_{HL} + 2 \cdot x_{HM} + 3 \cdot x_{VHM} + 1 \cdot x_{KrF} + 9 \cdot x_{SF} + 3 \cdot x_{PF} &\le 1500 \\ 110 \cdot x_{KF} + 200 \cdot x_{NF} + 120 \cdot x_{HL} + 260 \cdot x_{HM} + 200 \cdot x_{VHM} + 800 \cdot x_{KrF} + 200 \cdot x_{SF} + 550 \cdot x_{PF} &\to \max \end{align*}$$

This mathematical description of the problem's restrictions, goals, and decision flexibilities adheres to the rules of a **Linear Programming (LP)** model:

* There are a **finite number of variables**.
* The **domain of each variable is a continuous interval**.
* There are a **finite number of constraints**.
* The **left-hand side (LHS)** of each constraint is a **linear expression** of the variables.
* The relation in each constraint is either $\le$, $=$, or $\ge$.
* The **right-hand side (RHS)** of each constraint is a **constant**.
* The **objective function** is a **linear expression** of the variables, which can be either maximized or minimized.

Mathematical models that meet the above conditions are **LP models**. They can be solved to **optimality efficiently** (computational time is bounded by a polynomial function of the number of variables) using a simplex algorithm variant or an interior point method.

***

### Model for the Festival Example

Let's try to create a similar model for the festival example. First, observe the relationship between the parts of the problem description and the parts of the mathematical model.

In the LP model above, the **variables** represented the **decisions** we could make—the flexibility of the problem. Each possible option for a decision is encoded by a value in the domain of the corresponding variable, and vice-versa. The **restrictions** of the problem description were expressed via **constraints**. Finally, the **objective function** modeled our **goal**.

| Problem Definition | Linear Programming Model |
| :--- | :--- |
| Decision | $\iff$ Variable |
| Option for decision | $\iff$ Value of the variable |
| Restriction | $\iff$ Constraint |
| Goal | $\iff$ Objective function |

Let's construct the model along these lines in three simple steps:

#### Step 1: Variables

For the festival example, the decision we can make is whether we go to a festival or not. Let's represent this with variables $y_1, y_2, y_3, y_4,$ and $y_5$.

Next, we must define the domain of each variable and assign a "meaning" (decision option) to each possible value. In this case, the possible outcome for each decision is either going to that particular festival or not going. Thus, the domain must have two elements. Theoretically, we could choose any two numerical values; however, it's logical (and will be useful later) to have the following assignments:

$$y_n = 1: \text{We will go to the } n \text{-th festival}$$
$$y_n = 0: \text{We will not go to the } n \text{-th festival}$$

#### Step 2: Constraints

If the variables and value assignments are selected appropriately, deriving the equations is often straightforward, like for the *fröccs* example. Sometimes it's a bit trickier, as in this case.

First, we must identify our restrictions. The only restriction here is: **we have to see all of our favorite bands at least once.** This actually means seven separate conditions for the seven bands.

Sticking to one band, say Haggard, we know that we must go to at least one of festivals 1, 3, and 4 to see them. Translating that to our variables: at least one of $y_1, y_3,$ and $y_4$ must take the value of 1. So we must construct a constraint that evaluates to true if and only if at least one of these variables is 1.

The constraint is: $y_1 + y_3 + y_4 \ge 1$.

| $y_1$ | $y_3$ | $y_4$ | $y_1 + y_3 + y_4 \ge 1$ |
| :---: | :---: | :---: | :---: |
| 0 | 0 | 0 | $0 \not\ge 1$ |
| 0 | 0 | 1 | $1 \ge 1$ |
| 0 | 1 | 0 | $1 \ge 1$ |
| 0 | 1 | 1 | $2 \ge 1$ |
| 1 | 0 | 0 | $1 \ge 1$ |
| 1 | 0 | 1 | $2 \ge 1$ |
| 1 | 1 | 0 | $2 \ge 1$ |
| 1 | 1 | 1 | $3 \ge 1$ |

Following this example, a similar constraint could be derived for all of the bands. For instance:

* For Stratovarius: $y_1 + y_2 + y_3 + y_5 \ge 1$
* For Dalriada: $y_3 + y_5 \ge 1$
* The case of Apocalyptica is special: $y_4 \ge 1$, which basically forces $y_4$ to be 1. This is expected, as the 4th festival is the only one where Apocalyptica performs.

#### Step 3: Objective

Our objective is to go to as **few festivals as possible**—that is, to minimize the number of festivals we visit. Using the $y_n$ variables, the number of festivals we visit is simply the sum: $y_1 + y_2 + y_3 + y_4 + y_5$.

#### Finally, the Whole Model

Putting everything together:

$$\begin{align*} y_1, y_2, y_3, y_4, y_5 &\in \{0, 1\} \\ y_1 + y_3 + y_4 &\ge 1 \\ y_1 + y_2 + y_3 + y_5 &\ge 1 \\ y_1 + y_2 + y_4 + y_5 &\ge 1 \\ y_3 + y_5 &\ge 1 \\ y_4 &\ge 1 \\ y_2 + y_3 + y_4 + y_5 &\ge 1 \\ y_3 + y_5 &\ge 1 \\ y_1 + y_2 + y_3 + y_4 + y_5 &\to \min \end{align*}$$

Now, let's check if this model adheres to the rules of an LP model:

* There are a finite number of variables. **(Check)**
* The domain of each variable is a **continuous interval**. **(Not a Check)**
* There are a finite number of constraints. **(Check)**
* The left-hand side (LHS) of each constraint is a linear expression of the variables. **(Check)**
* The relation in each constraint is either $\le$, $=$, or $\ge$. **(Check)**
* The right-hand side (RHS) of each constraint is a constant. **(Check)**
* The objective function is a linear expression of the variables, that can be either maximized or minimized. **(Check)**

This is **not an LP model**, but something very similar. The only difference is that (some of) the variables take their values from a **discrete set** ($\{0, 1\}$). These types of problems are termed **Mixed-Integer Linear Programming (MILP)** problems.

In MILP models, some variables may take values from a continuous interval, while others may only take discrete values, such as integers. The most common discrete set is $\{0, 1\}$, so these variables are called **binary variables**. In our festival example, all variables are binary, and there are no other integer or continuous variables.

MILP models are generally **more computationally difficult to solve** than LP models. MILP solvers typically combine the simplex algorithm with other techniques, such as a **Branch-and-Bound (B&B) algorithm** or the **Cutting-Plane / Branch-and-Cut method**. Broadly speaking, the time required to solve a general MILP problem is an **exponential function** of the number of integer variables. This means that after a certain number of variables, the problem becomes extremely hard and practically impossible to solve to guaranteed optimality.

> **Note:** Not all MILP models are difficult to solve. If, for example, the matrix of the coefficients in the model is **totally unimodular**, the problem can be solved in polynomial time, just like an LP problem. A famous example is the **Assignment problem**, which can be solved efficiently by the Hungarian method. (The algorithm was developed by the American mathematician Harold W. Kuhn, who named it after the former works of two Hungarian mathematicians: Dénes Kőnig and Jenő Egerváry.)

***

### Final Notes

The key takeaway from this section is that certain problems can be described by **algebraic models** such as **LP** or **MILP**. If a practical problem can be adequately represented by one of these, it can be solved by well-known and highly optimized algorithms. If the problem has only linear constraints and continuous decisions (LP), it's easy to solve. It becomes significantly more troublesome with discrete (integer or binary) decisions (MILP).

