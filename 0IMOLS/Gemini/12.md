
## Under the Hood: The Branch and Bound Algorithm

### General Framework Algorithm for Solving Discrete Problems

### Prerequisites

#### Brute Force Approach and Enumeration of Feasible Solutions

We saw in the case of the **festivals example** that the brute-force approach, while likely very slow, is a valid method for finding an optimal solution when the search space is discrete and finite. We also mentioned a few ideas for acceleration, some of which could be applied more generally. Let's focus now on enumerating only the **feasible** solutions.

Enumerating all solutions was straightforward for the festivals example; traversing all subsets of a set is a simple task. We would only need to count from 0 to $2^n - 1$ and interpret the number's binary representation as a subset indicator. However, many of these subsets are infeasible, and things become a bit more complicated if we want to generate only the feasible solutions. Try to figure out an approach to do this yourself, or click the button below.

There are many ways to approach this, but a simple method would be to follow these steps:

* We either go to F1 or not.
* If we don't go to F1, we either go to F2 or not.
    * If we don't go to either F1 or F2, we can either go to F3 or not.
        * If we don't go to F1, F2, or F3, we **must** go to F4 because that's the last option for Apocalyptica and Haggard.
            * If we go to F4 but not to F1, F2, or F3, we **must** go to F5, as that is the last option for several bands.
                * We go to F4 and F5 but not to F1, F2, or F3. There are no decisions left, and we have a solution with two festivals.
        * If we don't go to F1 or F2 but **do** go to F3, we **must** go to F4 because that's the last option for Apocalyptica and Haggard.
            * If we go to F3 and F4 but not to F1 or F2, we either go to F5 or not.
                * If we go to F3 and F4 but not F1, F2, or F5, we have a solution with two festivals.
                * If we go to F3, F4, and F5 but not F1 or F2, we have a solution with three festivals.
* If we go to F2 but not to F1, we can either go to F3 or not...
* If we go to F1, we either go to F2 or not...

The approach above illustrates a **tree-style enumeration** of the feasible solutions:

* The **root** of the tree represents the case where no decisions have been made.
* The **leaves** represent solutions where all decisions have been made.
* At each **non-leaf node**, a decision is made, and all possible outcomes are "encoded" in its children.

$$
\text{No decision}
$$

$$\text{go to F1}$$
$$\dots$$

$$\text{don't go to F1}$$
$$\text{go to F2}$$
$$\dots$$

$$\text{don't go to F2}$$
$$\text{go to F3}$$

$$\text{go to F4}$$
$$\text{go to F5} \quad \text{don't go to F5}$$
$$\text{don't go to F3}$$
$$\text{go to F4}$$
$$\text{go to F5}$$

Another way to view the same tree is:

* The **root** represents the set of all feasible solutions.
* The **leaves** are single solutions, or more precisely, solution sets containing a single element.
* At each **non-leaf node**, a decision is made that divides the node's set into subsets, which become its children.

---

### The "Branch" Part

The approach described above can be generalized to any problem involving discrete decisions:

1.  Take the set of all feasible solutions and assign it to the **root node** of a tree.
2.  For each tree node whose set is not a **singleton** (a set with one element), select a decision that needs to be made. Partition the set assigned to that node such that each subset contains the solutions that result from a specific outcome of the decision. Assign these subsets to children nodes. (No children nodes are created for empty subsets.)
3.  If a node's set is a singleton, that node is a **leaf**, and the solution can be evaluated.

> Note that, in general, Branch and Bound algorithms do not require the branching step to create a **partition** (i.e., disjoint subsets); they only require creating subsets whose union covers the original set. Also, empty subsets may be represented and partitioned into further empty subsets, and singleton sets may be partitioned into empty sets and singleton sets, as reasoned below.

In practice, the sets assigned to nodes are usually not explicitly generated and partitioned. Instead, the outcomes of the former decisions are maintained, and at each node, it is somehow checked whether:

* There is at least one feasible solution consistent with the former decision outcomes.
* If yes, are there more than one solution in that set?

These checks do not need to be 100% precise; however, they must declare emptiness and singleton sets with **100 percent certainty**. This means that it is acceptable for the "emptiness" test to say, "I'm not sure," and then treat it as a non-empty set, but it must **never** declare a set empty if it is not. The same principle applies to identifying singletons.

If we already have the above branching algorithm, it can easily be extended with a minimum search on the leaves.

---

### The "Bound" Part

Let's consider a simple shortest path problem: I currently live in Győr, and my parents live in Nagykanizsa. Assume I want to drive home the shortest way possible, using only main roads (roads with one or two-digit numbers) but no highways, to avoid additional fees.

This problem can, of course, be solved efficiently to optimality by algorithms like Dijkstra's. Therefore, the approach presented here serves as an illustration rather than a recommendation for this particular problem class.

A simple way to split all feasible routes into subsets is to make a decision on the first part of my journey, which can be:

* Driving on road 1 to Mosonmagyaróvár
* Driving on road 85 to Csorna
* Driving on road 83 to Városlőd
* Driving on road 82 to Veszprém
* Driving on road 81 to Kisbér
* Driving on road 1 (in the other direction) to Komárom

A child node is created for each of these six options. For example, the fourth node represents all solutions that start with Győr–Veszprém–.... For each node, branching can be done in the same fashion. For instance, the route Győr–Veszprém can continue with:

* Driving on road 8 to Városlőd
* Driving on road 77 to Lesencetomaj
* Driving on road 73 to Csopak
* Driving on road 8 to the crossing near Litér

We do not list the option of driving road 82 back to Győr, as we are not interested in circular routes.

This can be repeated for all nodes until we reach Nagykanizsa. If a node's "partial route" ends at Nagykanizsa, it must be a leaf node, as that route is the only feasible non-circular solution with that beginning. The length of the route can be evaluated and used in the minimum search.

This approach, however, is not very efficient. Assume we have already found the following leaf node: "Győr – Veszprém – Csopak – Balatonederics – Keszthely – Fenékpuszta – Balatonszentgyörgy – Nagykanizsa" with a length of 217 km. When we find this solution, there may be other uninvestigated nodes with partial routes, such as: "Győr – Komárom – Budapest – Szolnok". If we were to blindly follow the instructions above, we would create two child nodes (branch this solution set into two) by following the direction toward either Jászberény or Törökszentmiklós.

However, we can observe that the route up to Szolnok is already 227 km long, which is longer than a feasible solution we have found so far. Thus, there is no point in finding solutions in this subtree (in the set assigned to this node), as they will definitely be worse than a previously found solution, and therefore not optimal. So, we can **prune** this node (solution subset) from the search and look for another one.

What we essentially did was provide a **lower bound** on all the solutions in that subtree (in the set assigned to the node), and if it was worse than the best solution found so far, the subtree (solution subset) was pruned. This idea can be generalized to any problem class if there is a way to provide a lower bound on a subset of solutions. A general, pseudo-code-like structure of the Branch-and-Bound framework algorithm looks like this:

1.  Set $min$ to $\infty$.
2.  Let $S=\{S\}$, where $S$ is the set of all feasible solutions.
3.  While $S$ is not empty:
    a. Select and remove an element from $S$, and denote it with $P$.
    b. If the lower bound on the solutions in $P$ is greater than $min$, then **prune** this set and continue with another set from $S$, if one exists.
    c. Otherwise:
        i. If $P$ is a **singleton**, check the value of that solution and update $min$ if it is better.
        ii. If $P$ is **not a singleton**, find a decision that can further partition it, creating $P_1, P_2, \dots$. Then, put the non-empty subsets into $S$.
4.  If $min$ is not infinity, it holds an optimal solution; otherwise, there is no feasible solution.

> Note that this is a framework algorithm that can be used for many problem classes, where the details have to be specified, e.g.:
>
> * How is $P$ selected (i.e., what is the rule for selecting the next uninvestigated node in the tree)?
> * Which decision is selected for a node?
> * How does the bound function work?
> * How can we decide if $P$ is a singleton or empty?

For example, we used the length of the "already traveled path" as the lower bound and created branches based on the next segment in the path.

If the problem is a **maximization** problem, we need an **upper bound**, and $P$ is pruned if its bound is lower than the best solution found so far ($max$ in that case). Furthermore, bounding functions are usually required to return the exact value of the solution contained in a singleton. If this is known about the bounding function, then no further condition is needed to update $min$ if $P$ is a singleton and its bound has already been proven to be below $min$.

---

### Note about Bounding Functions

The **"tightness"** of a bounding function can be the most important contributor to an algorithm's efficiency. If the bound is not tight (i.e., the bound is far from the actual value of the best solution in $P$), then pruning will only happen deeper in the tree, and a subtree is investigated unnecessarily. To understand this, let's return to our pruned path, "Győr – Komárom – Budapest – Szolnok." The parent of this node was "Győr – Komárom – Budapest," and it has seven siblings. The bound of the parent is 126 km, which is far below the 217 km solution we found earlier, so all eight child nodes are generated. If we look at the map, we can intuitively see that this is truly the wrong direction to go, as Budapest is east of Győr, while Nagykanizsa is to the southwest. This means that just by looking at the map, we know that none of the solutions in this subtree (in the set assigned to "Győr – Komárom – Budapest") will be better than the one we have already found. Still, we need to generate the children and, in some cases, the grandchildren to prove it because our bound is not tight enough.

Our previous bound did not include any information about the distance still to be traveled from the end of the current path. However, it is not difficult to provide a lower bound for that either. We should simply add the geographical (straight-line) distance between the end of the current path and Nagykanizsa. For the "Győr – Komárom – Budapest" node, this Budapest–Nagykanizsa distance is 190 km. Adding the two together: $126 + 190 = 316 \text{ km}$, which is still a valid lower bound, as any "ending" of that path will be longer than 190 km. $316 \text{ km}$ is far over 227 km, so with this **tighter bound**, we can prune the "Győr – Komárom – Budapest" node and will not have to spend time generating and evaluating its children and grandchildren.

> Note that we can only prune "Győr – Komárom – Budapest" if we already have a solution better than 316 km. Thus, the strategy for exploring the nodes in the tree can be just as important as a tight bound.

It seems that we should always strive for tighter and tighter bounds to keep the B&B tree as small as possible. However, tighter bounds often require more complex calculations. A slightly tighter bound may not prune enough nodes to make up for the additional time spent calculating that complex bound at each node. Selecting the best-performing bound is not a trivial task and is often done on a statistical basis.

---

### Final Notes

The purpose of this lecture is to provide a brief insight into how the discrete part of an optimization problem is often handled by a solver.

 