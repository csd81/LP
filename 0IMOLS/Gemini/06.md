


## Advanced GMPL Techniques: Data/Logic Decoupling

### Introduction

Introducing the use of **sets** and **parameters** in **GMPL** to separate **data** from the **logic** of a model.

-----

### Prerequisites

  * GMPL model of motivational examples

### Our Previous "Good" Model Is Actually Bad

The models we've created so far are correct—there's no mistake about that. However, when building a mathematical model, we should consider how **"manageable"** the code will be in the future. Similar to computer programming, there's a huge difference between code that simply works and code that is easy to use if later modifications are needed.

Let's look at the festival model again:

```
var y1 binary;
var y2 binary;
var y3 binary;
var y4 binary;
var y5 binary;

s.t. Haggard: y1 + y3 + y4 >= 1;
s.t. Stratovarius: y1 + y2 + y3 + y5 >= 1;
s.t. Epica: y1 + y2 + y4 + y5 >= 1;
s.t. Dalriada: y3 + y4 >= 1;
s.t. Apocalyptica: y4 >= 1;
s.t. Liva: y2 + y3 + y4 +y5 >= 1;
s.t. Eluveitie: y3 + y5 >= 1;

minimize NumberOfFestivals: y1 + y2 + y3 + y4 + y5;
```

We use our model, plan our summer, and everything is fine. Then, a new festival **F6** is announced, where Haggard, Epica, and Apocalyptica will perform. What kind of changes would be needed for the model?

1.  A new variable, `y6`, will be needed.
2.  In the constraints for Haggard, Epica, and Apocalyptica, an additional `+y6` needs to be added.
3.  The objective function also needs an additional `+y6`.

This is a lot of changes, spread across different parts of our code. It's still more or less manageable. Now imagine that we want to use our model a year later for the next summer as well. Our favorite bands may have changed, and although the set of interesting festivals might remain the same, their list of bands will definitely change. We could, obviously, build a similar model using the same logic, but we feel like we'd be doing something unnecessarily repetitive. This repetition, let's call it **redundancy**, is rarely a sign of quality code.

What we're noticing here is that two things in our model are **"intertwined"** in the same file:

1.  **Logic:** The "soul" of our model. What decisions must be made, how are they represented with variables, what constraints are defined on them, what is our goal, etc.
2.  **Data:** The "physical body" of our model. Which festivals we have, which bands we like, and where they perform.

The model's logic remains the same regardless of the actual data, and as such, it should be separated from it. This is similar to programming, where we don't want to embed our database directly into our source code. Besides redundancy, it's really easy to make **semantic mistakes** when changing the data can also alter the model's logic. (Imagine substituting a minus sign for a plus sign somewhere, or writing `y23` instead of `y32`. It would be very difficult to debug and find this kind of mistake in a larger model.) GMPL allows this kind of code separation into **model** and **data** sections (or even files), but let's briefly return to the mathematical realm of optimization.

-----

### Problems, Problem Classes, and Instances

Looking at the same thing from a different perspective: if we have a model for this year's festivals, another one for next year's festivals, and a third for the *fröccs* example, we would know that the first two are **"similar"** and the third is **"different."** We might even say that the first two models are of the **same type, but different instances.** But how can we define when two models are similar or different? What is the exact dividing factor?

After the introduction in the previous section, it's easy to see that the first two models share the same **logic** but have different **data**, while the third one has a completely different model as well. In practice, it is very common to have many instances of problems with the same logic but different data. For example: planning a factory's schedule for the next week is always a similar task, but each week has a different set of products, deadlines, initial resource stocks, etc.

As a result, we are usually more interested in providing a **general solution** for a **type of problem**, not just a single instance. On this page, we will use the term **Problem Class** to denote the set of all problems that are of the same type, i.e., they share the same logic. The problem class itself has no data, but it has **"features"** that are shared among all of its members. Each element of a problem class is termed a **Problem Instance**, which already includes the data.

We will generally want to provide **generic models** (model logic) for a problem class rather than an instance, so that it can be used for all instances in that class. In that sense, a generic model can be considered a **"recipe"** which can be used to generate a complete model once the data is provided for it. But let's have a hands-on experience now.

-----

### Generic Mathematical Model for the Festivals Example

To create our generic model, we need to strip away the instance-specific data and describe it in a generic manner:

  * There will be five festivals this summer; this is problem-specific data. In general, we could say that there will be a **set of festivals**, which we could denote with $F$.
  * We are interested in the bands Haggard, Stratovarius, etc. That is, again, something very specific—your music taste is probably different from mine. In general, we could say that there is a **set of interesting bands**, which we could denote with $B$.
  * Finally, we know that Haggard will perform at festivals 1, 3, and 4. In general, we could say that for each band, we have a **subset of festivals** where it will perform, which we may denote by $F_b$ for each $b \in B$. While this is true, having a set of sets is a bit complex. A simpler way to look at it would be to have a **parameter** that describes whether a band $b \in B$ performs at a festival $f \in F$, which could be denoted by $p_{b,f}$. Either way is fine.

> **Note:** If something needs to be defined for all values from a set, but will only have a value in a problem instance, we place a dummy index in the **subscript** of that something. A subscript is like a key for an associative array in programming languages. In contrast, when we use **superscripts**, it will be part of the variable's name, not an index.

Now, we have a generic problem definition: Given a set of bands $B$, a set of festivals $F$, and a subset of festivals $F_b \subseteq F$ for all $b \in B$, we should find a **minimal set of festivals** $F^*$ such that each $F_b$ has at least one element in it.

To create our model, we just have to follow the previously learned three steps, only doing it in a general way:

**Step 1: Variables**
We still have to make the same decision: whether we go to a festival or not. We don't know how many festivals there will be in a problem instance, but we can say that we will declare a **binary variable $y_f$ for all of them** (for all $f \in F$).

**Step 2: Constraints**
We should have a **constraint for all of the bands $b \in B$**, and in the constraints, we should **sum up the variables $y_f$ with $f \in F_b$**, and that sum should be **greater than or equal to 1**. Note that we already have a value for $b$ if we are writing a specific constraint.

**Step 3: Objective Function**
The objective function is simple: **sum all the variables, and that should be minimal.**

Putting all of these together, we have:

$$y_f \in \{0, 1\} \quad \forall f \in F$$
$$\sum_{f \in F_b} y_f \ge 1 \quad \forall b \in B$$
$$\sum_{f \in F} y_f \to \min$$

Or, if you prefer to use the parameter $p_{b,f}$ instead of the sets $F_b$, where we assume that $p_{b,f} = 1$ if band $b$ performs at festival $f$, and $0$ otherwise, then:

$$y_f \in \{0, 1\} \quad \forall f \in F$$
$$\sum_{f \in F} p_{b,f} \cdot y_f \ge 1 \quad \forall b \in B$$
$$\sum_{f \in F} y_f \to \min$$

> **Note:** In this version, the constraint is a bit different. Here, the sum goes over all of the festivals. However, the variables for festivals where band $b$ does not perform are multiplied by $0$, and all the others are multiplied by $1$, so the constraints will be the same. For example, instead of $y_1 + y_3 + y_4 \ge 1$, it will be $1 \cdot y_1 + 0 \cdot y_2 + 1 \cdot y_3 + 1 \cdot y_4 + 0 \cdot y_5 \ge 1$.

To keep things simpler, we will focus on the second model below.

-----

### Generic GMPL Models

GMPL (and most modern modeling languages) support this generic model definition. The previous structure for our GMPL model was this:

1.  Variable declarations
2.  Constraint definitions
3.  Objective function definition

To achieve the desired separation, the model file must have this structure:

```
Model logic / Generic model
data; keyword
Model data
end; keywords
```

> **Note:** The absence of the `end;` keyword also resulted in a warning in our previous models. We will talk a bit later about the data section; let's focus on the generic model first, which usually follows this template:

1.  Generic set and parameter definitions
2.  Generic Variable declarations
3.  Generic Constraint definitions
4.  Generic Objective function definition

**Sets** and **parameters** can be declared with the `set` and `param` keywords, respectively. If a set, parameter, or variable has a subscript/index, the name should be followed by the declaration: `{Setname}`, where `Setname` is the domain on which that set, parameter, or variable is defined. When using this set, variable, or parameter, the index should be put within brackets after the name. If there are multiple indices, they should be separated by commas in both the definition and when used. If we want a constraint to be defined for each element of a set, a `{s in Setname}` should be put after the name of the constraint, where `Setname` is the name of the set, and `s` is a dummy index that can be used within the constraint. The syntax for the sum symbol is similar.

Let's see how this looks for our second model with the $p_{b,f}$ parameter:

| Mathematical Notation | GMPL Code |
| :---: | :--- |
| **Sets and Parameters** | |
| $F$ | `set F;` |
| $B$ | `set B;` |
| $p_{b,f}$ | `param p{B,F};` |
| **Variables** | |
| $y_f \in \{0, 1\} \quad \forall f \in F$ | `var y{F} binary;` |
| **Constraints** | |
| $\sum_{f \in F} p_{b,f} \cdot y_f \ge 1 \quad \forall b \in B$ | `s.t. Constraints{b in B}: sum{f in F} p[b,f]*y[f] >= 1;` |
| **Objective Function** | |
| $\sum_{f \in F} y_f \to \min$ | `minimize Objective: sum{f in F} y[f];` |

So, all in all, our model is something like this:

```
    set B;
    set F;
    param p{B,F};

    var y{F} binary;

    s.t. Constraints{b in B}:
      sum{f in F} p[b,f]*y[f] >= 1;

    minimize Objective:
      sum{f in F} y[f];
```

But we've already learned that it's always good practice to use **meaningful names**. So, before we dive into the data section, let's refactor our model to this:

```
set Bands;
set Festivals;

param performs{Bands,Festivals} binary;

var go{Festivals} binary;

s.t. ListenToAllBandsAtLeastOnce {b in Bands}:
  sum{f in Festivals} performs[b,f] * go[f] >= 1;

minimize FestivalsWentTo:
  sum{f in Festivals} go[f];
```

If we were to "run" this model with the usual `glspsol -m model.mod` command, we would receive an error message something like this: **Missing value for S**. That's because the data section is still missing.

### The Data Section

The data section gives values for **sets** and **parameters**. Many syntax variations can be used here, so reading the GMPL reference is highly recommended. We only mention the four simplest cases here:

```
    # Set definition
    set Setname := element1 element2 element3;
    set Setname2 :=  element anotherelement;

    # Definition of parameter with 0 subscripts/indices/dimensions:
    # E.g., for declaration param Paramname0;
    param Paramname0 := numericvalue;

    # Definition of parameter with 1 subscript/index/dimension:
    # E.g., for declaration param Paramname1{Setname};
    param Paramname :=
      element3  numericvalue
      element2  numericvalue
      element1  numericvalue
      ;

    # Definition of parameter with 2 subscripts/indices/dimensions:
    # E.g., for declaration param Paramname2{Setname,Setname2}
    param Paramname :
                element         anotherelement :=
      element1  numericvalue    numericvalue
      element3  numericvalue    numericvalue
      element2  numericvalue    numericvalue
      ;
```

> **Note:** The order in which the elements of a set are listed in the parameter definitions is irrelevant. Also, sets can have numeric elements, and parameters can be symbolic too, but we will discuss such things in more advanced models.

For now, let's write our data section with the syntax above:

```
set Bands :=
  Haggard
  Stratovarius
  Epica
  Dalriada
  Apocalyptica
  Liva
  Eluveitie
  ;

set Festivals := F1 F2 F3 F4 F5;

param performs:
                  F1  F2  F3  F4  F5 :=
    Haggard       1   0   1   1   0
    Stratovarius  1   1   1   0   1
    Epica         1   1   0   1   1
    Dalriada      0   0   1   0   1
    Apocalyptica  0   0   0   1   0
    Liva          0   1   1   1   1
    Eluveitie     0   0   1   0   1
    ;
```

> **Note:** In the definition of the set `Bands`, the elements are given on new lines. This is fine; GMPL does not care about the number and type of whitespace characters (spaces, tabs, new lines). So, if your model is more readable this way, feel free to add extra newlines or spaces. Similarly, a 1-dimensional parameter could be defined like this as well:
>
> `param Param1:= element1 value1 element3 value3 element2 value2;`

-----

### Solve the New Model

We're almost done; we just have to copy these two parts of code into a single file and separate them with `data;`. While that's fine (and you should definitely try it), a better way is to put the **model part into a `festival.mod`** and the **data part into a `SummerOf18.dat`**. Then run the following command:

`glpsol -m Festival.mod -d SummerOf18.dat -o FestivalsSummer18.out`

The solver provides similar information to the standard output as before, but let's look at the solution file:

```
Problem:    festival
Rows:       8
Columns:    5
Non-zeros:  25
Status:     OPTIMAL
Objective:  FestivalsWentTo = 2 (MINimum)

   No.   Row name   St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 ListenToAllBandsAtLeastOnce[Haggard]
                    B              2             1               
     2 ListenToAllBandsAtLeastOnce[Stratovarius]
                    NL             1             1                           1 
     3 ListenToAllBandsAtLeastOnce[Epica]
                    B              1             1               
     4 ListenToAllBandsAtLeastOnce[Dalriada]
                    B              1             1               
     5 ListenToAllBandsAtLeastOnce[Apocalyptica]
                    NL             1             1                           1 
     6 ListenToAllBandsAtLeastOnce[Liva]
                    B              2             1               
     7 ListenToAllBandsAtLeastOnce[Eluveitie]
                    B              1             1               
     8 FestivalsWentTo
                    B              2                             

   No. Column name  St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 go[F1]       NF             0                                     < eps
     2 go[F2]       NF             0                                     < eps
     3 go[F3]       B              1                             
     4 go[F4]       B              1                             
     5 go[F5]       NF             0                                     < eps

Karush-Kuhn-Tucker optimality conditions:

KKT.PE: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

KKT.PB: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

KKT.DE: max.abs.err = 0.00e+00 on column 0
        max.rel.err = 0.00e+00 on column 0
        High quality

KKT.DB: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

End of output
```

From the first table, we can see that the constraints were indeed generated separately for all of the bands, and from the second table, that the `go` variables were generated for all of the festivals. Also, we get the same optimal solution of going to **F3 and F4 only**.

Later on, we will learn some other GMPL features with which we can fine-tune this model to be better, but for now, we have all the tools needed to build more complex models.

-----

### Final Notes

Putting the **logic** and the **data** in one place is never a good idea, and mathematical modeling is no exception. **GMPL** allows us to separate these elements by abstracting the data into **sets** and **parameters**, declaring them in the **generic model**, and defining their specific values in a **separate data file**.

