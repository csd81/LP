## ðŸŽµ Motivational Example: Festivals

A discrete decision problem used to discuss basic concepts and principles of **optimization**.

### Problem Description

Who doesn't love music and want to see their favorite bands live at summer festivals? In this example, that is exactly what we aim to do while saving as much money as possible. First, fill in the fields with the names of your favorite bands and performers, or simply leave my selection in place.

-----

Now, let's assume there are five festivals we have the chance to attend over the summer. For simplicity, these festivals will be called $F1, F2,$ etc. Below is a table detailing which band will perform at which festival:

| | $F1$ | $F2$ | $F3$ | $F4$ | $F5$ |
| :--- | :--- | :--- | :--- | :--- | :--- |
| Haggard | $\checkmark$ | $\checkmark$ | $\checkmark$ | | |
| Stratovarius | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$ | |
| Epica | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$ | |
| Dalriada | | $\checkmark$ | $\checkmark$ | | |
| Apocalyptica | | | | $\checkmark$ | |
| Liva | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$ | |
| Eluveitie | $\checkmark$ | $\checkmark$ | | | |

Let's suppose for now that the ticket for each festival costs the same, and we want to **minimize the money we spend** during the summer while seeing **every one of our favorite bands at least once**.

### Solving the Problem Manually

A problem of this size is easy to solve in a few minutes using a **trial-and-error** approach without any software tool. Try it yourself before checking the solution below.

It appears that going to only festivals $F3$ and $F4$ is the best solution. But how can we be sure that this is truly the **optimal** solution? A reasonable argument would be that our solution involves selecting 2 festivals. If this isn't the best solution, then the optimal solution must involve selecting at most 1 festival. By checking all 5 festivals, it is easy to see that none of them covers all of our favorite bands.

> **Note:** This logic would be much more complex to execute if we had a larger problemâ€”say, 30 bands and 50 festivals. If our presumably optimal solution involved 9 selected festivals, all of the 8-element subsets of the 50 festivals would have to be checked. That is a quite large number: $$\binom{50}{8} = 536,878,650$$

Now that we are assured that $\{F3, F4\}$ is optimal, another question may arise: Is this the **only** optimal solution?

It is quite easy to see that $\{F4, F5\}$ is also a **feasible** solution with 2 festivals. Thus, let's note that:

> A problem may have one or more optimal solutions simultaneously.

### What About a Larger Festival Problem?

A problem of this size can be handled effortlessly by hand; however, as the number of bands and festivals increases, it becomes less and less manageable. Imagine a problem with 30 bands and 50 festivals. If the "performing matrix" is not trivial, solving the problem will definitely require some sort of computer assistance.

Even if you have no background in optimization but possess basic programming skills, you should be able to write a computer program to solve this problem in your favorite language. Try to develop the algorithm yourself before proceeding.

The first thing to observe is that the flexibility we have is a **yes-or-no** type of decision for each of the 50 festivals. This basically gives us $2^{50}$ different **solutions**.

Some of these solutions satisfy the problem's constraints (i.e., all bands are seen), and others do not. Solutions in the former group are often called **good** or **feasible** solutions, while the others are called **bad** or **infeasible**.

In the case of the matrix above, selecting $\{F1, F3, F4\}$ is a feasible solution, while $\{F1, F3\}$ is infeasible, as we would miss Apocalyptica. Below is the complete list of the 32 subsets and whether they are feasible or not.

| | | | | |
| :--- | :--- | :--- | :--- | :--- |
| none | $F1$ | $F2$ | $F2, F1$ | $F3$ |
| $F3, F1$ | $F3, F2$ | $F3, F2, F1$ | $F4$ | $F4, F1$ |
| $F4, F2$ | $F4, F2, F1$ | $F4, F3$ | $F4, F3, F1$ | $F4, F3, F2$ |
| $F4, F3, F2, F1$ | $F5$ | $F5, F1$ | $F5, F2$ | $F5, F2, F1$ |
| $F5, F3$ | $F5, F3, F1$ | $F5, F3, F2$ | $F5, F3, F2, F1$ | $F5, F4$ |
| $F5, F4, F1$ | $F5, F4, F2$ | $F5, F4, F2, F1$ | $F5, F4, F3$ | $F5, F4, F3, F1$ |
| $F5, F4, F3, F2$ | $F5, F4, F3, F2, F1$ | | | |

If we already have the set of **finite** solutions, we just have to select the smallest one from the feasible solutions. For example:

```
S = generate_solutions();
min = infinity
for(s in S) {
  if (feasible(s)){
    if (value(s)<min) {
      min = value(s);
    }
  }
}
```

Or, if you prefer a functional programming style:
`(min (filter (generate_solutions) feasible) value)`

### Accelerating the Solution Procedure

Let's assume that we implemented the above algorithm in the most efficient way possible. It is fair to say that evaluating a single solution takes at least as much time as a floating-point operation. As of today, the fastest supercomputer is the **Summit** with $200$ petaflops of computational power. That would mean that even this computer could not investigate more than around $10^{17}$ solutions in a second. With the aforementioned problem having 50 festivals, the entire computation would take more than $2^{50} / 10^{17}$ seconds. Since $2^{10} \approx 10^3$, that would mean $10$ milliseconds. That may seem acceptable for an average computer, but not for the fastest supercomputer of our time. Moreover, if the problem size increased to, say, 100, even this computer would need more than $300$ thousand years. It is clear that if we want to tackle this type of problem with "practical" sizes in a reasonable amount of time, some **accelerations** are needed.

#### Idea 1: Use the Greedy Algorithm

A reasonable intuition suggests that festivals featuring many bands should be prioritized and selected. A simple algorithm could be built upon this idea:

1.  **Select** and **include** a festival with the most bands.
2.  **Remove** the bands covered by the selected festival.
3.  If there is at least one performer left, go to **Step 1**.

Applying this procedure to the original problem, it would first select either $F3, F4,$ or $F5$, as all three cover 5 bands. This ambiguity should be resolved somehow within the algorithm; we will always select the leftmost festival. So, $F3$ is selected, and then *Haggard, Stratovarius, Dalriada, Liva, Eluveitie* are removed from the list, and the table is reduced to the following:

| | $F1$ | $F2$ | $F4$ | $F5$ |
| :--- | :--- | :--- | :--- | :--- |
| Epica | $\checkmark$ | $\checkmark$ | $\checkmark$ | $\checkmark$ |
| Apocalyptica | | | $\checkmark$ | |

Since two bands are still left, the algorithm continues with the festival covering the most remaining bands, which is $F4$. Selecting $F4$ will cover all of the bands, and we end up with the solution of $\{F3, F4\}$.

For this particular example, this so-called **Greedy algorithm** provided the optimal solution. For some problem classes, optimality can be guaranteed this way; however, this problem is not one of them. It is not difficult to create an instance where this algorithm would provide a **sub-optimal** solution. Try to construct such an example yourself.

| | $F1$ | $F2$ | $F3$ |
| :--- | :--- | :--- | :--- |
| Haggard | $\checkmark$ | | $\checkmark$ |
| Stratovarius | $\checkmark$ | | $\checkmark$ |
| Epica | $\checkmark$ | | $\checkmark$ |
| Dalriada | $\checkmark$ | | $\checkmark$ |
| Apocalyptica | $\checkmark$ | | |
| Liva | | $\checkmark$ | $\checkmark$ |

It is easy to see that the optimal solution is $\{F1, F2\}$; however, the greedy algorithm would select $F3$ first and then include the other two.

The greedy algorithm can be considered a **heuristic approach** for this problem class, as it provides a (most probably) reasonably good solution very quickly. However, it cannot guarantee the optimality of the solution (even if it happens to be optimal).

#### Idea 2: Make Inevitable Decisions Right Away

Looking at the original problem, it is very obvious that Apocalyptica is a rather **picky** band, as they only perform at $F4$. Hence, $F4$ **must** be on our festival list, no matter what. This decision can be made with 100% certainty without sacrificing optimality.

Another less obvious observation is that $F2$ is **inferior** to $F5$, as it only covers a **subset** of the bands covered by $F5$. Even if there is an optimal solution that includes $F2$, another optimal solution must exist where $F5$ is selected instead of $F2$. Thus, we can disregard $F2$ right from the beginning and reduce the size of the problem.

These kinds of simplifications are often implemented as a **presolve** procedure in modern optimization software tools. In the best case, they can solve the problem; in the worst case, the problem remains unaltered.

These simple tricks can usually be applied recursively. Note that $F3$ does not dominate $F1$ in the same way that $F5$ dominated $F2$, because Epica performs at $F1$ but not at $F3$. However, if $F4$ is selected because of Apocalyptica, then Epica becomes irrelevant, as we will see them there anyway. Thus, after selecting $F4$, $F1$ becomes inferior to $F3$ and can therefore be disregarded. Similarly, $F3$ and $F5$ will become equivalent after including $F4$, so one of them can be disregarded.

For this specific problem instance, these two simple presolve techniques can solve the problem to optimality.

#### Idea 3: Investigate Only Feasible Solutions

For this particular problem, half of the solutions were infeasible (see above). This means that we are wasting computational time on many infeasible solutions that definitely will not end up being optimal. This ratio is usually much higher for real-world problems, so it is a good idea to somehow come up with an approach that generates **only the feasible solutions**.

Investigating this is not our main goal here, so such an algorithm is not presented. However, you should be able to construct such an algorithm and implement it in your language of choice.

#### Idea 4: Select the Order of the Solutions

Since we are only interested in the **smallest feasible subset** of festivals, it would be reasonable to design our algorithm in a way that it iterates through the singleton sets first, then the 2-element subsets, and so on. Thus, if a feasible solution is found, it can be crowned as the optimal one, and the algorithm could stop.

Unfortunately, the "best" search algorithm or subproblem selection approach can vary from one problem class to another. In this particular problem class, if all of the festivals are needed, then this algorithm would go through all of the solutions anyway.

### Final Notes

This problem class is called the **Set Covering Problem**, which was dressed up in this festival-band theme. This problem class is known to be **NP-Complete**. This means that, unless $P=NP$, no "fast" algorithm can be expected to solve it for larger instances.