## GMPL/GLPK Fundamentals

An overview of tools and languages for **(Mixed-Integer) Linear Programming ((MI)LP)** problems, with an introduction to **GLPK** and **GMPL**.

-----

### Prerequisites

  * **Linear Programming:** Initial steps.

-----

### (MI)LP Description Languages and Solvers

Because MILP and LP models are widely used in practice, the algorithms for solving them are already well-implemented. Therefore, there's no need to implement the simplex algorithm ourselves. Frankly, it's best not to, unless it's strictly for coding practice. State-of-the-art solvers are quite complex, and they address small but significant details (such as floating-point rounding) that are essential for producing a stable solver. Even if you manage that, the result won't come close to the efficiency of the solvers listed below. These solvers utilize many theoretical accelerations (e.g., **LU decomposition**), implementation "tricks" (e.g., **Sparse representation**), and numerous heuristic accelerations.

There are several options for solving MILP/LP problems. A selective list, along with some information about them, is provided below.

| Solver | License | Problem Classes |
| :--- | :--- | :--- |
| **lp\_solve** | LGPL | MILP |
| **GLPK** | GPL | MILP |
| **COIN-OR CLP** | EPL | LP |
| **COIN-OR CBC** | EPL | MILP |
| **Gurobi** | Proprietary - Gurobi Optimization | MIQP |
| **CPLEX** | Proprietary - IBM | MIQP |
| **LINGO** | Proprietary - Lindo systems inc. | MILP, MINLP |

As this list shows, there are many options to choose from, and even more exist.

Regarding **performance**, the proprietary tools significantly **outperform** the open-source alternatives. Among the open-source solutions, the **COIN-OR** project is generally considered the fastest. Ultimately, the situation dictates which one you should use. For example, I use (or would use):

  * The standalone solver of **GLPK** for **teaching purposes**, as it's very simple to install/use and is freely available.
  * The API of **COIN-OR** in **scientific software** that needs to solve MILP problems as subproblems.
  * **Gurobi/CPLEX** and **COIN-OR CBC** for **comparison purposes** in scientific papers.
  * **Gurobi/CPLEX** in an **industrial environment** where efficiency is key.

These are, of course, just my recommendations, and every situation is different. Note that **academic licenses** are also available for the proprietary tools.

Once the solver is selected, you can either use its **API** from your code or use the **standalone solver** with a **model file**. Different tools support APIs for various languages, but let's focus on the second option for now. There is a wide variety of languages for describing MILP models, and tools usually support several of them. The table below shows some examples.

| Format Name | Usual Extension | Description, Notes |
| :--- | :--- | :--- |
| **AMPL** | .mod .dat .run | A Mathematical Programming Language. Very general, multipurpose, and widely used. |
| **GMPL** | .mod .dat | **GNU Mathematical Programming Language**. A subset of AMPL and the default for GLPK. |
| **MPS** | .mod .dat | Mathematical Programming System. An old format, which most solvers support as a legacy option. |
| **GAMS** | TODO | General Algebraic Modeling System. A file format, an interpreter, an IDE, and an API for solvers. |
| **CPLEX** | .lp | The default format for CPLEX, widely accepted by other solvers. |
| **Lingo** | .lng | The format used exclusively by LINGO. |

Below, you can see the same example in a few different formats for comparison.

| Mathematical Model | MPS (fixed) | MPS (free) | CPLEX | GMPL | Lingo |
| :--- | :--- | :--- | :--- | :--- | :--- |
| $\text{var } x \ge 0;$ | | | | $\text{var } x\ge 0;$ | $\text{var } x\ge 0;$ |
| $\text{var } y \ge 0;$ | | | | $\text{var } y\ge 0;$ | $\text{var } y\ge 0;$ |
| $\text{s.t. Constraint1:}$ | | | | $\text{s.t. Constraint1:}$ | $\text{s.t. Constraint1:}$ |
| $\quad x + 2y \le 15;$ | | | | $\quad x + 2*y \le 15;$ | $\quad x + 2*y \le 15;$ |
| $\text{s.t. Constraint2:}$ | | | | $\text{s.t. Constraint2:}$ | $\text{s.t. Constraint2:}$ |
| $\quad 3x + y \le 20;$ | | | | $\quad 3*x + y \le 20;$ | $\quad 3*x + y \le 20;$ |
| $\text{maximize Objective:}$ | | | | $\text{maximize Objective:}$ | $\text{maximize Objective:}$ |
| $\quad x+y;$ | | | | $\quad x+y;$ | $\quad x+y;$ |

On this site, we will use the **GMPL** file format and the **glpsol** solver to solve our problems. Please note that if you need your model in a different format, you can also use `glpsol` to convert it using the `--wmps`, `--wfreemps`, or `--wlp` options.

-----

### GMPL Basics

As previously discussed, the model can be partitioned into three parts: **variable declarations**, **constraints**, and the **objective function**. We will introduce the basic syntactic elements of GMPL following this order. A detailed reference for the GMPL format is available if you download the package from the GLPK website.

#### Variables

Variables are defined using the **`var`** keyword, followed by the **name** of the variable, **restrictions on the domain**, and finally a **semicolon** (`;`).

| Mathematical Notation | GMPL Code |
| :--- | :--- |
| $x \in [0, \infty[$ | `var x>=0;` |
| $x \in [0, 8]$ | `var x>=0,<=8;` |
| $y \in \{0, 1\}$ | `var y binary;` |
| $y \in \mathbb{Z}$ | `var y integer;` |
| $y \in \mathbb{N}$ (Non-negative integers) | `var y integer >=0;` |

#### Constraints

Constraints are written in the form:
`s.t. CNAME: LHS OP RHS;`
where:

  * **`s.t.`** stands for "subject to."
  * **`CNAME`** is a descriptive name for the constraint.
  * **`LHS`** and **`RHS`** are the left- and right-hand sides of the inequality/equation, respectively.
  * **`OP`** is a comparison operator: **`<=`**, **`>=`**, or **`=`**.

The constraint name is for human readability and maintainability; it holds no importance for the solver. Be sure to note the **colon** (`:`) separating the name and the constraint, and the **semicolon** (`;`) closing the statement.

| Mathematical Notation | GMPL Code |
| :--- | :--- |
| $x_1 + x_2 \le 10$ | `s.t. SumBound: x1+x2 <= 10;` |
| $y_1 + y_2 + y_3 + y_5 \ge 1$ | `s.t. Stratovarius: y1+y2+y3+y5 >= 1;` |
| $1 \cdot x_{KF} + 2 \cdot x_{NF} + 1 \cdot x_{HL} = 1000$ | `s.t. UseUpAllTheWine: 1*xKF+2*xNF+1*xHL = 1000;` |

#### Objective Function

The syntax for the objective function is very similar to that of the constraint:
`[minimize|maximize] ONAME: EXPRESSION;`
where:

  * You must specify either **`minimize`** or **`maximize`**.
  * **`ONAME`** is a name assigned to the objective function.
  * **`EXPRESSION`** is the linear expression for the objective.

Again, note the **colon** (`:`) and the **semicolon** (`;`).

| Mathematical Notation | GMPL Code |
| :--- | :--- |
| $y_1 + y_2 + y_3 + y_4 + y_5 \to \min$ | `minimize VisitedFestivals: y1+y2+y3+y4+y5;` |
| $110 \cdot x_{KF} + 200 \cdot x_{NF} + 120 \cdot x_{HL} \to \max$ | `maximize TotalIncome: 110*xKF+200*xNF+120*xHL;` |

> **Tip:** If your model has perfect syntax, intentionally introduce errors in every way you can think of and examine the compiler error messages. Sometimes they don't provide many clues, but this way you can build a connection between the seemingly unrelated error message and the type of problem.

We are now ready to solve our motivational examples, but first, let's see how we can make the solver find the optimal solution for the models we implement in GMPL.

-----

### Using GLPK

The examples here assume you run `glpsol` from the **command line**.

If you use **GUSEK on Windows**, two things are important:

  * Always save your model with the **`.mod`** extension; otherwise, the editor won't recognize it as a GMPL file.
  * Before clicking on **Go** or pressing **F5**, be sure to check the **"Generate output file on go"** option in the **Tools** menu.

The basic command to solve a file is:
`glpsol -m model.m -o output.txt`
This command will **read** the model from `model.m`, **write** the results to `output.txt`, and display some info on the standard output while running.

If you run the above command on the simple example used earlier to demonstrate the different file formats, you will get this in the terminal:

```bash
bash$ glpsol -m helloworld.m -o output.txt
GLPSOL: GLPK LP/MIP Solver, v4.57
Parameter(s) specified in the command line:
 -m helloworld.m -o output.txt
Reading model section from helloworld.m...
helloworld.m:10: warning: unexpected end of file; missing end statement inserted
10 lines were read
Generating Constraint1...
Generating Constraint2...
Generating Objective...
Model has been successfully generated
GLPK Simplex Optimizer, v4.57
3 rows, 2 columns, 6 non-zeros
Preprocessing...
2 rows, 2 columns, 4 non-zeros
Scaling...
 A: min|aij| =  1.000e+00  max|aij| =  3.000e+00  ratio =  3.000e+00
Problem data seem to be well scaled
Constructing initial basis...
Size of triangular part is 2
* 0: obj =  -0.000000000e+00 inf =   0.000e+00 (2)
* 2: obj =   1.000000000e+01 inf =   0.000e+00 (0)
OPTIMAL LP SOLUTION FOUND
Time used:   0.0 secs
Memory used: 0.1 Mb (102269 bytes)
Writing basic solution to 'output.txt'...
bash$ 
```

There are many familiar-sounding terms here, like "Preprocessing," but for now, we will focus only on the line in all capital letters: **`OPTIMAL LP SOLUTION FOUND`**. This line indicates that the problem has been solved to **optimality**. For MILP models, the message would be slightly different: **`INTEGER OPTIMAL SOLUTION FOUND`**. If you see other messages indicating that **no feasible solution** was found or the solution is **unbounded**, you have probably **over- or underconstrained** the problem, respectively. More on that later; let's see what's in the generated `output.txt` file.

```
Problem:    helloworld
Rows:       3
Columns:    2
Non-zeros:  6
Status:     OPTIMAL
Objective:  Objective = 10 (MAXimum)

   No.   Row name   St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 Constraint1  NU            15                          15           0.4 
     2 Constraint2  NU            20                          20           0.2 
     3 Objective    B             10                             

   No. Column name  St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 x            B              5             0               
     2 y            B              5             0               

Karush-Kuhn-Tucker optimality conditions:

KKT.PE: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

KKT.PB: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

KKT.DE: max.abs.err = 0.00e+00 on column 0
        max.rel.err = 0.00e+00 on column 0
        High quality

KKT.DB: max.abs.err = 0.00e+00 on row 0
        max.rel.err = 0.00e+00 on row 0
        High quality

End of output
```

Again, there is plenty of information here, but we'll only need specific lines for now.

1.  First, the fifth line, **`Status: OPTIMAL`**, confirms that everything went well and an optimal solution was found.
2.  The line below that tells us what the optimal solution is: **`Objective: Objective = 10 (MAXimum)`**. The word "Objective" appears twice here, which is just a coincidence because the first appearance is a built-in term from the solver, and the second is the name we gave to our objective function (which also happened to be "Objective" for this simple problem).
3.  While knowing the **quality of the optimal solution** (10 in this case) is good, you generally also want to know **how to achieve that solution**â€”i.e., what decisions should be made to get there. Each decision outcome is linked to a variable value, so we basically want to know the **values of the variables** in the optimal solution. These values are provided in the **`Activity`** column of the second table. In this case, we can see that the optimal solution is achieved by setting both **`x`** and **`y` to 5**.

-----

### Final Notes

The takeaway from this section is that there are many formats for implementing (MI)LP models and plenty of solvers that can read and solve them. **Gurobi** and **CPLEX** are the proprietary, state-of-the-art solvers, and the **COIN-OR** project provides the best open-source alternative. For study purposes, we use **GLPK** and the **GMPL** language, which uses a simple syntax to represent variables, constraints, and objective functions. As the complexity of the model description grows, we will learn more elements of the language to formalize our models comfortably.

