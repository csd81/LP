
## Advanced Modeling Techniques: "Redundant" Variables

### Introducing "Redundant" Variables to Enhance Model Clarity

-----

### Prerequisites

  * Linear Programming: First Steps
  * Advanced GMPL Techniques: Data/Logic Decoupling

-----

### Motivational Example

For a couple of months, I was working in Oujda, Morocco. I decided to visit my friend Jacques in Capetown. Since I hadn't been to Africa many times before, I chose to travel by car so I could see more of that beautiful continent. My friend, Alae-Eddine, was kind enough to lend me his car for this trip, meaning the only expense I would have was the gasoline for the journey. Naturally, I wanted to minimize the total trip cost, so I planned in advance where and how much to refuel the car.

The trip was $11,000 \text{ km}$ long, and there were 22 gas stations along the way where I could buy gasoline at different prices. The following table shows the gas stations, their distance from Oujda, and the price of one liter of gasoline.

| Petrol station | Distance from Oujda (km) | Price of petrol (Dh/l) |
| :---: | :---: | :---: |
| Algeria1 | 320 | 100 |
| Algeria2 | 840 | 90 |
| Algeria3 | 1350 | 70 |
| Algeria4 | 2000 | 80 |
| Algeria5 | 2580 | 100 |
| Algeria6 | 3170 | 90 |
| Niger1 | 3560 | 120 |
| Niger2 | 4080 | 130 |
| Nigeria1 | 4660 | 140 |
| Nigeria2 | 5180 | 120 |
| Cameroon | 5500 | 150 |
| Gabon | 5950 | 160 |
| Congo1 | 6749 | 110 |
| Congo2 | 6990 | 130 |
| Angola1 | 7440 | 120 |
| Angola2 | 7960 | 130 |
| Angola3 | 8410 | 120 |
| Namibia1 | 8730 | 140 |
| Namibia2 | 9250 | 150 |
| Namibia3 | 9770 | 130 |
| SouthAfrica1 | 10350 | 140 |
| SouthAfrica2 | 10670 | 120 |

The car's tank capacity was at most $70 \text{ liters}$ of gasoline, and on average, it consumed $7.5 \text{ liters of gasoline per } 100 \text{ km}$.

Although I was eager to minimize my costs, I wanted to be safe. That is, I did not want to arrive at a gas station with an empty tank. My safety measure was to always have enough gasoline for an additional $50 \text{ km}$. Finally, when I started in Oujda, the tank was full.

The question is straightforward: where and how much did I fill the car's tank to reach Capetown with minimal costs?

-----

### The First Mathematical Model

#### Sets and Parameters

There is only one relevant set in this problem, the set of gas stations. We can simply define it as follows:

```glpk
    set Stations;
```

Now we can introduce the next two parameters that are given for all stations:

```glpk
    param petrolPrice{Stations};
    param distance{Stations};
```

And we also have some "global" parameters that are specific to our car ride:

```glpk
    param initialTank;
    param tankCapacity;
    param totalDistance;
    param fuelConsumption; 
```

#### Variables

There is only one variable needed: the amount of fuel we put into our tank at each station:

```glpk
    var fill{Stations} >= 0;
```

#### Constraints

The first constraint must express that we have enough fuel to reach a station, plus the safety measure. All the fuel we have added to our tank so far, plus the initial amount, must be sufficient for that distance. This could be expressed by the following constraint:

```glpk
    s.t. Has_to_meet_safety_measure {s in Stations}:
      (initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2]) * (100 / fuelConsumption) >= distance[s]+safetyMeasure;
```

Here, the term `initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2]` summarizes how much fuel we had put into our tank so far (including the initial amount), which must be multiplied by $100 / \text{fuelConsumption}$ to get the distance allowed by that amount. The RHS is simply the distance to the station plus the safety measure. Note that the filter `distance[s2] < distance[s]` makes the sum cover only the preceding stations.

A similar constraint must be added to specify that we should have enough fuel to get to the final destination:

```glpk
    s.t. Need_to_reach_final_destination:
      (initialTank + sum {s in Stations} fill[s]) * (100 / fuelConsumption) >= totalDistance;
```

Finally, we cannot overfill the tank:

```glpk
    s.t. Can_not_overfill{s in Stations}:
      initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100) + fill[s] <= tankCapacity;
```

This constraint is similar to the first one: the LHS summarizes how much fuel is in the tank before leaving the gas station (initial + filled previously - consumed + filled now), and the RHS is simply the capacity of our tank.

#### Objective Function

The objective function is simply the minimization of the total cost:

```glpk
    minimize TotalCost:
      sum{s in Stations} fill[s]*fuelPrice[s];
```

#### Some Fancy Output

To have a nice output, the following could be added:

```glpk
    printf "Total cost: %g\n\n",TotalCost;

    for{s in Stations}
    {
      printf "%14s  (%5g km, %3g Dh/l): %5.2g + %5.2g ---> %5.2g l\n",s,distance[s],fuelPrice[s],
      initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100),
      fill[s],
      initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100) + fill[s]
      ; 
    }
```

#### The Overall Model

The overall model looks like this:

```glpk
param totalDistance; #km
param fuelConsumption; # l / 100 km 
param tankCapacity; # l
param initialTank, default tankCapacity; # l
param safetyMeasure; # km

set Stations;
param distance{Stations}; # km
param fuelPrice{Stations}; # Dh / l


var fill{Stations} >= 0;

s.t. Has_to_meet_safety_measure {s in Stations}:
  (initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2]) * (100 / fuelConsumption) >= distance[s]+safetyMeasure;

s.t. Can_not_overfill{s in Stations}:
  initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100) + fill[s] <= tankCapacity;

s.t. Need_to_reach_final_destination:
  (initialTank + sum {s in Stations} fill[s]) * (100 / fuelConsumption) >= totalDistance;

minimize TotalCost:
  sum{s in Stations} fill[s]*fuelPrice[s];

solve;

printf "Total cost: %g\n\n",TotalCost;

for{s in Stations}
{
  printf "%14s  (%5g km, %3g Dh/l): %5.2g + %5.2g ---> %5.2g l\n",s,distance[s],fuelPrice[s],
  initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100),
  fill[s],
  initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s] * (fuelConsumption / 100) + fill[s]
  ; 
}
```

With the following data file:

```glpk
param totalDistance := 11000;

param fuelConsumption := 7.5;

param tankCapacity := 70;

param safetyMeasure := 50;

set Stations:= Algeria1 Algeria2 Algeria3 Algeria4 Algeria5 Algeria6 Niger1 Niger2 Nigeria1 Nigeria2 Cameroon Gabon Congo1 Congo2 Angola1 Angola2 Angola3 Namibia1 Namibia2 Namibia3 SouthAfrica1 SouthAfrica2;

param:        distance  fuelPrice:=
Algeria1      320       100
Algeria2      840       90
Algeria3      1350      70
Algeria4      2000      80
Algeria5      2580      100
Algeria6      3170      90
Niger1        3560      120
Niger2        4080      130
Nigeria1      4660      140
Nigeria2      5180      120
Cameroon      5500      150
Gabon         5950      160
Congo1        6479      110
Congo2        6990      130
Angola1       7440      120
Angola2       7960      130
Angola3       8410      120
Namibia1      8730      140
Namibia2      9250      150
Namibia3      9770      130
SouthAfrica1  10350     140
SouthAfrica2  10670     120
;
```

#### The Solution

After solving this simple model, we get the following output:

```glpk
Total cost: 84572.7

      Algeria1  (  320 km, 100 Dh/l):    46 +     0 --->    46 l
      Algeria2  (  840 km,  90 Dh/l):     7 +    35 --->    42 l
      Algeria3  ( 1350 km,  70 Dh/l):   3.8 +    66 --->    70 l
      Algeria4  ( 2000 km,  80 Dh/l):    21 +    49 --->    70 l
      Algeria5  ( 2580 km, 100 Dh/l):    26 +    21 --->    48 l
      Algeria6  ( 3170 km,  90 Dh/l):   3.7 +    66 --->    70 l
        Niger1  ( 3560 km, 120 Dh/l):    41 +    29 --->    70 l
        Niger2  ( 4080 km, 130 Dh/l):    31 +    39 --->    70 l
      Nigeria1  ( 4660 km, 140 Dh/l):    26 +    16 --->    43 l
      Nigeria2  ( 5180 km, 120 Dh/l):   3.8 +    66 --->    70 l
      Cameroon  ( 5500 km, 150 Dh/l):    46 +    24 --->    70 l
         Gabon  ( 5950 km, 160 Dh/l):    36 +   7.2 --->    43 l
        Congo1  ( 6479 km, 110 Dh/l):   3.8 +    66 --->    70 l
        Congo2  ( 6990 km, 130 Dh/l):    32 +   5.8 --->    38 l
       Angola1  ( 7440 km, 120 Dh/l):   3.8 +    66 --->    70 l
       Angola2  ( 7960 km, 130 Dh/l):    31 +   6.5 --->    38 l
       Angola3  ( 8410 km, 120 Dh/l):   3.8 +    66 --->    70 l
      Namibia1  ( 8730 km, 140 Dh/l):    46 +    24 --->    70 l
      Namibia2  ( 9250 km, 150 Dh/l):    31 +    12 --->    43 l
      Namibia3  ( 9770 km, 130 Dh/l):   3.7 +    66 --->    70 l
  SouthAfrica1  (10350 km, 140 Dh/l):    26 +   1.2 --->    28 l
  SouthAfrica2  (10670 km, 120 Dh/l):   3.7 +    21 --->    25 l
```

-----

### A Different Way of Modeling the Problem

If a computer programmer were to look at the code above, they would probably consider it a bit "messy" because the term `initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2]` is repeated multiple times throughout the model. In the case of such redundancy in computer code, a programmer would likely introduce a function that can be called from different places.

In mathematical modeling, we can do something similar: we can introduce additional variables that represent calculated values based on other decision variables and parameters, which are used in many places.

```glpk
    var fuelAtArrival{Stations};
```

These variables will denote how much fuel we have when we arrive at a station. However, these variables do not represent a decision; they are calculated based on other "real" decision variables and parameters using equality constraints, like the one below:

```glpk
    s.t. set_fuelAtArrival{s in Stations}:
      fuelAtArrival[s] = initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s]/100*fuelConsumption;
```

We will refer to these kinds of variables as **redundant variables** from now on.

Now, some of the constraints and outputs can be simplified:

```glpk
    s.t. Has_to_meet_safety_measure {s in Stations}:
      fuelAtArrival[s] * (100 / fuelConsumption) >= distance[s] - (distance[s]-safetyMeasure); // Simplified as the distance term cancels out when using the full constraint

// Rephrased for clarity and correctness based on the previous constraint's logic:
// The fuel at arrival must be enough to cover the remaining distance (which is not right here)
// Let's go back to the original form and simplify:
// (initial fuel available) >= (fuel consumed to destination) + (safety margin fuel)
// initialTank + sum {s2 < s} fill[s2] >= (distance[s] * fuelConsumption / 100) + (safetyMeasure * fuelConsumption / 100)
// fuelAtArrival[s] is (initialTank + sum {s2 < s} fill[s2]) - (distance[s] * fuelConsumption / 100)
// So, the fuel required *at arrival* to meet the safety measure is:
// fuelAtArrival[s] >= safetyMeasure * (fuelConsumption / 100) 
```

The constraint should ensure that upon arrival at station $s$, we have enough fuel for the safety distance ($50 \text{ km}$). The amount of fuel needed for the safety distance is:
$$\text{fuelAtArrival}_{\text{safety}} = \text{safetyMeasure} \times \frac{\text{fuelConsumption}}{100}$$
Therefore, the constraint becomes:

```glpk
    s.t. Has_to_meet_safety_measure {s in Stations}:
      fuelAtArrival[s] >= safetyMeasure / 100 * fuelConsumption;
```

And the capacity constraint:

```glpk
    s.t. Can_not_overfill{s in Stations}:
      fuelAtArrival[s] + fill[s] <= tankCapacity;
```

And the output:

```glpk
    for{s in Stations}
    {
      printf "%14s  (%5g km, %3g Dh/l): %5.2g + %5.2g ---> %5.2g l\n",s,distance[s],fuelPrice[s],
      fuelAtArrival[s], fill[s], fuelAtArrival[s] + fill[s]
      ; 
    }
```

If we look at the simplified first constraint, $\text{fuelAtArrival}[s] \ge \text{safetyMeasure} / 100 \times \text{fuelConsumption}$, it can even be eliminated and moved to a lower bound for the variable:

```glpk
    var fuelAtArrival{Stations} >= safetyMeasure / 100 * fuelConsumption;
```

### Final Look

So, the final version looks like this:

```glpk
param totalDistance; #km
param fuelConsumption; # l / 100 km 
param tankCapacity; # l
param initialTank, default tankCapacity; # l
param safetyMeasure; # km

set Stations;
param distance{Stations}; # km
param fuelPrice{Stations}; # Dh / l


var fill{Stations} >= 0;
var fuelAtArrival{Stations} >= safetyMeasure / 100 * fuelConsumption;

s.t. set_fuelAtArrival{s in Stations}:
      fuelAtArrival[s] = initialTank + sum {s2 in Stations: distance[s2] < distance[s]} fill[s2] - distance[s]/100*fuelConsumption;

s.t. Can_not_overfill{s in Stations}:
  fuelAtArrival[s] + fill[s] <= tankCapacity;

s.t. Need_to_reach_final_destination:
  (initialTank + sum {s in Stations} fill[s]) * (100 / fuelConsumption) >= totalDistance;

minimize TotalCost:
  sum{s in Stations} fill[s]*fuelPrice[s];

solve;

printf "Total cost: %g\n\n",TotalCost;

for{s in Stations}
{
  printf "%14s  (%5g km, %3g Dh/l): %6.3f + %6.3f ---> %6.3f l\n",s,distance[s],fuelPrice[s],
  fuelAtArrival[s], fill[s], fuelAtArrival[s] + fill[s]
  ; 
}
```

The same data section can be used, and the output is exactly the same as above.

-----

### Readability / Maintainability Over Performance?

One could rightly raise the point that we have made a poor trade-off, as our model now has twice as many variables, which theoretically means solving it will be slower. That is true in theory; however:

  * Adding a few continuous variables does not significantly increase the difficulty of solving the problem.
  * A sophisticated solver will likely recognize this and eliminate them.
  * Some languages may explicitly support this, like **defined variables** in AMPL.
  * Sometimes, especially for easy-to-solve problems with complex constraints, maintainable code is much more important.
  * If the model is extended later, these variables may prove to be very useful.

-----

### Exercise for You

The model could be transformed even further based on the following idea: the fuel level in the tank at a station is simply the level when leaving the last station minus the fuel consumed since then. Create a model that calculates the $\text{fuelAtArrival}[s]$ values based on this concept.

A little help: in the model, it will be important to refer to the *previous* station, which is difficult with the current set and parameter definitions. Changing the format of the input data to the following can solve this issue:

```glpk
    param stationCount;
    set Stations:=1..stationCount;
    param stationName{Stations} symbolic;
```

and in the data section:

```glpk
    param stationCount := 22;
    param:
          stationName   distance  fuelPrice :=
      1   Algeria1      320       100
      2   Algeria2      840       90
      3   Algeria3      1350      70
      4   Algeria4      2000      80
      ...
```

-----

### Final Notes

The purpose of this lesson was to introduce a new modeling technique that can often make our models much simpler and more transparent.